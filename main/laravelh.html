<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>laravel</title>
</head>
<body >

	<pre>
		<code>


			<?php

تفاوت کتابخانه و فریم ورک

هر دو کدهایی هستند که از قبل نوشته شده اند و باعث می شوند یکسری مشکلات رایج برنامه نویسی بدون وقت اضافه برای نوشتن کدهای از
ابتدا حل شوند

*library

کالکشنی از کلاس ها و متودها است. 
وقتی شما از کتابخانه استفاده میکنید در واقع این شما هستید که کنترل جریان کار را در دست دارید و این شما هستید که 
تعیین می کنید در کجا و کی از چه کتابخانه ای استفاده شود.
مثل اینکه می خواهید در کتابخانه کتاب انتخاب کنید.

*Framework
مجموعه کاملی از لایبری ها یا کتابخانه ها است.
در این مورد کنترل حریان برنامه دست فریم ورک است و چارچوب و اسکلت کد شما توسط اون فریم ورک تعیین می شود
این فریم ورک است که تصمیم می گیرد کی و کجا از کدهای شما استفاده کند
مثلا به شما کتابی داده می شود که شما باید جاهای خالی کتاب را پر کنید.


توجه از کتابخانه ها در هر زمان و هر مرحله از پروژه که خواستید می توانید استفاده کنید اما از فریم ورک باید از همان ابتدای شروع پروژه 
استفاده کنید.
در یک پروژه می توانید از چند کتابخانه ایتفاده کنید  اما از فریم ورک نه
فرمی ورک خیلی پیچیده تر است.


فریم ورک سرعت کدنویسی ما را چند برابر می کند.
کدهای منظم د ر فریم ورک ها بسیار بهتر است.


در ابتدای داکیومنشت لاراول گفته است که به چه چیزی هاییی مثل چه ورژنی از 
php 
نیاز دارد. حتما آن را بررسی کنید.



------------------------------------


ابتدا از سایت
getcomposer.org
کامپوزر را دانلود و با ادرس دهی فایل
php.exe 
در پوشه ومپ یا زمپ آن را نصب می کنیم
بعد رد cmd
کلمه
composer
را می نویسم و اینتر می زنیم تا اطلاعات بیاید اگر اطلاعات با نوشته بزرگ کامپوزر آمد یعنی کامپوزر به درستی نصب شده است

#################################

/// install laravel

php  باید بالای 7 باشد




به دو شکل می توان لاراول را نصب کردن

1. Global

Composer global require laravel/installer

در پوشه کامپوزر در داخل درایو سی به صورت گلوبال نصب می شود 
و هرجای سیستم که خاستیم تنها کافی است در 
cmd
 به آنجا ببریم با 
 cd
 وبعد دستور زیر را بزنیم تا
پروژه لاراولی ما ایجاد شود


laravel new Folder_mord_nazar_name (e.g. ali)





2. local 
composer create-project laravel/laravel example-app

به جای 
example-app
اسم پروژه خود را قرار دهید




در داخل داکیومنشن سایت 
laravel.com
بخش مربوط به لاراول با کامپوزر را انتخاب ودر 

cmd

مثلا

d:  -> enter

cd D:\wamp\www\newlaravel ->enter

paste دستور کپی شده از سایت لاراول --> Enter


دستور کپی شده به شکل زیر است
(composer create-project laravel/laravel example-app)


صبر کنید تا نصب شود

#################################
وقتی پیام 
application key fks;ldfksld;fk;s   set sussefully

آمد آن را حتما کپی کرده وذخیره می کنیم که کاریش داریم

بعد به پوشه محل نصب بروید و ببیندی که حجم پوشه بالای مگابایت باشد تا مطمئن باشیم نصب شده

#################################

وارد ترمینال IDE می شوید و کد زیر را می نویسید

php artisan serve --> کنسول php
--->enter

می آورد
آدرس
ادرس را کپی و در مروگر پیس دهید تا اولین سایت را ببنید


زمانی که کارتان تمام شد و خاستید پروژه را 
off
کنید
و 
cmd 
را از حالت رانینگ لاراول خارج کنید در 
cmd  ==> ctrl + c




---------------------------------------------------------------------session 2

پوشه بنندی ها در لاراول



هسته برنامه و تمام فایل های اصلی داخل این پوشه است.
app=> Console  === شامل دستورات artisan
app => Exception ==> کنترل خطاها

app ==> http ==> Controllers
		http ==> Middleware ==> میان افزار و مکانیسمی برای ارسال درخواست و پاسخ ==> اعمال برخی فیلترها روی کنترلر
		http ==> kernel.php => laravel core

app ==>Providers  

app ===> Models

#################################

bootstrap ==> معنی لغوی یعنی راه اندازه
این پوشه با فریم ورک بوت استرپ در 
css
فرق دارد و راه اندازه پروژه ما است
bootstrap==> cache ==> تمام فایل هایی که مورد نیاز است را برای ما کش می کند.
bootstrap==> app.php ==> شروع کننده و راه انداز پروژه ما

#################################
config ===> شامل تمام فایل های پیکربندی ما 

#################################
database ==> کار و مدیریت دیتابیس

database ==> factories  ==> ایجاد داده های ساختگی برای جداول دیتابیس
database ==> migrations  ===> طراحی جداول دستابیس به روشی بسیار ساده
database ==> seeders ==> تست دیتابیس

#################################
public ==> .htaccess
public ==> index.php ==> شروع درخواست های ما

#################################

resoures ==> views  ==> views
resoures ==> js  ==> views
resoures ==> lang  ==> views
resoures ==> css  ==> views

#################################
routes ===> مسیردهی

routes ===> web.php  ==> دستیابی به مسیرها از طریق وب
routes ===> api.php   ==> برای مسیرهایی که از طریق  ای پی آی درخواست می شوند
routes ===> channels.php ===> 
routes ===> console.php  ===> تعیین مسیرهایی که از طریق خط فرمان ارسال می شوند 

#################################
storage ===>  فایل هایی که در حریان پروژه ساخته یا کامپایل می شوند در این پوشه قرار داده می شوند.

storage ===> app ==> فایل های تولید شده در حین پروژه
storage ===> framework  ==> ذخیره فایل ها و کش های پروژه
storage ===> logs ===>  ذخیره لاگ های پروژه

#################################
tests ==> فایل های برای تست

#################################
vendor ==> وقتی کامپوزر را نصب می کنیم این پوشه ایجاد میشود

#################################

.env  ==> تنظیمات کانفیگ
server.php  ==> مانند یک سرور پشتیبانی عمل می کنه و باعث میشه پروژه ما ران بشه و بتوانیم آن را روی مرورگز مشاهده کنیم

webpack.mix.js ==> تنظیمات پکیج میکس لاراول




---------------------------------------------------------------------session 3

Extensions for laravel in vscode

bracket pair colorixze  ===> براکت ها را برای استفاده بهتر رنگی می کند

php Extension pack
vscode -icons

laravel extension pack
php namespace resolver

electron themem


---------------------------------------------------------------------session 4


Laravel Architecture              ||   معماری لاراول


--------------- service container

DI ==> Dependency Injection       تزریق وابستگی ها

به کلاس ها و کتابخانه های یک پروژه  وابستگی های آن می گویند.

یک الگوی طراحی یا دیزاین پترن است.

باید کمترین وابستگی را بین کلاس ها ایجاد کنیم.


IoC   ===> Inversion of Control           اصل وارونگی کنترل

در این مبحث باید به جای اینکه داخل یک کلاس از کلاس های دیگر استفاده کنیم باید
کدها را به شکلی بنویسم که برای مثال اگر به اتصال به دیتابیس نیاز داشتیم
به جای اتصال از داخل کلاس == اتصال را در خارج از کلاس براقرار کنیم و بعد متغییری که اطلاعات اتصال در ان ق
رار دارد را به متود constractor کلاس مورد نظر پاس بدهیم


class photo{
	protected $db;
	
	public function __construct(){
		$this->db = DB::getConnect();
	}
}

این روش درست نیست زیرا کلاس فوتو به کلاس 

DB
وابسته است و ممکن است بعد کلاس دی بی مشکلی پیدا کند یا ...
که در این صورت این کلاس هم با مشکل مواجه می شود.

class photo{
	protected $db;
	
	public function __construct($dbConn){
		
		$this->db = $dbConn;
		
	}
}

$photo = new photo($dbConn);

$dbConn ===> قبلا به دیتا بیس متصل شده است.


روش دیگر استفاده از     getter    &  setter


class photo{
	protected $db;
	
	public function __construct(){}
	
	
	
	public function setDB($dbConn){
		
		$this->db = $dbConn;
		
	}
}
$photo = new photo;

$photo->setDB($dbConn);


و حالا روش عالی برای ار بین بردن تمام وابستگی ها 


class IoC{  //container
	protected $db;
	
	
	public static function newPhoto(){
		
		
		$photo = new photo;
		$photo->setDB(static::$db);
		
		return $photo;
		
	}
}
$photo =IoC::newPhoto();


################################



service container ===>  برای مدیریت وابستگی های کلاس ها  

in bootstrap folder  -->app.php   شروع کننده پروژه

از اینجا لاراول شروع به کار می کند.

ابتدا یک شی از 
Application
ایجاد و آن را داخل
$app
قرار می دهد

$app = new Illuminate\Foundation\Application


به جای 
var_dump
در لاراول می توانید از
dd();
استفاده کنید که مخفف
dump and die  
است


dd($app);  ===> شی که از اپلیکشن ایجاد شده است را برمی گرداند


بعد از ما 
3
تا سینگلتون داریم که همان 
ioc Container
ما است


app()->bind("ali",function(){
	return 10;
});

$ali = app()->make("ali");

echo $ali;

ما می توانید با متود 
bind
می توانیم یک نام بگذاریم در قسمت 
key
بعد در قسمت 
value
نام کلاس مورد نظرمان را بدهیم و بعد مانند روش بالا
make
کنیم
در این صورت خودش می رود از روی کلاس مورد نظر که اسمش را داده ایم یک شی می سازد و بعد 
اگر 
Dependency
یا وابستگی داشته باشد به آن اضافه می کند و مقدار را برمی گرداند  و نیازی نیست ما خودمان را درگیر وابستگی ها کنیم.

تفاوت    bind   & singleton

وقتی از بایند استفاده می کنیم هربار که 
make
صدا زده می شود یک بار دیگر کلاس اجرا می شود و مثلا اگر کار کلاس برگرداندن عدد رندوم باشد
عدد جدیدی برمی گیرد
اما در 
singleton
تنها یک بار کلاس اجرا می شوند و هربار دیگر که 
make
صدا زده شود همان مقدار اول را بر می گرداند.

app()->bind("ali",function(){
	return rand(10,50);
});

$ali = app()->make("ali");
$ali2 = app()->make("ali");
$ali3 = app()->make("ali");

echo $ali."<br>";
echo $ali2."<br>";
echo $ali3."<br>";
// return  deffrent  number




app()->singleton("ali",function(){
	return rand(10,50);
});

$ali = app()->make("ali");
$ali2 = app()->make("ali");
$ali3 = app()->make("ali");

echo $ali."<br>";
echo $ali2."<br>";
echo $ali3."<br>";
// return only  one number

singleton ==> از هر کلاس تنها و تنها یک شی ایجاد شود








---------------------------------------------------session 4  (12)

bind a class to service container



به جای اینکه به فایل 

bootstrap ==> app

برویم و کلاس های خود را بایند کنیم لاراول امکانی تحت عنوان 
provider
ها را در اختیار ما برای این کار قرار داده است





in app folder    ===> provider


هر 
app service provider

دو بخش دارد 
1. 
public function register()
    {
        //
    }
در این قسمت ما ثبت می کنیم 

2.

public function boot()
    {
        
		
    }

در این قسمت اجرا می شود


زمانی که پروژه اجرا می شود  لاراول ابتدا به سراغ سرویس کانتینر  می رود 
وبعد  به سراغ
service provider
می رود بررسی می کند که چه مواردی وجود دارند تا آن ها را به 
service container
متصل کند.

تنها در 
register        and    boot
می توانیم از   بایند یا سینگلتون سرویس کانتینر می توانیم استفاده کنیم

و در این قسمت نباید از بقیه سرویس ها مانند   
route   or  event

استفاده کنیم

------------------------
دو روش برای ساخت  یک فایل   
provider 
جدید وجود دارد
1.
داخل پوشه پرووایدرها   یک فایل جدید بسیازید بعد  
namespace
و اکستندهایی که در فایل های دیگر قرار دارد را در آن قرار دهید یا از فایل های دیگر کپی کنید و بقیه کارتان را ادامه دهید
2.
استفاده از دستور  ارتیسان
php artisan 
بزنید در 
cmd
دستورات مربوط به ارتیسان را می آورد که در آن ها 
make provider
هم وجود دارد

in cmd   

php artisan make:provider --help  ===> می دهد که کار برد این چیست و به چه پارامترهایی نیاز دارد
 
این دستور تنها یک نام برای کلاس می خواهد

php artisan make:provider DBServiceProvider  ===>  ساختن فایل با کلاس در پوشه پرووایدرها

در حالت عادی این سرویس جدید ران نمی شود و باید به آن بفهمانیم که همچین فایل و سرویسی هم وجود دارد

in config folder  ===> app.php


go to  Autoloaded Service Providers  part  

in  Application Service Providers...

copy and add    App\Providers\DBServiceProvider::class,
به جای   
DBServiceProvider
اسم سرویس مورد نظرمان را قرار می دهمی


::class  ===>  یعنی   namespace    و   اسم  کلاس قبلش را برنمی گرداند
===> App\Providers\DBServiceProvider  ==> این را برمیگرداند



---------------------------------------------------session 5  (13)

Request Lifecycle  ===>     چرخه حیات درخواست

یعنی زمانی که یک درخواست به لاراول می آید چه مراحلی طی می شود تا به آن درخواست پاسخ داده شود.

'User'   -->send HTTP Request to  'web serve'  ---> 'public/index.php'

در این فایل     ---> require __DIR__.'/../vendor/autoload.php';
صدا زده می شود
و توسط تمام کلاس هایی که مورد نیاز است لود می شوند

سپس این را که سرویس کانتینرها 
در آن قرار دارند فراخوانی می کند
---->
$app = require_once __DIR__.'/../bootstrap/app.php';



---->  بعد ایجاد یک کلاس از کرنل و ارسال اطلاعات
//index.php


$kernel = $app->make(Kernel::class);

$response = tap($kernel->handle(
    $request = Request::capture()
))->send();

$kernel->terminate($request, $response);



// register    یعنی  ثبت  
---> service provider  register

---> service provider  boot

--> dispatch request to Router   
// ارسال درخواست تو روتر

روتر برسی می کند که این درخواست مربوط به کدام کنترلر است و به همان کنترلر ارسال می شود


-->send to controller  --- > اجرای دستورات و درخواست ها 


---> send  to view  ---> send HTTP Response to 'User'






---------------------------------------------------session 6  (14)


Facades  in Laravel

به معنی نمای خارجی است و یک الگوی طراحی یا دیزاین پترن است
به این دلیل به این اسم نامیده می شود که جزئیات نرم افزار را پنهان می کند

به شما اجازه می دهد که به صورت استاتیک به سرویس کانتینرها دسترسی داشته باشید

static

بر ای مثال در 
routes folder  -->  web.php

Route::get('/', function () {
    return view('welcome');
});

Route::get  --> استاتیک   //  یک نوع فساد

فساد ها در
config folder  ---> app.php
تعریف شده اند

بخش     aliases


---------------------------------------------------session 7  (15,16)

contracts in laravel              قرارداد در لاراولی

##################################

################################

in view --- اولین فایل   --- welcome.blade.php  ---> صفحه خوش آمدگویی

#################################
blade ---> engine قالب ساز   laravel

blade {{}}

{{$name}} 
به طور خودکار عملیات اسکیپ و حذف کاراکترهای مخرب را انجام می دهید
همچنین تگ های  html   را به صورت رشته و بدون اثر برمی گرداند 


اگر نیاز بود که عملیات اسکیپ انجام نشود و تگ ها کار کنند باید تگ ها را به این صورت بنویسیم
{!! $name !!}


اگر نیاز بود که رندر  روی  {{}}   انجام
نشود و خودش چاپ شود تنها کافی است قبل از آن یک 
@
قرار دهیم

@{{$name}} 


کامنت بلید به شکل زیر است
{{-- {{$name}} --}}
{{-- <br/> --}}


ویو در پوشه 
storege ==> framwork == view
به صورت یک فایل با نام هش شده کامپایل می شود

در حقیقت این فایل های کامپایل شده هستند که به ما و کاربر نمایش داده می شوند در مرورگر  و نه کدهای بلید

//e($name) ==>  درفایل های کامپایل شده این مورد یک   هلپر    فانکشن است که داده های را فیلتر می کند.

به دستورات   بلید   
directive 
می گویند


php cs fixer  ===>   اکستنشن برای فرمت کردن کدهای    php



---------------------------------------------------session 8  (17,18)

=======   ======   condition in blade 

@if()
	#code
@endif

-----------

@if($count>5)
	{{$count}} > 5
@endif
		
-------	
@if($count>5)
	{{$count}} > 5
@else
	{{$count}} < 5
@endif

-----------


@if($count==10)
	hoooy 10
@elseif($count>10)
	hooy up 10
@else
	hooy down 10
@endif


-----
unless

برعکس دستور
if
است و اگر شرط اشتباه بود دستور را اجرا می کند

@unless($count < 5)
	isit Down
@endunless

در این دستور اگر 
count
بزرگتر از   5
باشد دستورات و کدها اجرا می شود 

// حالت کمپایل شده

if($count<5){}  //if
if(!($count<5)){}  //unless


------------------

@switch($count)
	@case(1)
		count 1
		@break;
	@case(4)
		count 4
		@break;
	@case(9)
		count 9
		@break;
	@default
		switch ===> {{$count}}
@endswitch



=======   ======   loop in blade 

@for($i=0; $i<10; $i++)
	The Current val is {{$i}} <br>
@endfor

----------

@foreach($lists as $list)
	<li> {{$list}} </li>
@endforeach


--------
forelse in blade

این دستور می آید بررسی می کند که لیست خالی نباشد
اگر خالی بود پیام 
no list
که ما مشخص کرده ایم را نمایش می دهد
و اگر لیست پر بود مانند   
foreach
عمل می کند

@forelse($lists as $list)
	<li> {{$list}} </li>
@empty
	<p>No list<p>
@endforelse


------------------
گاهی می خواهیم در قسمتی از برنامه یک متغییر را تعریف کنیم و در قسمت دیگر از آن استفاده کینم و نیاز به تگ ها 

<?php  ?>

داریم

@php   ===> <?php

@endphp  ===> ?>


----------------
@php  
	$u=5;
@endphp  


@while ($u<10)
	The Current val is {{ $u }} <br>
	
	@php  
		$u++;
	@endphp 

@endwhile



################################################



route folder --> web.php ---> کل سیستم روتینگ لاراول 

Route::get("/",function()){
	return view("welcome"); /// این اسم فایل با همین نام با پسوند    .blade.php
	// را لود می کند از داخل ویوها
}

/// create new route  --> copy code and paste and change
Route::get("/post",function()){
	return view("post"); // view ==> helper function
}


send data to view

in terminal  ---> php artisan serve ---> enter

// روش اول
Route::get("/post",function()){
	$txt="Academy it";
	return view("post")->with("txt",$txt)
					   ->with("txt2",$txt)
					   ->with("txt3",$txt)
	;
}
// now in post.blade.php 
//در محلی که مدنظرمان است

echo $txt; OR {{$txt}} // second better

#################################

comment blade laravel --->  {{--{{$txt}}--}}

####################################

// روش دوم


Route::get("/welcome",function()){
	$urls=[
		"http://academyit.net",
		"http://academyit.ir",
		"http://academyit.com"
	];
	return view("post",compact('urls'));
}
// now in post.blade.php 
//در محلی که مدنظرمان است

foreach($urls as $url):
echo "<li> $url </li>";
endforeach; 


OR  // second better

@foreach($urls as $url)
	<li>{{ $url }}</li>
	<a href="{{$url}}">{{ $url }}</a>
@endforeach





---------------------------------------------------session 9  (19,20)

template inheritence       وراثت  صفحات در تمپلت

ابتدا یک 
layout  
اصلی  یا
master layout 

می  سازیم 
و بهتر است آن را داخل یک پوشه برای منظم تر شدن کدها قرار دهیم

سپس قسمت هایی که قرار است در صفحات دیگر تکرار شود را داخل آن قرار می دهیم و در صفحات دیگر 
آن را فراخوانی یا اکستند  می کنیم

@extends("layouts.master")
@extends("folder nade  .  file name")

. ==> /
در لاراول برای مسیر دهی از  
.
به جای 
/
استفاده می کنیم  


سپس داخل 
master
قسمتی که قرار است تغییر داشته باشد در صفحات مختلف را پاک می کنیم وبه جای آن 
@yield('name')
قرار می دهمیم

==> name    کاملا اختیاری است


سپس در صفحه مورد نظر به کمک دایرکتیو

@section('name')

می گوییم که محتوای جایگزین قسمت 
yeild
چی باشد
توجه داشته باشید که نامی که به سکشن می دهید باید با نام 
yeild
مورد نظر که محتوا باید جایگزین آن شود   برابر باشد


------master page

@yield('content')

---- about page

@section('content')
<div>
		
	<h2>Index 2 Page </h2>
	<p>lorem lorem  lorem</p>
	
</div>
@endsection


اگر یک تکه کد داشتیم به این روش عمل می کنیم 

@section('content')

#code

@endsection

اما اگر یک استرینگ ساده داشتیم  به روش زیر عمل میکنیم

@section('title',"contact US")


#########################
include Directive

برای این کار بهتر است از یک پوشه بسازیم و ترجیحا اسم آن را 
partials
 قرار دهیم و بعد فایل هایی که قررا است اینکلود شود را درون آن قرار دهیم و بعد داخل فایلی که قرار است اینکلود در آن 
 انجام شود به روش زیر عمل می کنیم
 
 @include("parials.header")
 
 //parials.header ===> ادرس فایل  



 @includeIf
 
 دستور بررسی می کند که آیا فایلی که ادرس را به آن داده ایم وجود دارد یا نه 
 اگر وجود داشت اضافه می کند و اگر وجود نداشت کاری انجام نمی دهد
 
 اما اگر فایلی وجود نداشت و از 
  @include
  استفاده کردیم  ارور می دهد
  
  ------
  اگر فایل های 
  
  composer.json
  composer.lock
  را داشته باشیم می توانیم به راحتی پوشه وندور را بسازیم   تنها کافی است در پوشه لاراول دستور زیر را در 
  cmd
  بزنیم
  composer install





---------------------------------------------------session 10  (21)

section      &&   show          directive

گاهی 
yield
تعریف می کنیم اما می خواهیم یک مقدار  پیشفرص وجود داشته باشد که اگر در صفحات دیگر برای 
yield
مقداری در نظر نگرفتیم آن مقدار نمایش داده شود .
برای این کار ابتدا 
yield
را برمی داریم و به جای آن این دستور را قرار می دهیم

@section('name') Defalut Value   @show


اما اگر در صفحه اکشتند شده ما 

@section('name')
 را داشته باشیم لاراول این مورد را در نظر می گیرد و آن چیزی که ما به جای 
 yield
 قرار دادیم و در صفحه مستر قرار دارد   
 مقدار پیشفرص را نادیده می گیرد
 
 
 
 
 
 
 
 
 ---------------------------------------------------session 11  (22)

component   && slot


ابتدا یک پوشه می سازیم و با هر نام دلخواهی آن را نامگذاری می کنیم اما بهتر است آن را
components
قرار دهیم

سپس مقداری که می خواهیم را در آن قرار می دهیم اما به جای مواردی که باید به آن پاس داده شود 
برای مثال اسم  دکمه یا  غیره باید از متغییر استفاده کنیم

<button class="{{$class}}">
{{ $title }} 
</button>


فراخوانی یک کامپوننت

//@component("components.button",[params])

@component("components.button",["title" => "sendComponent btn",
							    "class"=>"btn"])

@endcomponent


تعریف مقدار پیشفرض در فایل کامپوننت  تا اگر  پارامتر مورد نظر به آن پاس داده نشد  مقدار پیشفرض را در نظر بگیرد و   ارور ندهیم

@php
	$title=isset($title) ? $title : "title send";
	$class=isset($class) ? $class : "btn-blue";
@endphp


روش دیگر برای ارسال دیتا به کامپوننت ها   
slot
است

در حالت عادی ارسال دیتا ما تنها می توانیم استرینگ ارسال کنیم  اما با 
slot
ما می توانیم تگ 
html
هم ارسال کنیم


@component("components.input")

@slot("xxxxxx")
<mark>hooy</mark>
@endslot

@endcomponent


===recevie
@php
	$title=isset($title) ? $title : "title send";
	$class=isset($class) ? $class : "btn-blue";
@endphp

<input class="{{$class}}">
<h2>
{{ $xxxxxx }}
</h2>

##########################


اگر بین تگ های کامپوننت   اسلات  قرار ندهیم  و  یک  چیزی  بنویسم 

@component("components.input2")

<u>
Ali Started Laravel
</u>

@endcomponent


و   در  خود  کامپوننت به جای  مطلبی که قرار است جایگزین شود 



{{$slot}}

مقدار ارسال شده و نمایش داده می شود




 ---------------------------------------------------session 12  (23)
 Customize  Component    کامپوننت سفارشی 


// laravel  6

برای تعریف کامپوننت سفارشی ما باید به  سراغ
appServiceProviders
برویم چرا که می خواهیم یک سرویس جدید تعریف کنیم 

in  appServiceProvider.php 
in boot  part

Blade::component("component.button2","btn")
//Blade::component(address,custon name)

now
در فایل مورد نظر

@btn
<u>fdsf sdf sdf sd fdsf </u>
@endbtn


or

@btn
@slot("xxxxxx")
<mark>hooy</mark>
@endslot
@endbtn



// laravel 8 

کامپوننت سفارشی

in cmd   ===> php artisan make:component Component Name (paskal case)

// php artisan make:component forms/input


بعد از اجرای این دستور یک پوشه   
view  
در پوشه 
app
ایجاد می شود 
که بعد تنظیمات مربوط به ارسال پارارمتر را داخل آن قرار می دهیم 
و همچنین یک فایل داخل پوشه کامپوننت در بخش 
ویو ها ایجاد می شود که کدهای مربوط به کامپوننت را داخل آن قرار می دهیم

برای استفاده از کامپوننت هم تنها کافی است اسم فایل آن را  به صورت تگ صدا بزنیم

<x-forms />

اگر کامپونت را داخل یک پوشه ایجاد کردیم صدا زدن آن به شکل زیر می شود  مثلا از پوشه  فرمز   می خواهیم کامپوننت را فراخوانی کنیم

<x-forms.input />


############
ارسال پارامتر به کامپوننت

<x-forms.input type="errorrtttttttttttttt" :message="$message" />

دیتا ها را به عنوان  
attribute
به تگ پاس میدهیم و بعد به فایل ایجاد شده در 
app/view/components/xxxx.php
می رویم و داخل متود 
constract
این شکل عمل می کنیم


public $type;
public $message;

public function __construct($type, $message)
{
	$this->type = $type;
	$this->message = $message;
}


///  
دریافت در فایل کامپووننت هم به شکل زیر است

{{$message}}

{{$type}}


########################
slot
در کامپوننت سفارشی


// به شکل دیفالت
<x-componnet name >

<p>
<h1>Slot In laravel 8 </h1>
</p>

</x-componnet name >




<div>
  {{ $slot }}
</div>


// با نام


<x-forms.ali >


<x-slot name="sub">    <mark>This is a sub message (slot name)</mark>   </x-slot>


</x-forms.ali >



//recive

	{{ $sub }}
	
	

---------------------------------------------------session 13  (24)
دایرکتیو   سفارشی

1. simple
2. condition



---- simple
چون ما می خوامیم یک سرویس اضافه کنیم باید به 
appServiceProvider
برویم و داخل  
boot()

بنویسم
Blade::directive('blodX', function($text=null){
	return "<b>".$text."</b>";
});

سپس به راحتی آن را صدا می زنیم

@blodX(WebProg is rid)




---- condition directive 

in appServiceProvider

Blade::if("ISint" , function($txt=null){
	return is_int($txt);
});

// به این فانکشن ها که به عنوان پرامتر دوم  پاس می دهیم   =====>  کلوژر  می گویند

برای استفاده هم کافی است  

@ISint(12.2)
	this is  INT
@else
	this is Not  INT  XXXXX
@endif


---------------------------------------------------session 14  (25)
اضافه کردن فایل های استاتیک  مانند
css  -js  - font  and ....

به پروژه


in public folder

فایل ها را در این بخش قررا می دهیم

craate  css Folder and ........

سپس به 
resource/views
می رویم و هرجا که خواستیم از فایل ها استفاده می کنیم 

<link rel="stylesheet"  href="/css/style.css">
<script src="/js/main.js"></script>

توجه نیست مسیر دهیم کنید چراکه همچی از پوشه 
public
خوانده می شود

در حقیقت روند کاری  لاراول به این شکل است که تمام کدهایی که ما در قیمت  ویوها و در قالب  بلید می نویسم 
کامپایل می شوند و به صورت کدهای 
php
معمولی در می آنید و در  فایل 
index.php
در پوشه 
public
بارگذاری می شوند و به نمایش در می آید  یا به عبارتی در این فایل  اینکلود می شوند.

####
می توانم از این روش هم برای ادرس دهی فایل های استاتیک استفاده کنیم

<link rel="stylesheet"  href="{{ asset('/css/style.css') }}">
<script src="{{ asset('/js/main.js') }}"></script>


در
inspect 
روش نمایش اولین روش به شکل زیر است و ادرس  نسبی است 
/css/style.css

در روش دوم ادرس مطلق و به شکل زیر است

http://localhost:8000/css/style.css



---------------------------------------------------session 15  (26)

Comiling Assets (MIX)

اگر بخواهمیم در پروژه از 
sass  - Vue  - React   ........

استفاده کنیم
این موارد باید کامپایل شوند و به 
پوشه پابلیک
پاس داده شوند
و در آنجا در پوشه های مربوطه 
مثلا
scss
درcss folder
قرار بگیرند
لاراول برای کامپایل ابزاری دارد که کار ما را خیلی آسان می کند

این ابزار   
laravel mix
هستش

برای استفاده این قابلیت باید آشنایی نسبی با 

package.json
داشته باشیم که مربوط به
npm
است

همان گونه که اگر
composer.json
را داشتیم می توانستیم با دستور
composer install

پکیجها و پوشه  
vendor
را دوباره نصب کنیم

اگر 
package.json

را داشته باشیم می توانیم با دستور
npm install
پکیجها و 
dependcy
های موجود در آن را به راحتی همراه با پوشه 
node_modules
نصب کنیم


نحوه کار به این صورت است که ما داخل خود پوشه پروژه یک فایل داریم به اسم
webpack.mix.js

داخل این فایل یک دستور به شکل زیر است

const mix = require('laravel-mix');

در اینجا لاراول میکس فراخوانی میشود

mix.js('resources/js/app.js', 'public/js')
    .postCss('resources/css/app.css', 'public/css', [
        //
    ]);

سپس طبق این دستور فایل های 
app.js
کامپایل می شود و به صورت فایل مورد نظر در

public/js

قرار می گیرد که دقیقا همین موضوع برای 
sass  & less
هم صادق است

resources/css/app.css   ==> public/css


توجه داشته باشیم که فایل کامپایل شده با نام های 
app.js  & app.css
داخل پوشه پابلیک قرار می گیرد   پس فایل با این نام نداشته باشید  در پوشه پابلیک تا
overwrite
نشود روی آن ها


حالا برای شروع کار در 
cmd 
به پوشه لاراول برویم 
مثلا

dw/wamp/www/laravel8/example-app

سپس دستور 
npm install
را بزنید تا پکیج ها نصب شوند 

وقتی نصب شد نباید ارور داشته باشیم و همچنین 
پوشه 
node_modules
ایجاد شده باشد



##############
داخل
webpack.mix.js

خودمان می توانیم فایل های جدید برای کامپایل اضافه کنیم 

mix.js('resources/js/app.js', 'public/js')
   .js('resources/js/admin.js', 'public/js')
   .postCss('resources/css/app.css', 'public/css', [
        //
    ]
	.postCss('resources/css/admin.css', 'public/css', [
        //
    ]);


#########

حالا برای استفاده از دستورات به فایل
package.json
می رویم که در ابتدای آن دستورات لازم نوشته شده است
in scripts part

"scripts": {
        "dev": "npm run development",
        "development": "mix",
        "watch": "mix watch",
        "watch-poll": "mix watch -- --watch-options-poll=1000",
        "hot": "mix watch --hot",
        "prod": "npm run production",
        "production": "mix --production"
    },

---dev 
همان خلاصه شده دستور بعدی یعنی 
development
است

این دستور می آید کامپایل می کند و در داخل پوشه پابلیک فایل ها را قرار می دهد
ولی در خالت 
development
است و فایل ها خوانا هستند و شما می توانید آن ها را تغیرر دهید

--- watch
این دستور بررسی می کند که اگر ما داخل فایل های موجود در 
resource
تغییری ایجاد کردیم آن ها را کامپایل می کند و در پابلیک قرار می دهد
به عبار دیگر با  تغییرات ما در فایل ها دستور 

dev
اجرا می شود


---- prod
این برای زمانی است که شما کار پروژه تان به طور کامل تمام شده و می خواهید اپلود انجام دهید
این دستور می آید فاصله های اضافی را حذف می کند و فایل ها را 
minify 
می کند 


حالا در 
cmd
دستور 
npm run dev
را می زنیم تا فایل ها را کامپایل کند

حالا زمانی که 
successfully
داد به پابلیک بروید می بینید که فایل ها ایجاد شده است

برای استفاده از این فایل ها هم مثل فایل های استاتیک دیگر عمل می کنیم



---------------------------------------------------session 16  (27)

javascript & css  Scaffolding

Scaffolding ==> اسکت بندی

برای استفاده از 
bootstrap.css
vue
React

برای اینکار ما  برای آن که راحت تر باشده کارمون از 
laravel UI
استفاده می کنیم 
زمانی که دستور ات  این پکیج را اجرا می کنیم  
مثلا برای بوت استرپ 
می آید فایل های بوت استرپ را دانلود و خودش آن ها را با 
laravel MIX
منطبق می کند تا شما به راحتی از آن ها استفاده کنید


-- قدم اول  نصب   لاراول  یو آی
به سایل لاراول بروید بخش
frontend  ==> Scaffolding

در لاراول 
8 
به جای لاراول یو آی به سمت 
jetstream
رقته اند اما هنوز امکان استفاده از 
laravel UI
وجود دارد و باید به 
github 
برویم تا دستورات نصب آن را ببینیم

https://github.com/laravel/ui


composer require laravel/ui  ===> install

// Generate basic scaffolding...
php artisan ui bootstrap
php artisan ui vue
php artisan ui react


---------------------------------------------------session 17  (28)

Route::get   ==> get method
برای خواندن و نمایش لیست محصولات یا محصول تکی در فروشگاه  برای مثال

Route::post   ==> post method
برای ایجاد کردن است یا
create 
هستش

Route::put  ===> put method

برای آپدیت و ری پلیس است
این دستور یک رکورد را پاک می کند و مقدادیر جدید به جای آن قرار می دهد

Route::patch ===> patch method
برای آپدیت  مدیفای است
می آید فیلدهایی که دارای مقدار هست را فقط تغییر می دهد

Route::delete ===> delete method
برای پاک کردن  و حذف یک رکورد در پایگاده داده کاربرد دارد

Route::any ===> any method

هر دستور باشد را  عبور می دهد و مقدایر داخل تابع را برمی گرداند.



Route::get('/user', function(){}); 
اسلش را هم می توانیم قرار ندهیم به شکل زیر اما بهتر است قرار دهمیم
Route::get('user', function(){}); 


########################################
برای دیدن تمام 
route
های پروزه می توانیم از 
Artisan
کمک بگیریم

in cmd    
php artisan route:list

این دستور تمام روت هایی که داریم را به صورت یک جدول منظم برمی گرداند


---------------------------------------------------session 18  (29)

ارسال پارامتر
id
slug
و غیره به یک صفحع



Route::get("/course/{courseXXX}/{id}", function($courseXXX,$id){
	return $courseXXX."---".$id;
});

دادن پارامتر های اختیار با مقدار دیفالت

Route::get("/course/{courseXXX}/{id}/{def?}", function($courseXXX,$id,$def="ohh default"){
	return $courseXXX."---".$id;
});




---------------------------------------------------session 19  (30)
لینک دادن به صفحات مختلف

<a href="{{ url('/about') }}">about PAGE</a>

می توانیم به شکل عادی هم 
<a href="/about">about PAGE</a>

هما چون هلپر فانکشن 
url

آدرس را به شکل مطلق برمی گرداند بسیار بهتر است 

######################

گاهی 
url
های ما پیچیده است و با تعداد زیاد که در این صورت می توانیم از 
route name
استفاده کنیم


Route::get('/about', function(){
	return view('about');
})->name("aboutx");


نحوه استفاده 

<a href="{{ route('aboutx') }}">about PAGE</a>


برای استفاده از 
route('value')
باید حتما 
name
تعریف کرده باشیم وگرنه باید از 
url
استفاده کنیم


تعریف 
name
بسیار بهتر است و کدهای ما خوانا تر می شود


###############
ارسال مقدایر در این روش


Route::get("/vit/{courseXXX}/{id}/{def?}", function($courseXXX,$id,$def="ohh default"){
	return $courseXXX."---".$id."----".$def;
})->name("viti");


<a href="{{ route('viti',['courseXXX'=>'laravel','id'=>'65']) }}">vit PAGE</a>





---------------------------------------------------session 20  (31)


گاهی روت های شبیه به هم داریم و می خواهیم آن ها را دسته بندی کرده و راحت تر از آن ها استفاده کنیم
که در این صورت از 
route group
استفاده می کنیم

Route::get('/admin', function(){
	return "ADMIN";
//return view('contact');
});
Route::get('/admin/contact', function(){
	return "contactA";
});
Route::get('/admin/comment', function(){
	return "commentA";
});
Route::get('/admin/user', function(){
	return "userA";
});



این ها روت هایی هستند که همگی به 
admin مرتبط هستند
و  در آن ها کلمه ادمین وجود دارد


Route::prefix("admin")->group(function(){
	
	
	Route::get('/', function(){
	return view('contact');
	});
	Route::get('/contact', function(){
		return view('contact');
	});
	Route::get('/contact', function(){
		return view('contact');
	});
	Route::get('/contact', function(){
		return view('contact');
	});

	
});

در این روت گروپ ما موارد تکراری را حذف کردیم و به عنوان 
prefix
آن مورد تکراری را ست کردیم 



روش دوم برای تعریف    ==> prefix

Route::group(["prefix"=>"admin"],function(){
	
	
	Route::get('/', function(){
	return view('contact');
	});
	Route::get('/contact', function(){
		return view('contact');
	});
	Route::get('/contact', function(){
		return view('contact');
	});
	Route::get('/contact', function(){
		return view('contact');
	});

	
});



---------------------------------------------------session 21  (32)

Controller in Laravel


برای ایجاد کنترل دوتا راه داریم 
1
دستی فایل در بخش کنترل ها ایجاد کنیم
2
استفاده از 
Artisan


in cmd   ==>  php artisan 

در بخش 
make
ها مشاهده می کنیم که دستورات برای ساختن چیزهای مختلف وجود دارد که کنترلر هم جز آن ها است

php artisan make:controller --help

این دستور به ما میگوید که این دستور چه پارامترهایی می خواهد که تنها یک نام برای کنترلر است

php artisan make:controller  HomeController   ==> لاراول می گوید که به صورت پاسکال بنویسید



به متود های داخل کنترل یا همان فانکشن ها     اکشن   می گویند 

#############

برای صدا زدن کنترل از طریق روت در لاراول 
8 

Route::get('/cont2' , [controller name::class,'action']);

//  ====> method 1

use App\Http\Controllers\HomeController;
Route::get('/cont2' , [HomeController::class,'home']);
Route::get('/contAbout' , [HomeController::class,'about']);


//  ====> method 2
//Route::get('/cont2', 'App\Http\Controllers\HomeController@home');


// Controller
class HomeController extends Controller
{
    public function home(){
		return view("firstController");
	}
	public function about(){
		return view("about");
	}
}



ساخت کنترل در پوشه 

php artisan make:controller  Admin\AdminController
or
php artisan make:controller  Admin/AdminController


---------------------------------------------------session 22  (33,34)

resource Controller


برای ساخت 
in cmd 


php artisan make:controller  ArticleController -r

برای حالت عادی کارهایی که ما قرار است با مثلا مقالات و بخش آن انجام دهیم
شامل حذف  نمایش  اضافه کردن و ...
است که باید در داخل کنترلر خودمان بیاییم   اکشن یا متود برای هریک از این ها تعریف کنیم اما 
این روش یک کنترلر می سازد و تمام متودهایی که به آنها نیاز داریم را داخل آن قرار می دهد تا ما فقط تغییرات را در آن ها اعمال کنیم

create()  / create() /  store(Request $request) / show($id) /edit($id)

update(Request $request, $id)/  destroy($id)


جالبتر این است که در روت ها هم کارمان آسان تر شده است و به جای نوشتن روت 
هم برای ادیت و اد و  حذف و ...

تنها یک روت از نوع 
resource
می نویسیم

use App\Http\Controllers\ArticleController;
//Route::resource('articles',"App\Http\Controllers\ArticleController");
Route::resource('articles',ArticleController::class);

تمام روت های مورد نیاز با اکشن های بالا را برای ما ایجاد می کند

البته شما میتوانید به آن دستور دهید که فقط اکشن های خاصی را داشته باشد 
مثلا دستور پایین می گوید که فقط 
index()   and  show()
را از کنترلر بخوان 

Route::resource('articles',ArticleController::class)->only(['index','show']);

دستور پایین  هم می گوید همه را بخوان  به جز 
index()  and show()


Route::resource('articles',ArticleController::class)->except(['index','show']);



in resource controller

show($id) --->   id     ای دی مقاله ای که قرار است تغییرات روی آن اعمال کنیم
بعدا درموردش صحبت می شود



update(Request $request, $id)

Request $request --->  

Request ===>   اگر با ارتیسان کنترلر ایجاد کرده باشیم خود لاراول در ابتدای صفححه این را 
use
کرده است
Request $request   ==>  می گوید ریکوئست اول را بریز داخل
$request

{همان    --- > DI}

در کل این بدان معناست که سرویس کانتینر  می آید یک شی از روی 
Request
ایجاد می کند و وابستگی های مورد نیار را بهش می دهد و بعد آن را می ریزد داخل
$request


dd($request->all());   // تمام پارامترهایی که ارسال شده است را نمایش می دهد

http://127.0.0.1:8000/req?w=12&hop=225

array:2 [▼
  "w" => "12"
  "hop" => "225"
]


Route::get('/req/{id?}' , [HomeController::class,'req']);



public function req(Request $request ,$id="12"){
	dd($request->all(),$id); 
}


---------------------------------------------------session 23  (35,36,37)


اضافه کردن بوت استرپ به پروژه

برای این کار در خال حاضر از 
laravel UI
استفاده کنیم 

ابتدا آن را با این دستور به
package.json
اضافه و نصب می کنیم
php artisan ui bootstrap

بعد برای نصب پکیج های اضافه شده به 
package.json

دستور 
npm install  or  npm i
را می زنیم

حالا داخل پوشه 
resoure  --> app.scss
بوت استرپ را هم ایمپورت کرده است و تنها کافی است بزنیم
npm run dev
تا لاراول میکس اجرا شود و فایل های کامپایل شده ما در پوشه
public 
قرار  بگیرد 




البته اگر قبل کرده این دیگر نیازی نیست و تنها باید بقیه مراحل را انجام دهسد


گاهی متود فرم پست است و با سابمیت کردن  ارور
419
به ما می دهد که دلیل ان عدم قرار دادن
فیلد برای 
csrf
است
{{csrf_field()}}


موضوع 
csrf
یک 
middleware
است که لاراول آن را هندل می کند و ما می توانیم آن را در پوشه 
middleware
ها ببینیم

آن میدل ویر هایی که در بخش   
web
قرار دارند در هنگام دستورات ارسالی روی روت های    وب   اجرا می شوند
اگر 

in kernel.php   ===> $middlewareGroups

می توانیم با کامنت کردن 

\App\Http\Middleware\VerifyCsrfToken::class,

از این که در هنگام سابمیت درخواست  
توکن کند جلوگیری کنیم ولی بهتر است هیچگاه این را کامنت نکنیم چراکه یک متود امنیتی است


کار 
middleware
های این است که دستورات ما به روت های مختلف را بررسی می کند و اگر همچی اوکی بود   اونموقع دستور را پاس می دهند
به کنترلر تا ادامه کار انجام شود



در درخواست های نوع 
get
نیاز زیادی به این موضوع 
csrf
نداریم و خود لاراول هم گیر نمی دهد

دو راه پیاده سازی متود جلوگیری از 
csrf
 در فرم های 
 
 1.   {{csrf_field()}}
 2.    @csrf


برای دریافت درخوایت های ارسالی هم باید به روش زیر عمل کنیم

public function loginUser(Request $request){
		//dd($request->all());
		
		//$data = $request->get("email","default value");
		//$data = $request->get("email");
		
		//$data = $request->email;
		
		
		// check for exist value
		//$data = $request->has("email");  // return true
		//$data = $request->has("emails");  // return false
		
		// for get only   value  mored nazar
		//$data = $request->only("email");
		//$data = $request->only(["email","password"]);
		
		// به  جز
		//$data = $request->except(["email","password"]);
		
		// for get query string
		//$data = $request->query("email");
		$data = $request->query("email","default value");
		
		
		// get patamer e.g.  idpost
		//$data = $request->route()->parameter(''id);   //  مناسب نیست 
		
		//  بهتر است به همراه ریکوئست در ورودی این تابع آن را دریافت کنیم
		
		
		dd($data);
		
	}




---------------------------------------------------session 24  (38)


دسترسی به فایل ها 

باید به فرم  اتربیوت 

enctype="multipart/form-data"

را اصافه کنیم

برای دریافت فایل ها در کنترلر هم به روش زیر عمل می کنیم

// get file
//dd( $request->all() );
//$data= $request->files;
//$data= $request->file1;
//$data= $request->file("file2");

// check  exist  file
//$data= $request->hasFile("file2");  //return true  becuse exist
//$data= $request->hasFile("file3");  //return false  becuse not exist



//$data= $request->file("file2")->path();
//$data= $request->file("file2")->getFileName();
//$data= $request->file("file2")->getClientOriginalName();


$data= $request->file("file2");


dd($data);


---------------------------------------------------session 25  (39)

ریکوئست سفارشی در لاراول

in cmd

php artisan make::request --help

php artisan make::request name
php artisan make::request LoginRequest


زمانی که که اجرا می کنیم دستور را در پوشه 
app / Http
خودش یک پوشه با نام 
Requests
می سازد 

برای استفاده هم باید در فایل کنترلر آن را 
use
کنیم
برای این کار  اسمش را به جای ریکوئست در ورودی تابع می نویسم سپس آن را سلکت می کنیم
و 
ctrl + alt + i   ===>vscode

را می زنیم تا خودش آن را 
use
کند


use App\Http\Requests\LoginRequest;

public function loginUser(LoginRequest $request){
		dd($request->all());
}



حالا باید اگر اجرا کنیم یک ارور می دهد

403 | THIS ACTION IS UNAUTHORIZED.

authorize  === سطح دسترسی



این ارور می گوید که دسترسی به کاربر داده نشده است
فعلا برای حل آن لازم است به فایل ریکوئستی که ایجاد کردیم بریم و 
false
را
true
کنیم

public function authorize()
    {
        //return false;   ====>  return true;
        //
    }


public function rules()
    {
        return [
            //
        ];
    }
این مورد هم برای 
validation
ورودی های ارسالی است



---------------------------------------------------session 26  (40)

>>>>>     validation


IN LARAVEL   (;)    dont needed

in site laravel  --the basic  --> validation

اطلاعات کامل در مورد   اعتبار سنجی ها در این قسمت قرار دارد



in controller

$data = $request->validate([
			
	"email" => "required"

]);

اگر حالا ایمیل ازسال نشود یک فلش   سشن  ارور به ما می دهد که تنها یکبار دریافت می شود و ما می توانیم آن را به شکل زیر ببینیم

{{ dd( $errors->all() ) }}



@if($errors->all())
	<div class="alert alert-danger">

		@foreach($errors->all() as $error)
		
				{{$error}}
			
		@endforeach

	</div>
@endif


ارور برای یک فیلد تکی 

@if($errors->has('email'))
		
	<span class="text-danger">{{$errors->first('email') }}</span>
	
@endif


روش خیلی ساده تر به کمک دایرکتیو

@error('email')
	<span class="text-danger">{{$message }}</span>
@enderror




حالا ما می توانیم همین اعتبار سنجی را هم در بخش 

rules

در ریکوئست سفارشی که ساختیم پیاده سازی کنیم


public function rules()
    {
        return [
            "email" => "required",
			"password" => "required"
        ];
    }


---------------------------------------------------session 27  (41)

بررسی بیشتر  
validation
ها

public function rules()
{
	return [
		"email" => "required|email",
		"password" => "required|integer",
	];
}
	
	
زمانی که ارور داریم    اینپوت ها   خالی می شوند که این
ux
ضعیفی هست و برای حل کردن آن می توانیم به شکل زیر عمل کنیم

به اینپوت مورد نظر 

value="{{ old('email') }}"
	
البته این روش برای اینپوتها 
password
به درستی عمل نمی کند  چون  نشان دادن پسورد یک ضعف امنیتی است


یک کار بهتر این است که شما طور تنظیم کنید که اگر ارور  نداشتیم مقدار را خالی  نکند  و اگر  ارور  بود خالی کند 


value="    @unless($errors->has('email'))       {{  old('email') }}            @endif     "



public function rules()
    {
        return [
            "email" => "required|email",
			"password" => "required|       max:5     ",  //min:5
        ];
    }


	public function rules()
    {
        return [
            "email" => "required|email",
			"password" => "required|max:5",
			"id" => "array",
			"id.*" => "string"
        ];
    }
	
	public function rules()
    {
        return [
            "email" => ["required","email"],
			"password" => "required|max:5",
			"id" => "array",
			"id.*" => "string"
        ];
    }
	
	

---------------------------------------------------session 28  (42)

فارسی سازی  ارورها

 
in resource folder   ===> lang
می توانیم فایل های داخل این پوشه را برای بخش های دیگر ترجمه و فارسی سازی کنیم


بعد از قرار دادن پوشه فایل های فارسی شده به 
config -> app.php

می رویم و 

'locale' => 'en',       en   ----> fa    // اسم پوشه 


####

در ضمن در فایل 
validate.php
که پوشه 
fa
قرار دارد در بخش 
attributes

می توانیم تعریف کنیم که ارور های چگونه باشد و اتریبوت هم فارسی کنیم
مثالا

حالت عادی 
فیلد email الزلمی است

اما با این روش 

"email" => "پست الکترونیکی",

ارور می شود              ====> فیلد پست الکترونیکی الزامی است 


---------------------------------------------------session 29  (43)


ساخت یک 
validation
سفارشی که در لیست 
validation
های لاراول نیست




public function rules()
    {
        return [
            "email" => "required|email",
			//"password" => "required|max:5",
			"id" => "array",
			"id.*" => "string",
			
			// custom
			"password" => ["required", function($attr, $value , $faill){
				//dd(func_get_args());        ///  آرگومان های ورودی تابع را به ما می گوید
				if($value< 8){
					$faill($attr . " is not valid");
				}
			}],
        ];
    }

dd(func_get_args());        ///  آرگومان های ورودی تابع را به ما می گوید

در 
dd
مشخص شد که تابع سه پارارمتر می گیرد

$attr   ===>   نام اتریبیوت که ولیدت  دارد برای آن انجام می شود     ===> e.g.   password
$value  ===>   مقدار ارسال شده
$faill  ===>   یک تابع است که با اجرا شدن آن ارور ایجاد می شود و ما می توانیم با دادن ورودی به آن 

پیام خطا را مشخص کنیم






حالا می توانیم این 
validation
سفارشی را در 
serviceProvider
هم پیاده سازی کنیم


در پرووایدرها
می توانیم یک پرووایدر  جدید برای  
validation
ها ایجاد کنیم یا در همان 
appServiceProvider
بنویسم


ابتدا 
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Validator as BaseValidator;

چون 
Validator
داریم باید یک نام مستعار برای دومی قرار دهیم که به شکل 
as BaseValidator
انجام می شود


سپس    ===>  in boot


Validator::extend('my_validation' , function($attr, $value , $params=[], BaseValidator $validator){
	//dd(func_get_args()); 
	if($value < 10){
		return false;
	}else{
		return true;
	}
} , ":attribute is not valid from service provider");

Validator ==>Fecads

::extend   ===> یعنی می خواهم گسترشت بدهم


1. ----- >  'my_validation'   ===> name  validator  

2.  ---->   function(
	$attr  ===>    نام اتریبیوت که ولیدت  دارد برای آن انجام می شود     ===> e.g.   password
	, $value   ===>  مقدار ارسال شده
	, $params=[]   ==== >  پارامتر های ارسالی به همراه   اسم  ولیدتور  ==> e,g,  p1 , p2
	, BaseValidator $validator   ===>  کلاس اصلی  ولیدتور که باید فراخوانی شود
	)
 
 
3.  --->	":attribute is not valid from service provider"  ===> پیام برای نمایش به کاربر 



in use it  in rules() request

"password" => ["required","my_validation:p1,p2"], // with service provider

// :p1,p2  ===> پارامترهایی که می توانیم ارسال کنیم  






---------------------------------------------------session 30  (44)

اطلاعات کامل درمورد
.env

env  ===> enviroment

شامل متغییر های محیطی است

اسم های داخل این پوشه باید با حروف بزرگ باشند و مقدار به هیچ وجخ داخل 
''   OR  ""
قرار نمی گیرند

APP_NAME=Laravel

در کل پروژه لارواولی به این این متغییرها دسترسی داریم

APP_NAME=Laravel         ===> project name

APP_ENV=local

APP_KEY=base64:F17vaPzKRcZwaBWP5miJq3EpSXbbTQ2Mtvs53774QjY=    
لاراول از این مورد برای مرز گذاری یا 
encrypt
کردن دیتاها استفاده می کند

           
APP_DEBUG=true           ====> زمانی که   ترو    است امکان  دیباگ کردن فراهم است



با توجه به این که ممکن است با  اپلود کردن یا تغییر پروژه  اطلاعات مثلا مربوط به دیتابیس تغییر کنند ما این اطلاعات
را داخل این فایل قرار می دهیم تا دیگر مجبور نباشیم یک تغییر را در چندین فایل لحاظ کنیم

زمانی که پروژه را در گیت هاب یا گیت لب قرار  می دهیم 
.env
قرار نمی گیرد چون در 

.gitignore

اسمش وجود دارد و نادیده گرفته می شود



.env.example

همان فایل 
.env
هست و زمانی که کامپوزر اجرا می شود  بررسی می کند که اگر 
.env
نبود  از روی این مورد یک کپی جدید ایجاد می کند در قالب 
.env


in composer.json   ===>  

post-root-package-install": [
    "@php -r \"file_exists('.env') || copy('.env.example', '.env');\""
],



APP_KEY=
در 
.env.example
خالی است زیرا هربار که  دستور 
composer install
را می زنیم یک  
APP_KEY
جدید ساخته می شود تا بدن شکل  شیوه کد گذاری دیتا ها  مشخص  نباشد در هر پروزه و امنیت هر پروزه چندین برابر شود 



هر  دستور یا متغییری که به 
.env
اضافه می کنید باید حتما به 

.env.example
تا اطلاعات از طریق 
git
هم قابل دسترسی باشد 


اما توجه داشته باشید که برای خود لاراول تنها و تنها   
.env
با اهمیت است و آن یکی را نمی شناسد


---  نحوه دسترسی به این متغییر های محیطی 

به کمک 
helper function   ==>   env('APP_NAME',"default");

env('APP_NAME',"ali");


برای کامنت کردن در 
.env 
از #
استفاده کنید

#APP_NAME=Laravel

dd(env('APP_NAME',"ali"));




---------------------------------------------------session 31  (45)

تنظیمات  دیتابیس در 
.env

با توجه به این که لاراول از 
PDO
استفاده  می کند میتواند به چندین مدل دیتابیس به جز
mysql
متصل شود  



DB_CONNECTION=mysql   ==>  database kind (sqlite,mysql,pgsql,sqlsrv)

DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=laravel_8_first
DB_USERNAME=root
DB_PASSWORD=



از این اطلاعات  در فایل 
config / database.php

استفاده کرده است


'default' => env('DB_CONNECTION', 'mysql'),

و بقیه موارد که خودتان یم تووانید ببینید 

'mysql' => [
	'driver' => 'mysql',
	'url' => env('DATABASE_URL'),
	'host' => env('DB_HOST', '127.0.0.1'),
	'port' => env('DB_PORT', '3306'),
	'database' => env('DB_DATABASE', 'forge'),
	'username' => env('DB_USERNAME', 'forge'),
	'password' => env('DB_PASSWORD', ''),
	'unix_socket' => env('DB_SOCKET', ''),
	'charset' => 'utf8mb4',
	'collation' => 'utf8mb4_unicode_ci',
	'prefix' => '',
	'prefix_indexes' => true,
	'strict' => true,
	'engine' => null,
	'options' => extension_loaded('pdo_mysql') ? array_filter([
		PDO::MYSQL_ATTR_SSL_CA => env('MYSQL_ATTR_SSL_CA'),
	]) : [],
],




در حالا در 
phpmyadmin
با اسمی که در قابل 
.env
قرار دادید یک دیتابیس بیازید  


---------------------------------------------------session 32  (46)

اتصال و کوئری به دیتابیس 

در لاراول این کار به دوشکل انجام می شود

1.   DB   class
2.   Eloquent ORM

هر دو به از   
query bilder
استفاده می  کنند 

Eloquent ORM  is best



in contoller

use Illuminate\Support\Facades\DB;

DB::connection("mysql");  // تعریف نوع دیتابیس و اتصال 
با توجه به این که در 
.env
تعریف کرده ایم  نیازی به آن نیست 


$res = DB::connection("mysql")->table("articles")->get();

or 

$res = DB::table("articles")->get();

dd($res);




$res = DB::table("articles")->toSql();

این دستور  کوئری  اتصال را به ما نشان می دهد 

e.g.   =>   "select * from `articles`"


برای ارتباط با دیتابیس   ومپ باید  ران   باشد


public function connect(){
		 
	$res = DB::connection("mysql")->table("articles")->get();
	
	$res = DB::table("articles")->toSql();
	
	$articles = DB::table("articles")->where('id',3)->get();
	
	$articles = DB::table("articles")->where('id',"<",3)->get();
	
	$articles = DB::table("articles")->find(3);  // get  id
	
	$articles = DB::table("articles")->count();  // row count
	
	$articles = DB::table("articles")->get();
	
	//dd($articles);
	
	
	
	//   *****               send to view
	
	//return view("dbclassconnect" , ["articles" => $articles]);
	return view("dbclassconnect" , compact("articles"));
}



-----in view 



@foreach($articles as $article)

<li> {{ $article->title }}   {{ $article->id }}</li>

@endforeach



---------------------------------------------------session 33  (47)

CRUD    ===>  Create      Read    Update    Delete

چهار  عمل اصلی  


 ===== READ
 
 $articles = DB::table("articles")->get();
	
 dd($articles);


 ===== INSERT
 
 $result = DB::table("articles")->insert([
			
	['title'=> 'Articles 4 insert', "body" =>"lorem ipsum ;)"],
	['title'=> 'Articles 5 insert', "body" =>"lorem ipsum ;)"],

]);

dd($result);    // if added  correcly ==> return true  




===== UPDATE


$result = DB::table("articles")->where("id",1)->update([
	"title" =>"UPDATED THIS FIELD ;)"
]);


dd($result);  // if Updated  is correcly  return  1    else return 0



===== Delete

$result = DB::table("articles")->where("id",5)->delete();
		
		
dd($result);  // if Updated  is correcly  return  1    else return 0



$result = DB::table("articles")->delete();

این دستور کل اطلاعات جدول را پاک می کند 

بعد از این دستور  زمانی که دیتا بعدی وارد می شود    ایدی  آن   یکی  بعد از  ایدی  اخرین اطلاعات پاک شده است 
اما گاهی می خواهیم کاری کنیم که کلا   جدول 
empty
شود و حافظه آن از بین برود   و با وارد کردن اطلاعات جدید  دوباره  ایدی از 
1 
شروع شود که در این صورت به شکل زیر عمل میکنیم


$result = DB::table("articles")->truncate();




---------------------------------------------------session 34  (48)

Eloquent ORM 

ORM  ==> Object Relational  Mapping

یک ابزار است که به ما می گوید نیاز به نوشتن کوئری های دیتابیس نیست و من به عنوان حد واسط بین  دستورات خودم و دستابیس قرار می گیرم
و کوئری های را تولید می کنم

داده های پایگاه داده را به  ابجکت ها  و  کلاس های شی گرایی تبدیل  می کند که کار را خیلی  آسان تر می کند  


ما برای هر زبان برنامه نویسی   
ORM
های مختلفی داریم که کاربردشان متفاوت است 

لاراول یک 
ORM
اختصاصی به اسم  
Eloquent
دارد

قابیلت های   
ORM

1.   امنیت به شدت بالا
2.    آسان تر کردن  کد نویسی 
3.    ارتباط راخت تر بین  دیتابیس ها 
4.     قابلیت های مهاجرت به پایگاه داده های دیگر را بسیار آسان کرده است    e.g.  mysql  ==> pgsql

کلاس ها در 
ORM
همان مدل ها هستند و 
Eloquent
حول محور  مدل ها می چرخد  



---------------------------------------------------session 35  (49,50)

ایجاد مدل های 

models    ===> app  / Models   {in laravel 8    in other  app }


برای ایجاد مدل ها 

in cmd  ==>  php artisan  make:model  --help

php artisan  make:model  name


قواعد نامگذاری  مدل ها 

اسم مدل باید  مفرد باشد و اسم  جدولی که می خواهیم با آن در ارتباط  باشیم باید  جمع باشد 

model  name   ==>  Article
table name   ===>  articles

توجه این قاعده الزامی است  چون لاراول اسم  مدل را می گیرد  و آن را  تبدیل می کند به    جمع   و در دیتابیس   دنبالش می گردد 

نکته  دوم  برای  جمع قرار دادن نمی توانید به همه  اسم ها  
s
اضافه کنید و باید طبق قواعد گرامری  انگلیسی  عمل کنید 

model  ==> Category
table ===>   categories

با رعایت  این قانون دیگر نیازی در بخش مدل چیزی  برای  مشخص کردن  اسم   دیتابیس بنوسیم




البته  می توانیم  اسم  مدل و  جدول را هم  متفاوت از هم  بنویسید  



php artisan  make:model  Article


بعد از این دسنور    مدل ساخته می شود  
برای فراخوانی آن از کمترل هم کافی است  ابتدا 

in controller

use App\Models\Article;

public function index(){
		
	
	
	$articles = Article::all();
	
	//dd($articles);
	
	
	// send  to view
		
	return view("orm",compact('articles'));
	
}



اما برای انیکه  با اسم مدل مختلف به دیتابیس  متفاوت از اسمش متصل شویم در مدل   می نویسیم 

protected $table = "article_webprog_ali"; 
// for connect to defrent name table and model


کلا به این روش که مدل با یک سطر از جدول دیتابیس  ارتباط برقرار می کند و می آید روی جدول دیتابیس ما سوار می شود  
ORM
گفته می شود



Article::all();     همه را برمی گرداند از دیتابیس

Article::find(1);   فقط  ایدی  1   را  برمی گرداند 

Article::find([1,3])


اگر   
dd
کردین و در متن های برگشت داده شده 
query bilder
بود برای دستیابی به مقادیر باید از متود 
get
استفاده کنید

Article::where("id",3)->get();           شرط گذاری
Article::where("id","<",3)->get();



Article::first();         اولین خانه دسیتاییس را بریمی گرداند 

Article::findOrFail(12);  اگر پیدا کرد ایدی که بهش دادیم را  برمی گرداند  اما اگر پیدا نکرد
						  fail   می کند  و  شما را به صفخه    
						  404
						  منتقل می کند 
						  
						  
Article::orderBy("id","DESC")->get();  //orderBy

Article::take(3)->get();  // limit 3
Article::limit(3)->get(); // limit 3

Article::orderBy("id","DESC")->limit(3)->get();




---------------------------------------------------session 36  (51,52)

CRUD in Eloquent

Read   ===>  درس های  جلسه قبل


---- insert

// روش اول برای  اینزرت

		$article = new Article();
		
		$article->title= "art 7 Elequent";
		
		$article->body= "bode lorem 200	 7 Elequent";
		
		
		$article->save();
		
		dd($article);


ممکن است  ارور بدهد و بگوید که دوتا فیلد  
created_at
updated_at

می خواهد که می توانید آن را به جدول اصافه کنید یا کلا  

صرف نظر کنید که برای این کار  در فایل 
model 


class Article extends Model
{
    use HasFactory;
		
	public $timestamps = false;
}


البته بهتر است همیشه این دو را داشته باشید و از آن ها ضرف نظر نکنید



// روش  دوم   insert

به اضافه کردن یکباره  اطلاعات  توی  دیتابیس  

mass assignments

می گویند


//Insert  2
		
$article = new Article([
	'title' => "art 8 Elequent",
	'body' => "bode lorem 200  7 Elequent  insert 2"
	
]);

$article->save();




برای این حالت باید  کمی تغییر در بخش  
model
ایجاد کنید 

این موضوع به این دلیل وجود دارد که ما  یک مدیدیرت روی  فیلدها داشته باشیم و تعیین کنیم که کدام   فیلدهای دیتابیس
fillable
هستند یا قابلیت پر شدن دارند 

in model 

protected $fillable = ['filed name','filed name'];

protected $fillable = ['title','body'];


اگر در مدل این  کد را قرار ندهید  و از  
mass assignments
استفاده کنید به ارور می خورید

همچنین یک قابلیت دیگر را هم می توان در     مدل   قرار داد که تعیین می کند  که کدام  فیلدها  نمی تواننند  ونباید   پر شوند وابسته
و در نتیجه  در برابر آن ها    گارد   گرفته   میشود

protected $guarded = ['title','body'];
این دستور  اجازه  پر کردن فیلد های    بادی   و    تایتل   را نمی دهد 



class Article extends Model
{
    use HasFactory;
	
	protected $fillable = ['title','body'];
	
	//protected $guarded = ['title','body']; ===> Comment
}

 ======  نکته 

زمانی که  ومپ  ران نیست و دستور مرتب با دستابیس را  فراخوانی می کنیم  به ما ارورو

SQLSTATE[HY000] [2002] 
No connection could be made because the 
target ======  machine actively refused it ========== 

می دهد 



//Insert  3

این روش هم چون دیتا را  داریم   یکباره  وارد می کنیم   
mass assignments
هست

$article = Article::create([
	'title' => "art 9 Elequent",
	'body' => "bode lorem 200  9 Elequent  insert 3"		
]);



//Insert  4

این روش  یک   شرط از ما می گیرد و بررسی می کند که اگر اون فیلد بود 
کاری انجام نمی دهد اما  اگر فیلد وجود نداشت  فیلد با اطلاعاتی که بهش دادیم را  
insert
می کند


$id=10;
$article = Article::firstOrCreate(['id'=>$id],[
	'title' => "art 10 Elequent",
	'body' => "bode lorem 200  10 Elequent  insert 3"		
]);


چندتا شرط هم می توانیم قرار دهیم 


$id=10;
$article = Article::firstOrCreate(
[
	'id'=>$id,
	"title"=>'art 9 Elequent'
],
[
	'title' => "art 10 Elequent",
	'body' => "bode lorem 200  10 Elequent  insert 3"		
]);






---- update

روش اول

$article = Article::find(2)->update([
	'title' => "this title  UPDATED"
]);


dd($article);  // if updated  ==>return true



روش دوم 


$article = Article::find(2);
$article->update([
	'title' => "this title  UPDATED !!",
	'body' => "this body  UPDATED",
]);



//update 3

$id=12;
$article = Article::updateOrCreate(['id'=>$id],[
	'title' => "this title  UPDATED )) ",
	'body' => "this body  UPDATED",
]);

این دستور  شرط را بررسی می کند  اگر  مثلا 
ایدی در دیتابیس  وجود داشت      آن  را   اپدیت می کند  

اما  اما   اگر  وجود نداشت  آن را  
create
می کند یا به عبارتی اطلاعات را  در یک فیلد جدید 
insert 
می کند 


---------------------------------------------------session 37  (53)

DELETE


//delete 1
		
$article = Article::find(12)->delete();

//delete 2
		
$article = Article::where('id',12)->delete();

dd($article);  // if delete  == return 1    else  return 0


$article = Article::where('id',">",12)->delete();

dd($article);
در این حالت  تعداد مواردی که  پاک کرده است را برمی گرداند 


//delete 3
			
$article = Article::find(2);
$article->delete();


//delete 4 

$article = Article::destroy(2);

$article = Article::destroy([7,8]);


تمام این روش ها 
physical delete
بودن و عملا با اجرای دستور   چیزی که در دیتابیس است  حذف می شود اما 
soft delete
به این صورت است که ما نمی آییم  فیلد را بهطور کامل از دیتابیس  حذف کنیم اما کاری می کنیم که رفتار یک 
فیلد پاک شده را داشته باشد     یعنی  وقتی 
آن را 
find 
می کنیم   سیستم  بگه  این مورد وجود ندارد  اما  در دیتابیس باشد 


برای اجرای این کار باید  به روش زیر عمل کنیم  

in model

use Illuminate\Database\Eloquent\SoftDeletes;

class Article extends Model
{
    use HasFactory;
	
	
	use SoftDeletes;
	

	protected $fillable = ['title','body'];
	
}

in mysql   --> create  deleted_at  column


in controller

// soft delete
			
$article = Article::where('id',9)->delete();

dd($article);

بعد از اجرای این دستور  فیلد 
deleted_at
پر می شود و ما دیگر نمی توانید این سطر را دیگرر

Read
کنیم 

find   &  where  

دیگر کارایی ندارند  و زمانی که می گوییم  ایدی  
مثلا 9 را
بیاور
null
می دهند اما کاهی نیاز است که انی موارد را هم فراخوانی کنیم  مثلا در بخش مدیریت برای مدیر که در این صورت برای 
برگرداندن آن ها به روش زیر عمل می کنیم 

$article = Article::find(9);  //return  null
$article = Article::where('id',9)->get(); //return  empty array


با این دستور  مواردی که 
soft  delete 
شده اند هم برمی گردند 

$article = Article::withTrashed()->find(9);
$article = Article::withTrashed()->where("id",9)->get();


برای بررسی این که از نوع 
soft delete
هست یا نه هم می توانیم از دستور زیر استفاده کنمی 

$article = Article::withTrashed()->find(9);
dd($article->trashed());



دستور زیر هم  تنها  مواردی که  
soft delete
هستند را  برمی گرداند 

$article = Article::onlyTrashed()->get();
			
dd($article);



خارج کردن   کردن   یک سطر از  حالت 
soft delete
و در دسترس کردن آن 


$article = Article::onlyTrashed()->find(9);
$article->restore();

dd($article);

بعد از اجرای این دستور  فیلد 
deleted_at
خالی می شود 




حذف کامل موردی که  
soft delete
َده از دیتابیس  یا به عبارت دیگر  
physical delete

مورد سافت دیلیت شده 

$article = Article::where("id",9)->forceDelete();

dd($article);




---------------------------------------------------session 38  (54)

scope in model 

به متودهایی که مربوط به مدل است    ما متود هایی را اضافه می کنیم تا کار مورد نظر مارا انجام دهند
به این متودها اسکوپ  گفته می شود

scope 
	1.local
	2.global   ==>  تاثیر روی همه کوئری ها 


in model

class Article extends Model
{
    use HasFactory;
	
	//global  scope

	protected static function boot(){
		
		parent::boot();
		
		static::addGlobalScope("status", function($query){
			$query->where("status",1);
		});
		
	}
}

این دستور به این شکل است که زمانی که ما در کنترلر  موارد را فراخوانی می کنیم 
این دستور که گفتیم  فقط  روی 
status 1

ها کوئری های  اجرا شوند  می آید  تنها  کوئری ها را روی  این موارد اجرا می کند 

//scope
			
$article = Article::all();

dd($article);

با متود 
toSql
هم می توانیم کوئری را ببینیم که به شکل زیر شده است 

"select * from `articles` where `id` > ?  and `status` = ?"


and `status` = ?     را به آخرش  اضافه کرده است 


گاهی هم نیاز است که  کاری کنیم که  
global scope
روی کوئری خاصی اجرا نشو د که در این صورت به شکل زیر عمل می کنیم 

$article = Article::withoutGlobalScope('status')->where("id",">",9)->toSql();
			
dd($article);



"select * from `articles` where `id` > ?"

در این کوئری ما دیگر  

and `status` = ? 

را نداریم 



// local  scope

in model 


// local scope
public function scopeStatus($query){
	$query->where("status",1);
}

نامگذاری مهم است  باید ابتدا 
scope
قرار دهید  وبعد  اسم  مورد نظر را به صورت 
پاسکال بنویسید 
این خیلی مهم است 

in controller

//local
$article = Article::status()->get();


dd($article);

اسم باید  کوچک باید 

این را می توانید با ارسال پارامتر  داینامیک  کنیم 






// local scope
public function scopeStatus($query,$statusParam){
	$query->where("status",$statusParam);
}



//contoller


//local
$article = Article::status(0)->get();


dd($article);


تعداد پارامترهای ارسالی  محدودیت ندارد 





---------------------------------------------------session 39  (55)

Accessors  and   Mutators

زمانی که می خواهیم اطلاعات را از دیتابیس بخوانیم و اطلاعات را به دستابیس وارد کنیم  با این  ویژگی  
Elequent
می توانیم اطلاعات را به صورت دلخواه تنظیم و فرمت دهی کنیم 


زمانی که داریم  اطلاعت را  را دریافت یا بازیابی می کنیم از 
Accessors
استفاده می کنیم 


اما 
Mutators
برای ذخیره اطلاعات در دیتابیس است 


in model

//Accessors

name --> important

name ===>  get + Field database name +  Attribute   // pascal case
	
برای اسم های چند قسمتی 

in database ==> first_name    ===> getFirstNameAttribute	
	
public function getTitleAttribute($value){
	
	// $this->title;  ===> دسترسی به مقادیر داریم 
	// $this->body;
	
	return strtolower($value);
}

این اکسسور  فیلدهای تایتل را که از دیتابیس می کیریم به صورت 
small
در می آورد 


// 



//mutators
name ===>  set + Field database name +  Attribute   // pascal case

public function setTitleAttribute($value){
	$this->attributes['title'] = strtoupper($value);
}

برای زمانی است که می خواهمی اطلاعات را ثبت کنیم 
با این کار می توانیم هر تغییری می خواهیم  ایجاد کنیم و بعد اطلاعات را ذخیره کنیم 









---------------------------------------------------session 40  (56,57)
migration

یک ابزار است که به راحتی  جدول های دیتابیس را ایجاد  و مدیریت کنیم 

همچنین با توجه به تاریخ ایجاد شدن می توانیم بعدا اگر نیاز بود  دیتابیس را به زمان خاصی برگردانیم و اطلاعات آن زمان را داشته باشیم 


migrations  in  database floder/migrations

اسم مایگریت ها اطلاعانی به ما می دهد 

2014_10_12     _000000      _create_users_table        .php

تاریخ         .   زمان      .          دستور          

دلیل این شکل نامگذاری این است که  اولا  فایل ها هم نام نشود 

دوما   لاراول زمان اجرا این دستورات  و فایل ها را از بالا به پایین اجرا و فراخونی می کند  پس  ترتیب  بسیار  مهم است
زیرا نمی توانیم مثلا جدولی که به اطلاعات جدول دیگر وابسته است را قبل از   ایجاد   حاوی اطلاعات مورد نیاز ایجاد کنیم 


create magiration

in cmd   ==>  php artisan make:migration --help

php artisan make:migration name    --kind

name   ==> create_table name _table 


php artisan make:migration  create_articles_table --create=articles


حالا باید در پوشه مایگریشن ها   فایل ایجاد شده باشد 

فایل ایجاد شده شامل دو قسمت است 
up   and  down

up()  ==>  این متود برای زمانی است که می خواهیم یک جدول ایجاد کنیم 
down()   ===>   برای زمانی است که می خواهیم یک جدول را پاک کنیم 


همچنین می توانیم با دستور   ایجاد  مدل       هم  مدل ایجاد کنیم و هم   مایگریشن 


php artisan make:model NameModel -m

خودش همه کارهای مریوط به ایجاد   مدل و مایگریشن را انجام می دهد 



############################

ساخت جدول با مایگریشن


public function up()
    {
        Schema::create('articlesM', function (Blueprint $table) {
            $table->id();
            $table->string("title",100)->comment("my comment");
            $table->text("body");
            $table->boolean("status")->default(0);
            $table->timestamps();
        });
    }


بعد از  تعیین این موارد  

in cmd    php artisan migrate:status

این دستور وضعیت را به ما می گوید  مثال  می گوید که هنوز   جدولی  نساختید 


php artisan migrate   =>  ایجاد جدول 

ممکن ایت ارور بدهد  


terminal --> php artisan migrate ---> تمام توابع موجود در فایل های پوشه مایگریت را ران می کند
---> دو ارور هم ایجاد می شود که برای جلوگیری از آنها (max key length is 1000 bytes)
--> go to  App folder ---> providers  ---> appServiceProviders.php
--> in public function boot() ---> 
public function boot(){
	Schema::defaultStringLength('191');
}


حالا  
php artisan migrate:status
بزنید تا وضعیت را ببیندی 




---------------------------------------------------session 41  (58,59)

وقتی دستور  مایگریت را اجرا می کنیم در کنار جداول  یک جدول با نام 
migrations
هم وجود دارد که در ان دو فیلد وجود دارد 
1. migration name
2.  batch            ==>  دسته اش چی هست 

مثلا زمانی که  چندتا   سطر 
batch
مساوی دارند  یعنی این که در یک رمان  مایگریت شده اند 

مثلا اگر الان یک مدل و مایگرینشن جدید به اسم 
Post 
بسازیم و دستور میگریت را اجرا کنیم در جدول 
batch
آن را 
2
قرار می دهد 

دلیل استفاده از این 
batch 
برای این است که بتوانیم از 
rollback 
استفاده کنیم 
این دستور یکی به عقب برمی گردد و و آخرین  مایگریتی که در دیتابیس ایجاد کرده اینم   که در اینجا
batch 2
است را حذف می کند  و  ما می توانیم تغییراتی که می خواهیم را در فایل مایگریت ایجاد و دوباره دستور 
مایگریت را بزنیم تا جدول با اصلاحات جدید برای ما ساخته شود 


###

ابتدا یک مدل جدید می سازیم  برای تست 
php artisan make:model Post -m

بعد به دیتابیس که نگاه کنیم  batch
مربوط به این مورد با قبلی ها فرق دارد و یکی به آن اضافه شده است

php artisan migrate:rollback

این دستور  آخرین مایگریت که در ایمجا 
Post 
است را پاک می کند 

حالا اجرای تغییرات در فایل مایگریت 

ابتدا 
status
می گیریم و می بینیم که وضعیت مایگریت 
post
 را 
 no
گذاشته است یعنی هنور این مایگریت ساحته نشده است 

حالا دستور مایگریت را دوباره اجرا می کنیم 

php artisan migrate



----------------
دستورات دیگر در کنار 
rollback

---- fresh         ==>  تمام مایگریشن ها را حذف و جدول را خالی و دوباره همه مایگریشن ها را اجرا می کند 

----- install       ===>   برای ساخت جدول    migrations  
							در دیتابیسس هست که ما وقتی دستور مایگیرت را زدیم خودش این را اجرا می کند 
					 		
--------refresh    ====>  تمام جدول ها را    ریست  می کند و  بعد دوباره  مایگریت را اجرا می کند 

-------reset       ===>   تمام جدول های دستابی را     رول  بک    می کند 
 
 
-------status     ====> همان دستوری است که باهاش کار کردیم 							
-------rollback     ====> گفته شد					


!!!!!!!!!!!!!!!!!!!!!important

reset    /  refresh   /    fresh

این سه دستور به  هیچ وجه در پروزه  نباید  زده شوند   زیرا  تمام دستابیس  را  پاک می کند  و تمام  اطلاعات از بین می رود 
همچنین  
batch
همه را   یک  می کند که این  تربیت را به هم می زند 




!!!!!! important 
هر چند   رول  بک  یکی از روش های ایجاد   ستون جدید به دیتابیس است اما به دلیل  تغییر  
batch
و چیزهای دیگر از آن استفاده نمی کنیم   و برای   اضافه کردن  ستون های جدید  به  یک جدول  مایگریت شده از روش زیر  استفاده می کنیم


in cmd   => php artisan make:migration add_new_to_post_table_ali --table=posts


این دستور  یک فایل جدید برای ما در بخش  مایگریشن ها می سازد که می توانیم  ستون های جدیدی که قرار است   اضافه کنیم را در آن قرار دهیم 

public function up()
{
	Schema::table('posts', function (Blueprint $table) {
		$table->text("body2")->default("lorem");
	});
}








داخل  
down 
هم باید به روش زیر عمل کنیم 

public function down()
{
	Schema::table('posts', function (Blueprint $table) {
	   $table->dropColumn(["body2"]);
	});
}


حالا دستور 
php artisan migrate
را می زنیم تا فیلد جدید اضافه شود  

اگر ارور داد   به فیلد 
->default("lorem ");
اضافه می کنیم 

حالا اگر دستور  رول بک  بزنیم   فقط  اون ستونی که اضافه کردیم را پاک می کند و کاری به سایر اظلاعات دیتابیس ندارد 







php artisan make:migration change_articles_table_ali --table=articles

حالا می خواهیم یکسری تغییرات ایجاد کنیم

public function up()
{
	Schema::table('articles', function (Blueprint $table) {
		$table->string("title",150)->change();
		$table->renameColumn("status","is_status");
	});
}


public function down() //  برای وثتی رول بک  زدیم و می خواهیم تغییرات را به حالت اول برگرداند 
    {
        Schema::table('articles', function (Blueprint $table) {
            $table->string("title",100)->change();
            $table->renameColumn("is_status","status");
        });
    }


حالا
php artisan migrate

یک ارور می دهد و می گوید برای تغییر ستون ها به یک کتاب خانه 
doctrine/dbal
نیاز داریم 


برای نصب 

composer require doctrine/dbal

بعد از نصب 
php artisan migrate

بعد باید تغییرات اعمال شود 
 
 
 حالا اگر  رول بک  بزنیم     چون  در بخش 
 
 down
 گفته ایم  تغییرات  ریست شود  
 دوباره جدول به حالت قبل برمی گردد 
 
 
 
 
این سبک از پیاده سارزی دیتابیس به ما کمک می کند تا هر زمانی که نیاز بود تغییرات دیتابیس را به حالت و زمان مورد نظر برگردانیم 






---------------------------------------------------session 42  (60)
Seeder

اطلاعات فیک برای تست کردن  مایگریشن ها 

in database floder  /  seeders

create seeders

in cmd  ==> php artisan make:seeder  --help

php artisan make:seeder  name

php artisan make:seeder  ArticlesTableSeeder


باید فایل با این نام در پوشه  سیدر ها  ساخته شود 

داخل این فایل یک منود   ران   وجود دارد که کدها را باید داخل آن قرار دهیم 

برای استفاده باید ابتدا    مدل  مورد نظر را  
use
کنیم 

use App\models\Article;

public function run()
    {
        foreach(range(0,10) as $item){
			
			Article::create([
				'title'=>'Fake Seeder',
				'body'=>"fake body seeder"
			]);
		}
    }
	

بعد داخل 
cmd   ==>  php artisan db:seed --help

این دستور می گوید که یک   اپشن دارد و نام  کلاس سیدر را می گیرد  اما اگر آن را قرار ندهیم 
به طور پیشفرض همان فایل اولیه که در پوشه بوده است   یعنی 

DatabaseSeeder.php

را فراخوانی می کند 



خوب ابتدا  با زدن نام اظلاعات را وارد می کنیم و بعد با تغییراتی در فایل 
DatabaseSeeder

php artisan db:seed --class=ArticlesTableSeeder

روش دوم
ما هم داخل این فایل تغییراتی ایجاد میک نیم   تا اطلاعات به دیتابیس اظافه شود 


in DatabaseSeeder

public function run()
    {
        // \App\Models\User::factory(10)->create();
		
		
		$this->call([
			ArticlesTableSeeder::class,
			// 
		]);
   }


php artisan db:seed



برای استفاده از  اطلاعات  فیک واقعی تر می توانید از کتابخانه 
faker

استفاده کنید 

فارسیش را می توانید سرچ کنید  اما  انگلیسی آن به صورت  خودکار روی خود لاراوال وجود دارد و تنها برای استفاده از آن می توانید به روش زیر عمل کنید 

حتما داکیمونت این کتابخانه را در گیت هاب مطالعه کنید 


public function run()
    {
        
		// faker library
		$faker = \Faker\Factory::create();
		
		foreach(range(1,10) as $item){
			
			Article::create([
				'title'=>$faker->text(50),
				'body'=>$faker->paragraph(rand(5,20))
			]);
		}
    }



حالا دیتابیس را کلا پاک می کنید و دوباره اطلاعات جدید به آن وارد می کنید
پاک کردن دستابیس هیچ الزامی ندارد و اینجا  در جهت آموزش است 

fresh and seed together  ==> php artisan migrate:fresh --seed




---------------------------------------------------session 43  (61)

factory

کار کردن با سیدرها را برای ما آسان تر می کند 
کارخانه ای است که برای ما اطلاعات فیک درست می کند 

database/factory


create factory

in cmd  php artisan make:factory  --help

php artisan make:factory  --help name --model=modelName

php artisan make:factory  ArticleFactory --model=Article

اگر این قسمت
--model=Article
را قرار ندهیم در فایل ایجاد شده به جای اسم مدل  کلمه 
model
می نویسد که ما باید خودمان پرش کنید اما بهتر است  از همان اول اسم مدل را قرار دهیم 

public function definition()
{
	return [
	
		'title'=>$this->faker->text(50),
		'body'=>$this->faker->paragraph(rand(5,20))
		
	];
}

مزیت  فکتوری   نسبت  به سیدر این است که سیدر را ختما باید  در کامند  لاین  اجرا کنیم  اما  فکتوری را می توانیم به کمک یک  هلپر فانکشن در هر جایی 
استفاده کنیم

برای مثال در کنترلر 

Article::factory()->count(15)->create();

همچنین می توانیم این   فکتوری را در  سیدر  قرار دهیم 
به جای نوشتن کلی سید   به روش زیر عمل می کنیم 


public function run()
{

	//Factory
	Article::factory()->count(15)->create();
}


و برای اجرا شدن 
in cmd   ===> php artisan db:seed    OR  php artisan db:seed --class=ArticlesTableSeeder









---------------------------------------------------session 44  (62)

++++   Relationship

ارتباط  بین  جداول


One to One

foreign key

همان عامل ارتباط بین دو جدول است   برای مثال  دو جدول   مقالات و ویژگی ها داریم
در جدول ویژگی ها یک فیلد احتضاض می دهیم به 
idArticle
تا به کمک آن بتوانیم تشخیص دهیم که کدام ویژگی مربوط به کدام مقاله است


local_key
همان فیلدی است که ار روی آن ارتباط می گیرم  مثلا   ایدی در جدول  یوزرز




حالا برای مثال ما دو  جدول  
users   
و 
profiles
داریم و می خواهیم بین آن ها ارتباط برقرار کنیم 


php artisan make:migrate Profile -m

in migration

$table->id();
$table->integer("age");
$table->integer("phone");

$table->unsignedBigInteger("user_id");    //  باید با نوع  آن در جدول  یوزر یکی باشد 

$table->foreign("user_id")->references('id')->on('users')->onUpdate('cascade');

کلید   خارجی   که رفرنس  آن ایدی از   حدول یوزرز  است  و  زمانی که  آن   اپدیت شد  این هم  اپددیت شود  به صورت  آبشاری

onDelete
هم داریم که می گوید  اگر  آن حذف شد این هم جذف شود 



$table->timestamps();


php artisan  migrate

in model  User
//relation
	public function profile(){
		return $this->hasOne(Profile::class);
	}
	
	
in controller


use App\models\User;
use App\models\profile;

public function index(){
	
	//dd(profile::class);
		
	$user = User::find(1);
	
	$user->profile;
	
}

الان این متود می رود از جدول  پروفایل  اطلاعات مربوط به  یوزر با  ایدی یک را بر می گرداند 

// ======  Get  profile  from  user

in model   User

//relation
	public function profile(){
		return $this->hasOne(Profile::class);
	}


in controller
public function index(){
		
	
	
	dd(profile::class);
	
	$user = User::find(1);
	
	dd($user->profile());
	
	$user->profile;
	
	dd($user->profile->age);
	
}



// ======  Get user from   profile

in model  Profile


//relation
public function User(){
	return $this->belongsTo(User::class);
}

  
in controller

public function index(){
	
	// ======  Get user from   profile  
	
	$profile=Profile::find(1);
	
	dd($profile->User);
	
	
	}

حالا  لاراول از کجا می فهمد که   
foreign key
ما کدام است 

در حالت اول می گوید که  تو جدول  یوزر داری پس می آید داخل جدوول  پروفایل دنبال 
user_id
می گردد 

اما ممکن است اسمی که ما برای ستون انتخاب کردیم متفاوت باشد که دراین صورت به باید به عنوان پارامت دوم آن را معرفی کنیم 

public function profile(){
		//return $this->hasOne(Profile::class);
		//return $this->hasOne(Profile::class , 'foreign_key', 'local_key');
		
		
		return $this->hasOne(Profile::class , "user_id","id");
}


public function User(){
		//return $this->belongsTo(User::class);
		//return $this->belongsTo(User::class,'foreign_key', 'other_key');
		
		return $this->belongsTo(User::class , "user_id","id");
}


---------------------------------------------------session 45  (63)

++++   Relationship  one  to many

برای زمانی است که یک مدل واحد با چند  مدل دیگر در ارتباط است 

برای مثال  یک  پست می تواند  چند کامنت  داشته باشد 


برای این که  کامنت های مربوط به یک پست را برگردانیم 


migrate post 

		Schema::create('posts', function (Blueprint $table) {
            $table->bigIncrements('id');
			$table->string("title");
            $table->timestamps();
        });




migrate comment  


		Schema::create('comments', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->text('body');
            $table->boolean("is_status");
            $table->unsignedBigInteger("post_id");
            $table->foreign("post_id")->references('id')->on('posts')->onDelete('cascade');
            $table->timestamps();
        });





in model post
public function comments(){
	return $this->hasMany(Comment::class);
}

in controller

$post=Post::find(1);
		
$comments = $post->comments->where('is_status',1);

dd($comments);


---------------------------------
اما گاهی یک کامنت را داریم و می خواهمی به پست مربوط به آن دسترسی پیدا کنیم که در این صورت از رابطه معکوس استفاده می کنیم

in model comment

	public function post(){
		return $this->belongsTo(Post::class);
	}

//  belongsTo  ==> متعلق است به 

in controller

	//(one to many)  //  معکوس
	
	$post=Comment::find(4)->post;


	dd($post);
	
	اگر به این شکل بنویسیسم خود متود  رول را برمی گرداند 
	// $post=Comment::find(4)->post();  ==>  مهم


ممکن است برای  فارن کی    ما از 
post_id
استفاده نکرده باشسم که در این صوورت باید به عنوان پارامتر دوم آن را پاس بدهیم 

in model post

return $this->hasMany(Comment::class,"foreing_key","local_key");
return $this->hasMany(Comment::class,"post_id","id");


in model comment 

return $this->belongsTo(Post::class,"foreing_key","other_key");
return $this->belongsTo(Post::class,"post_id","id");



---------------------------------------------------session 46  (64)

++++   Relationship  many  to many

برای مثال ما در دیتابیس یک جدول برای   کاربران داریم  و  یک جدول برای نقش های آن ها 
یک کاربر می تواند چند نقش داشته باشد و   یک  نقش هم می تواند  متعلق به چندین کاریر باشد 

1    ===> many
many <=== 1


در این جا ما نمی توانیم از   
foreign_key
استفاده کنیم   چون  در این صورت می گوییم که  هر نقش  تنها  متعلق به یک کاربر است 
برای این کار از یک جدول رابط یا 

Pivot Table

استفاده می کنیم

اسم گذاری این جدول هم باید  اصولی و طبق ترتیب جروف الفبا باشد 
roles
users

==>role_user

هر دو باید مفرد باشد در نام 


اول رول   و بعد یوزر که  ترتیب الفبایی رعایت شود 

داخل این جدول   دو مورد زیر را داریم 

role_id
user_id



role_user  migrate

	Schema::create('role_user', function (Blueprint $table) {
		//$table->id();
		
		$table->unsignedBigInteger("role_id");
		$table->foreign("role_id")->references('id')->on("roles")->onDelete('cascade');
		
		$table->unsignedBigInteger("user_id");
		$table->foreign("user_id")->references('id')->on("users")->onDelete('cascade');
		
		$table->primary(["role_id","user_id"]);
		
		$table->timestamps();
	});
	
	

user migrate  


	Schema::create('users', function (Blueprint $table) {
		$table->id();
		$table->string('name');
		$table->string('email')->unique();
		$table->timestamp('email_verified_at')->nullable();
		$table->string('password');
		$table->rememberToken();
		$table->timestamps();
	});


role migrate 


		Schema::create('roles', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string("name");
            $table->timestamps();
        });
		

در جدول رول  یوزر  باید  ایدی ها را به هم نسبت دهیم  مثلا 
user_id  1   role_id 1
user_id  1   role_id 2


in user model 

	//many to many
	public function roles(){
		return $this->belongsToMany(Role::class);
	}
	

in controller 


	$roles = User::find(1)->roles;
		
	d($roles);
	
	
	حالا می توانیم به خود جدول 
	pivot
	هم دسترسی داشته باشیم به شکل زیر 
	
	
	$roles = User::find(1)->roles->first();
		
	dd($roles->pivot);

	در این حالت فقط 
		user_id  , user_id
		را می آورید و  اگر خواستیم  مثلا   تایم  استمپ جدول را هم بیاورد به شکل زیر عمل می کنیم در مدل


	return $this->belongsToMany(Role::class)->withTimeStamps();  ==>  برای گرفتن 
	
																created_at   and  updated_at
	
	return $this->belongsToMany(Role::class)->withPivot("column name","sdsd");
	
	==>  برای برگرداندن  ستون های مورد نظر  مثلا  وضعیت یا  نام یا ...
	
	return $this->belongsToMany(Role::class)->wherePivot("is_status",1);
	
	==>  ایجاد شرط
	


many to  many     معکوش 

in  role model 

//many to many
	public function users(){
		return $this->belongsToMany(User::class);
		//return $this->belongsToMany(User::class)->withTimeStamps();
		//return $this->belongsToMany(User::class)->withPivot("column name","sdsd");
		//return $this->belongsToMany(User::class)->wherePivot("is_status",1);
	}
	
	

in controller

		$users = Role::find(2)->users;
		
		dd($users);
		

گاهی ما نمی خواهیم اسم ستون های ارتباطی را 

role_id   and  user_id
قرار دهیم و  می خواهیم هر اسمی دوست داشتیم بگذرایم که دراین صورت به روش زیر همل می کنیم 


public function roles(){
		return $this->belongsToMany(Role::class);
		
		
	
		return $this->belongsToMany(Role::class,"pivot_table name","local_foreign_key(this model table foreign kek)" ,"other_foreign_key","local_id","other_id");
		return $this->belongsToMany(Role::class,"role_user","user_id" ,"role_id","id","id");
		
	}



// معکوش

public function users(){
	return $this->belongsToMany(User::class);
	

	return $this->belongsToMany(User::class,"pivot_table name","local_foreign_key(this model table foreign kek)" ,"other_foreign_key","local_id","other_id");
	return $this->belongsToMany(User::class,"role_user","role_id" ,"user_id","id","id");
	
}


ترتیب ایجاد  جداول  بسیار مهم است و شما نمی توانید  جدول
pivot
را قبل  جدول های اصلی ایجاد کنید  چون این جدول به اطلاعات آن ها نیاز دارد 



اضافه کردن اطلاعات به جدول  
pivot


روش لاول 

// save


$role = Role::find(1);
$user = User::find(2);

$result = $user->roles()->save($role);

dd($result);

نمی توانیم در جدول یک رابطه را دوبار تکرار کنیم  زیرا  
primary key
هستند و یونیک 



روش دوم 

// attach

$role = Role::find(1);
$user = User::find(2);

$result = $user->roles()->attach($role);

dd($result);



می توانیم حتما یک رابطه را در جدول 
pivot
حذف هم بکنیم 

// detach

$role = Role::find(1);
$user = User::find(2);

$result = $user->roles()->detach($role);

dd($result);

می توانیم  برای  دیتچ های بیشتر   داخل  
find([1,2])
آرایه بدهیم 







$role = Role::find(1);
$user = User::find(2);

$result = $user->roles()->sync($role);

dd($result);

این مورد می آید  هرچه  ارتباط   برای  یوزر  
2 
است را پاک می کند و این  ارتباط جدید  را وارد می کند 


البته می توانیم کاری کنیم که  این متود    سنیک   موارد قبلی را حذف  نکند که در این صورت به روش زیر عمل می کنیم

$result = $user->roles()->sync($role, false);





---------------------------------------------------session 47  (65)

++++   Relationship  hasOneThrough

یک رابط  یک  به  یک 

برای پیاده سازی این رابطه از یک جدول واسط کمک  می گیریم 

یک جدول برای   کاربران  داریم و یک جدول  برای   ماشین ها  
هر کاربر یک ماشین دارد 

از طرفی هم یک جدول داریم به  اسم 
cars_info
که اطلاعات ماشین ها درون آن قرار دارد و هر ماشینی یک  سطر را  اشغال کرده  
و هر ماشین یک سطر را به خود اختصاص داده  حالا  ما می خواهیم به کمک 
جدول یوزر  اطلاعت  ماشین را به دست آوریم 


ابتدا جدول  یوزر    کار   و   کار اینفو  را همراه  مایگریشن ها ایجاد میک نیم 


in model  user 


/* hasOneThrough */
	
public function carInfo(){
	return $this->hasOneThrough(CarInfo::class, Car::class);
	return $this->hasOneThrough(@1, @2);
}

@1 ===>  اسم جدولی که می خواهیم  اطلاعات را از آن دریافت کنیم
@2 ===>  اسم جدول واسط ما 


in controller 

$user = User::find(1);
		
dd($user->carInfo);





 در صورتی که کلید های خارجی ما دلبخواهی بود  باید آن ها را به روش زیر به لاراول معرفی کنیم 
 
 public function carInfo(){
		/* return $this->hasOneThrough(CarInfo::class, Car::class); */
		
		
		return $this->hasOneThrough(
		CarInfo::class, 
		Car::class,
		"user_id",  ===> کلید خارجی گیرند اطلاعات در جدول واسط
		"car_id",    ===>  کلید خارجی جدول واسط در  جدول اطلاعات 
		"id",		====> کلید اصلی گیرند اطلاعات
		"id"		===>  کلید اصلی در جدول اطلاعات 
		);
		
		
		
	}


---------------------------------------------------session 48  (66)

++++   Relationship  hasManyThrough


یک حدول یورز داریم  و یک جدول   پست  و یک جدول   کشورها

داخل جدول یوزر  ایدی کشور را قرار داده ایم و داخل  پست ها   اید های یوزر 

حالا در این رابطه به دنبال این هستیم که به پست های کاربران یک کشور دسترسی پیدا کنید 

در اینجا جدول   یوزرز    جدول  واسط است 

کاربران یک کشور می توانند چندین پست داشته باشند  
اما هر پست متعلق به کاربر یک کشور است 


ایجاد 

model  and  migration  client  / country  / galery  => به جای پست ایجاد کردم 

توجه دشته باشید که اول باید جدول کانتری را ایجاد کنید و بعد جدوال کلاینت  و  بعد جدول  پست

به این دلیل که ما در جدول یوزر  کانتری  ایدی داریم و در جدول  پست  یوزر  ایدی  پست باید  اول جدول مورد نیاز ایجاد شده باشد

اگر برای مثال جدول کلاینت را داشتیم از قبل حالا باید تاریح فایل آن را   ری نیم    کنیم تا  بین   کانتری و پیت قرار بگیرد تا ارتباط به درستی انجام شود 


می خواهیم  پست ها یا گارلری های مربوط به کاربران یک کشور را استخراج کنیم 



in migrate  Country


		Schema::create('countries', function (Blueprint $table) {
            $table->bigIncrements('id');
			
            $table->string('title');
            $table->timestamps();
        });





in migrate  Client


		Schema::create('clients', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
			
			
			$table->unsignedBigInteger('country_id');
			$table->foreign('country_id')->references('id')->on('countries')->onDelete('cascade');
			
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });




in migrate  Gallery


		Schema::create('galleries', function (Blueprint $table) {
            $table->bigIncrements('id');
			
            $table->string('title');
			
			$table->unsignedBigInteger('client_id');
			$table->foreign('client_id')->references('id')->on('clients')->onDelete('cascade');
			
			
            $table->timestamps();
        });




in model  Country 

	class Country extends Model
	{
		use HasFactory;
		
		
		public function galleries(){
			return $this->hasManyThrough(Gallery::class, Client::class);
			
			
			 برای زمانی که اسم فیلدهای جدول دلبخواهی است 
			
			//return $this->hasManyThrough(Gallery::class, Client::class,
			// "کلید خارجی  در جدول واسط" ,
			//"کلید خارجی جدول واسط در جدول اطلاعات یا  پست ها  (کلید خارجی خود جدول واسط)"
			//,"کلید اصلی جدول که داریم این مدل را در آن می نویسم که در اینجا   کانتری است ",
			// "کلید اصلی جدول واسط");
			
			//return $this->hasManyThrough(Gallery::class, Client::class, "country_id","user_id","id",'id');
		}
	}



in controller  


/* hasManyThrough */
		
		$country = Country::find(1);
		
		dd($country->galleries);







---------------------------------------------------session 49  (67)

++++   Relationship  Polymorphic (one to one)


در این روابط  یک مدل  می تواند به طور همزمان به چند  مدل دیگر  تعلق  داشته باشد

در حالت  عادی یک جدول  پست داریم   و یک  جدول کامنت  که چون در  جدول کامنت  
post_id
تعریف شده  این جدول به پست ها تعلق دارد و برای ساخت کامنت باری جدول  مثلا   محصولات  باید جدول جدید ایجاد کنم 

همینطور برای قیمت ها دیگر 

اما در روابط  
Polymorphic
ما با یک جدول ارتباطات مورد نظر را ایجاد می کنیم 

در حقیقت  جدول کامنت می تواند به بی نهایت جدول دیگر متصل شود 



Polymorphic      (one to one)

ما در اینجاد  دو جدول  پست  و   محصولات داریم 

برای هر پست  یک تصویر داریم  و برای هر  محصول هم یک تصویر داریم 


در داخل جدول تصاویر  علاوه بر  فیلده ای اصلی   مثل 
url 
و ...

دو فیلد هم باید داشته باشیم

imageable_id
imageable_type

imageable  ==> اسم رابطه  پلی مورفیک
 
اسم  مدل  مقصد   +  able 


_id   ==>   ایدی  جداول  مبدا

_type  ==>  اسم  جدول  مبدا   App/models/Post



ایجاد   مدل و مایگریت   
Product  /  Image  /   Post


in migrate Post

	Schema::create('posts', function (Blueprint $table) {
		$table->bigIncrements('id');
		$table->string("title");
		$table->timestamps();
	});



in migrate Product

		Schema::create('products', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('name');
            $table->integer('price');
            $table->timestamps();
        });


in migrate Image

		Schema::create('images', function (Blueprint $table) {
			
            $table->id();
            $table->string('url');
            $table->morphs('imageable');
			
			==>  establish   imageable_id  &  imageable_type
			
			
            $table->timestamps();
        });



php artisan  migrate 




in  model  image   (مدل  مقصد )


	public function imageable(){
			
		return $this->morphTo();
		
	}
	

in other model 

	//post 
	public function image(){
		
		return $this->morphOne(Image::class,'imageable');
		
	}
	
	//product
	
	public function image(){
		
		return $this->morphOne(Image::class,'imageable');
		return $this->morphOne(maghsad class name,'اسم رابط پلی مورفیک ');
		
	}



in controller 

		$post = Post::find(1);
		
		$post = Product::find(1);
		
		dd($post->image);



رابطه  معکوس

in controller 


// معکوس  مورف  یک به یک 

$image=Image::find(1);

dd($image->imageable);


پارامترهای دیگر برای زمانی که اسم فیلدها دل خواهی بوده است 

رابطه نهایی که این جا در مدل 
Image
اسم  پارامتر دیگری ندارد 

return $this->morphTo();


in post model

return $this->morphOne(class maghsad name,'polymorphic interface',"imageable_type","imageable_id","id modeli ke rabeteh darim da on mine visim");

return $this->morphOne(Image::class,'imageable',"imageable_type","imageable_id","id");
		

داخل
product 
هم به همین شکل است 



insert    Delete   Update 


//PlyMorphic insert
		
		
		$post =Post::find(1);
		
		$result = $post->image()->create([
			"url" => 'upload\images\test3.jpg'
		]);
		
		dd($result);



//Polymorphic update
		
		$post =Post::find(1);
		
		$result = $post->image()->update([
			"url" => 'upload\images\test4.jpg'
		]);
		
		dd($result);



//Polymorphic delete
		
		$post =Post::find(1);
		
		$result = $post->image()->delete();
		
		dd($result);
		







---------------------------------------------------session 50  (68)

++++   Relationship  Polymorphic (one to Many)


یک جدول برای پست ها داریم 
یک جدول برای ویدئو ها 
یک جدول هم برای  نظرات

داخل جدول 

recomment

recommentable_id
recommentable_type

داریم 

یک پست می تواند  چندین کامنت داشته باشد اما هر کامنت متعلق است به یک پست

یک ویدئومی تواند  چندین کامنت داشته باشد اما هر کامنت متعلق است به یک ویدئو

ساخت مدل و مایگریت  
post  /  video  / recomment


 migrate  post 
 
		Schema::create('posts', function (Blueprint $table) {
            $table->bigIncrements('id');
			$table->string("title");
            $table->timestamps();
        });
 
 
 migrate  recomment

		Schema::create('recomments', function (Blueprint $table) {
            $table->id();
			
            $table->text('body');
            $table->morphs('recommentable');
			
			
            $table->timestamps();
        }); 
 
 
 
 
 migrate  videos 

 
	Schema::create('videos', function (Blueprint $table) {
            $table->id();
            $table->string('title');
            $table->timestamps();
        });


هدف این است که بگوییم این پست مورد نظر چه کامنت هایی دارد 


in Recomment Model

	protected $fillable = ['body'];

	public function recommentable(){
		return $this->morphTo();
	}


in Video Model
	
	public function recomments(){
		return $this->morphMany(Recomment::class,"recommentable");
	}


in Post Model
	public function recomments(){
		return $this->morphMany(Recomment::class,"recommentable");
	}


in controller 


// Polymorphic  oneToMany
		
		$post = Post::find(1);
		$post = Video::find(2);
		
		dd($post->recomments);
		


حالا اگر  از فیلدهای دلخواهی استفاده کردیم می توانیم به شکل زیر عمل کنیم 

return $this->morphOne(class maghsad name,'polymorphic interface',"recommentable_type","recommentable_id","klid asli modeli ke rabeteh darim ra dar oon minevisim");
		
return $this->morphOne(Recomment::class,'recommentable',"recommentable_type","recommentable_id","id");


رابطه معکوس 




$recomment=Recomment::find(1);

dd($recomment->recommentable);




/  insert   update  delete 


// insert
		
		$post =Post::find(1);
		
		$result = $post->recomments()->create([
			"body" => 'shir laravel ti vue'
		]);
		
		dd($result);


// update
		
		$post =Post::find(1);
		
		$result = $post->recomments()->update([
			"body" => 'shir laravel ti vue morph'
		]);
		
		dd($result);
		
		
		
		$post =Post::find(1);
		
		$result = $post->recomments()->where('id',4)->update([
			"body" => 'Vue X'
		]);
		
		dd($result);
		
		
		
		
//delete
		
		$post =Post::find(1);
		
		$result = $post->recomments()->delete();
		
		dd($result);
		
		
		


---------------------------------------------------session 51  (69)


++++   Relationship  Polymorphic (Many to Many)


یک جدول  تصاویر داریم  
یک جدول برای پست ها  و یک جدول برای دسته بندی ها 

هر پست  یا  تصویر می تواند  چندین  دسته بندی دشته باشد و از 
طرفی هر کتگوری می تواند چندین پست یا تصویر را دردرون خود قرار دهید 

جدول واسط در ایجاد 
categorizables
است و شامل فیلدهای زیر می باشد 

category_id
categorizable_id
categorizable_type



create model and migrate    Post / Category / Picture / Categorizable


migrate Post 

		Schema::create('posts', function (Blueprint $table) {
            $table->bigIncrements('id');
			$table->string("title");
            $table->timestamps();
        });

migrate Category 

		Schema::create('categories', function (Blueprint $table) {
            $table->id();
            $table->string('name',100);
            $table->timestamps();
        });

migrate Picture

		Schema::create('pictures', function (Blueprint $table) {
            $table->id();
            $table->string('title');
            $table->timestamps();
        }); 

migrate Categorizable

		Schema::create('categorizables', function (Blueprint $table) {
			
            $table->unsignedBigInteger('category_id');
            $table->foreign('category_id')->references->('id')->on('categories')->onDelete('cascade');
			
            $table->morphs('categorizable');
            $table->timestamps();
        }); 



هدف این است که کتگوری های مربوط به پست شماره  
2
را برگردانم 


in model  Category

هیچی


in model  Picture

	public function categories(){
		return $this->morphToMany(Category::class,"categorizable");
	}


in model  Post

	public function categories(){
		return $this->morphToMany(Category::class,"categorizable");
	}


in model  Categorizable

	public function categorizable(){
		return $this->morphTo();
	}
	

in controller 

		$post = Post::find(1);
		
		dd($post->categories);


گاهی اسم فیلد هار ا دلبخواهی می گذرایم که دراین صورت باید به روش زیر عمل کنیم 

		return $this->morphToMany(
			اسم مدلی که می خواهیم با آن ازتباط برقرار کنیم ,
			"اسم رابط پلی مورفیک ",
			"اسم جدول واسط",
			'کلید خارجی جدول مقصد',
			"کلید خارجی مدل های مبدا ",
			"کلید اصلی مدلی که داخل اون داریم رابطه را می نویسیم ",
			"کلید اصلی جدول مقصد",
			false
		);
		return $this->morphToMany(Category::class,"categorizable",'categorizables','category_id', "categorizable_id","id","id" , اگر ترو شود می شود رابطه معکوس);



رابطه معکوس
حالا می خواهیم پست هایی که در یک کتگوری قرار می گیرند را برگردانیم 


in model  Category


	public function posts(){
		return $this->morphedByMany(Post::class,"categorizable");
	}
	
	public function pictures(){
		return $this->morphedByMany(Picture::class,"categorizable");
	}


in controller 

/* راطه معکوس */
		
		$category = Category::find(2);
		
		
		dd($category->posts);
		dd($category->pictures);
		


پارامترهای اضافه برای اسم های دلخواهی 



return $this->morphedByMany(
			اسم مدلی که می خواهیم با آن ازتباط برقرار کنیم ,
			"اسم رابط پلی مورفیک ",
			"اسم جدول واسط",
			'کلید خارجی جدول مقصد',
			"کلید خارجی مدل های مبدا ",
			"کلید اصلی مدلی که داخل اون داریم رابطه را می نویسیم ",
			"کلید اصلی جدول مقصد",
			true              (--> true)
		);
		return $this->morphToMany(Category::class,"categorizable",'categorizables','category_id', "categorizable_id","id","id" , اگر ترو شود می شود رابطه معکوس);



save  and attach  many to many

in controller


		$category = Category::find(1);
		
		$post = Post::find(2);
		
		$result = $post->categories()->save($category );
		
		dd($result);
		
	با این روش بین یک  پست و کتگوری  رابطه برقرار می کنیم و میگوییم که  یک پست چه کتگوری داشته باشد 
	


		$category = Category::find(1);
		
		$post = Post::find(3);
		
		$result = $post->categories()->attach($category );
		
		dd($result);
		


//  sync  

بررسی می کند که این پست این کتگوری ها را دارد  یا نه 


		$category = Category::find([1,2]);
		
		$post = Post::find(3);
		
		$result = $post->categories()->sync($category );
		
		dd($result);
		
بررسی می کند اگر  رابطه ای وجود دشات آن ها را پاک می کند  و رابطه های جدیدی که به اون دادیم را اضافه می کند 
توجه  منظور  رابطه های بین  پست 
3
و کتگوری  
1 و 2 
است 

برای اینکه بگوییم مقادیر قبلی را پاک نکن  پارامتر دوم به آن می دهیم 
$result = $post->categories()->sync($category ,false);


detach


		$category = Category::find(2);
		
		$post = Post::find(3);
		
		$result = $post->categories()->detach($category );
		
		dd($result);
		
	ایت دستور رابطه بین  پست  
	3
	و گتگوری 
	2
	را از بین می برد و رابطه را از جدول 
	categorizables
	پاک می کند 
	





	
---------------------------------------------------session 52  (70,71)

Collections

همان ارایه ها هستند ولی فراتر از آرایه ها عمل می کنند 

collections is  wrapper for arrays   یک پوشش


لاراول یه ما کمک میکند با این موارد تا کاراهایی که روی آرایه ها با روش ها 
functional
انجام می دادیم   حالا در بستر 
object oriented
اون ها را رو انجام دهیم 

کالکشن ها مثل آرایه ها قابل پیمایش هستند و می توانیم با 
foreach
 روی انها پیمایش کنیم

ایجاد کردن کالکشن ها 


in controller 

	$collection = collect([1,2,3]);
		
	dd($collection);

حالا با متود ها مربوط به ابجمت ارینتد می توانیم به مقادیر دسترسی داشته باشیم 

dd($collection->get(0)); //  ایندکس  0 را برمی گرداند 


dd($collection->all(0));   // همه را برمی گرداند 

dd($collection->first());  // اولی

dd($collection->count());  // شمارش اعضای ارایه

dd($collection->toArray());  // کالکشن را تبدیل میک ند به  آرایه 


dd($collection->toJson()); //  کالکشن را به  جیسون تبدیل می کند 


in laravel documention ==> Digging Deeper

در این قسمت می توانیم همه متود ها را ببینیم 



++++++++   مهمترین دستورات  کالکشن ها 

dd($collection->has(12));   // بررسی می کند که ایا  12 در کالکشن وجود دارد  یا نه و اگر بود    ترو  برمیگرداند

dd($collection->isEmpty());  // بررسی می کند که ایا کالکشن خالی است یا  نه 



آرایه انجمنی 

$collection = collect([
	'name' => 'namel',
	'age' => 21,
]);

dd($collection->get('age'));


dd($collection->all());


				array:2 [▼
				  "name" => "namel"
				  "age" => 21
				]




dd($collection->forget('age')->all());  // مثل یک فیلتر عمل می کند  و دیگر 
										//  age  
										// را داخل آرایه نمایش نمی دهد 
										
				array:1 [▼
				  "name" => "namel"
				]


همچنین کالکشن می تواند  ارایه ای از آرایه ها باشد 

$collection = collect([
		[
			'name' => 'namel1',
			'age' => 30,
		],
		[
			'name' => 'namel2',
			'age' => 40,
		],
		[
			'name' => 'namel3',
			'age' => 20,
		]
]);

dd($collection->avg('age'));  // میانگین سن ها را برمی گرداند 


dd($collection->chunk(2));  // ارایه ها را دوتا دوتا  دسته بندی می کند 
							// مثلا برای مثال بالا ارایه را یه ارایه با دو عضو تقسم می کند که اعضای آن خود کالکشن است 
				
				Illuminate\Support\Collection {#1305 ▼
				  items: array:2 [▼
					0 => Illuminate\Support\Collection {#1296 ▼
					  items: array:2 [▼
						0 => array:2 [▼
						  "name" => "namel1"
						  "age" => 30
						]
						1 => array:2 [▼
						  "name" => "namel2"
						  "age" => 40
						]
					  ]
					}
					1 => Illuminate\Support\Collection {#1303 ▼
					  items: array:1 [▼
						2 => array:2 [▼
						  "name" => "namel3"
						  "age" => 20
						]
					  ]
					}
				  ]
				}



dd($collection->contains('name','name1'));  // بررسی می کند که آیا داخل  نیم  ها   نیم 1 داریم یا نه 




$result = $collection->filter(function($value,$key){
	return $value['age']>21;
});

dd($result);

مانند فور ایچ در ارایه  پیمایش می کند و هر دستوری که خواستیم اعمال می کنیم 
$value ==>  مقادیر آرایه 
$key ==> خانه های آرایه یا همان ایندکس ارایه 





$result = $collection->map(function($item,$key){
			
	return ['title'=> $item['name'] , 'age'=> $item['age']/2 ];
	
});

dd($result);

name 
را به 
title 
تغییر می دهد و تمام  
age
ها را تقسیم بر   
2
می کند 

Illuminate\Support\Collection {#1303 ▼
  #items: array:3 [▼
    0 => array:2 [▼
      "title" => "namel1"
      "age" => 15
    ]
    1 => array:2 [▼
      "title" => "namel2"
      "age" => 20
    ]
    2 => array:2 [▼
      "title" => "namel3"
      "age" => 10
    ]
  ]
}





dd($collection->pluck('name'));  نام ها را استخراج کرده و اونا رو به شکل یک آرایه برمی گرداند 

Illuminate\Support\Collection {#1296 ▼
  #items: array:3 [▼
    0 => "namel1"
    1 => "namel2"
    2 => "namel3"
  ]
}



dd($collection->implode('name' , ", "));    تنها نام ها رو می گیرد و اونا رو با کاما به هم وصل می کند 

"namel1, namel2, namel3"





dd($collection->all());

در حالتی که از این متود استفاده می کنیم  کلید  آرایه ها  اولی را  با اعداد  نشان می دهد  اما شاید 
ما تمایل داشته باشیم که این اعداد نباشد

array:3 [▼
  0 => array:2 [▼
    "name" => "namel1"
    "age" => 30
  ]
  1 => array:2 [▼
    "name" => "namel2"
    "age" => 40
  ]
  2 => array:2 [▼
    "name" => "namel3"
    "age" => 20
  ]
]


برای این اعداد نباشد با روش زیر می توانیم تعیین کنیم که چی باشد 
با این روش هر مقداری که در ارایه قرار دارد می توانیم به جای   کی ها قرار دهیم 


dd($collection->keyBy('name'));  // استفاده از   نیم 


Illuminate\Support\Collection {#1303 ▼
  #items: array:3 [▼
    "namel1" => array:2 [▼
      "name" => "namel1"
      "age" => 30
    ]
    "namel2" => array:2 [▼
      "name" => "namel2"
      "age" => 40
    ]
    "namel3" => array:2 [▼
      "name" => "namel3"
      "age" => 20
    ]
  ]
}

dd($collection->keyBy('age')); // استفاده از سن ها 


Illuminate\Support\Collection {#1303 ▼
  #items: array:3 [▼
    30 => array:2 [▼
      "name" => "namel1"
      "age" => 30
    ]
    40 => array:2 [▼
      "name" => "namel2"
      "age" => 40
    ]
    20 => array:2 [▼
      "name" => "namel3"
      "age" => 20
    ]
  ]
}






Elequent
همیشه یک collection برمیگرداند

============

ما خودمان هم می توانیم یک متود به متودهای collection  اضافه کنیم و بعد از استفاده کنیم


use Illuminate\Support\Collection; 
use Illuminate\Support\Str;

 Collection::macro('toUpper', function () {

 return $this->map(function ($value) {

 return Str::upper($value);
 }); 
}); 

$collection = collect(['first', 'second']); 

$upper = $collection->toUpper(); 

// ['FIRST', 'SECOND']


تعریف متود سفارشی برای کالکشن را می توانید در هرجایی انجام دهید.  می توانید در کنترلر اینکار را انجام دهید و یا که برای انکه در همه جا در دسترس با ان را در 
Service provider
و در متود boot تعریف کنید


===============
از متود کالکشن زیر می توانید برای ترجمه عبارات استفاده کنید

use Illuminate\Support\Collection;
 use Illuminate\Support\Facades\Lang; 
use Illuminate\Support\Str;

 Collection::macro('toLocale', function ($locale) { 

return $this->map(function ($value) use ($locale) { 

return Lang::get($value, [], $locale); 

}); 
}); 

$collection = collect(['first', 'second']); 

$translated = $collection->toLocale('es');


================
متودهای کالکشن ها در لاراول

توجه داشته باشید که این متودها می توانند به هم chain شوند.

collect([1, 2, 3])->all(); 
// [1, 2, 3]

---------

average()
Alias for the avg method.

--------------

$average = collect([ 
['foo' => 10], 
['foo' => 10], 
['foo' => 20], 
['foo' => 40] 
])->avg('foo');              // 20

 $average = collect([1, 1, 2, 4])->avg();     // 2

در ارایه های انجمنی با گرفتن key میانگین را برمی گرداند اما برای ارایه های ساده key نیازی نیست

----------

$collection = collect([1, 2, 3, 4, 5, 6, 7]); 

$chunks = $collection->chunk(4); 

$chunks->all(); 

// [[1, 2, 3, 4], [5, 6, 7]]

این متود  در  views برای زمانی که از بوت استرپ استفاده می کنیم برای column بندی عالی است


@foreach ($products->chunk(3) as $chunk) 

<div class="row"> 

@foreach ($chunk as $product) <div class="col-xs-4">{{ $product->name }}</div>

 @endforeach 
</div> 
@endforeach

------------------
chunkWhile

$collection = collect(str_split('AABBCCCD'));

 $chunks = $collection->chunkWhile(function ($value, $key, $chunk) { 

return $value === $chunk->last(); 
}); 
$chunks->all(); 
// [['A', 'A'], ['B', 'B'], ['C', 'C', 'C'], ['D']]

===========
collapse

این مورد مجموعه ای از ارایه ها را داخل یک ارایه جمع اوری می کند

$collection = collect([ 
[1, 2, 3], 
[4, 5, 6], 
[7, 8, 9], 
]); 

$collapsed = $collection->collapse(); 

$collapsed->all(); 

// [1, 2, 3, 4, 5, 6, 7, 8, 9]








---------------------------------------------------session 53  (72,73)
Sessions

درخواست های 
http
ناپایدار هستند

state less

تنظیمات  سشن ها

config folder /session.php


'driver' => env('SESSION_DRIVER', 'file'),   // شکل ذخیره سشن ها 

Supported: "file", "cookie", "database", "apc",
            "memcached", "redis", "dynamodb", "array"


برای ذخیره  سشن ها  در دیتابیس هم یک دستور دارد ارتیسان

php artisan session:table

با اجرای این دستور یک مایگریت ایجاد می کند و اطلاعاتی که نیاز دارد را در داخل آن قرار می دهد 

		Schema::create('sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->text('payload');
            $table->integer('last_activity')->index();
        });


بهترین حالت 
file 
است 

در اینحالت سشن به صورت فایل در پوشه 
storege/framework/sessions 

قرار می گیرد 


ایجاد سشن 

in controller

از هلپر فانکشن  
session
استفاده می کنیم 

ست کردن 

روش اول 

session()->put('name' , "value");
session()->put('name' , "first my sesion in laravel");

روش دوم 


session(['name' => "third my sesion in laravel"]);



گرفتن  سشن

روش اول

$session = session()->get('session name');
$session = session()->get('name');

روش دوم 

$session = session('name');



تعریف چند سشن باهم 

session()->put([
	'name' => "third my sesion in laravel",
	'title' => "session laravel",
]);


$session = session()->all();
dd($session);

// کل سشن ها را برمی گرداند 

array:5 [▼
  "_token" => "adx90M0TPziOznNTEwTIrGUEzr6ZIG7wiZr1M70y"
  "name" => "third my sesion in laravel"
  "_previous" => array:1 [▼
    "url" => "http://127.0.0.1:8000/session"  // ادرسی که کاربر از آن امده است 
  ]
  "_flash" => array:2 [▼
    "old" => []
    "new" => []
  ]
  "title" => "session laravel"
]


اون فلش سشنی که اطلاعات کاربر و  ارور ها در آن ذخیره می شد همین 

_flash

است 



$session = session()->has('name2');
dd($session);

بررسی می کند که ایا در سشن ها  سشنی به اسم 
name2
وجود دارد یا نه و اگر وجود داشت
true
برمی گرداند 
		
		
	
$session = session()->exists('name2');
		dd($session);
برسی می کند که ایا  سشن وجود دارد یا نه 



has  

روی 
value
چک می کند و اگر مقدار یکی را برابر با 
null
قرار دهیم   
has  
false
برمی گیرداند 


session()->put([
	'name' => null,
	'title' => "session laravel",
]);	

اما چون 
exists
از روی 
key
چک می کند گر نال  کنیم ویلی  
key
وجود داشته باشد   بازهم  ترو   می آورد 


session()->forget('name');
$session = session()->all();
dd($session);

در خروجی دیگر سشن 
name 
را برنمیگرداند  و نمایش نمی دهد 


		
session()->flush();
$session = session()->all();
dd($session);	

همه   سشن ها را پاک می کند و یک ارایه خالی 
[]
برمی گرداند 	
		


گاهی ما داده ها را برای درخواست بعدی در سشن ذخیره  می کنیم که در این صورت آن ها را 
در 
flash
ذخیره می کنیم
این سشن ها  فقط و فقط در درخواست 
http
بعد در دسترس هستند و بعد بلافاصله پاک می شوند 

این مورد برای  
status message 
ها  یعنی پیام ها تایید ذخیره اطلاعات یا حذف پیام و 
...
عالی است 



ایجاد کردن  سشن   فلش

session()->flash('msg','laravel');


فراخوانی 

$session = session()->all();
return $session;
		
	
{"_token":"adx90M0TPziOznNTEwTIrGUEzr6ZIG7wiZr1M70y","name":"third my sesion in laravel","_previous":{"url":"http:\/\/127.0.0.1:8000\/session"},


"_flash":{"old":["msg"],"new":[]},


"title":"session laravel","msg":"laravel"}

==> refresh 

	
{"_token":"adx90M0TPziOznNTEwTIrGUEzr6ZIG7wiZr1M70y","name":"third my sesion in laravel","_previous":{"url":"http:\/\/127.0.0.1:8000\/session2"},

"_flash":{"old":[],"new":[]},


"title":"session laravel"}	
		
دیگر ما سشن  
msg
را نداریم 
		


session()->reflash();
		
$session = session()->all();
return $session;

با این روش می توانیم بگوییم که  فلش  سشن  حذف نشود و در درخواست های بعدی هم باشد 


{"_token":"adx90M0TPziOznNTEwTIrGUEzr6ZIG7wiZr1M70y","name":"third my sesion in laravel","_previous":{"url":"http:\/\/127.0.0.1:8000\/session"},

"_flash":{"old":[],"new":["msg"]},  // اینبار در    نیو    قرار دارد 


"title":"session laravel","msg":"laravel"}		
		
		
		
برای  ست کردن  سشن  فلش نمی توانیم از ارایه استفاده کنیم و اگر نیاز بود بیش از یکی ست کنیم باید دوباره بنویسیم 

session()->flash('msg','laravel');
session()->flash('msg2','vue');		
		
		
session()->reflash();
		
session()->keep(['name']);

$session = session()->all();
return $session;		

این دستور  فقط   فلش  سشن   
name
را نگه می دارد و بقیه  فلش سشن ها پاک می شوند 


	

---------------------------------------------------session 54  (74)

cache

نقش زیادی در افزایش سرعت وبسایت ما دارد 
باعث می شود   سایت  سریع تر از حالت معمولی   لود  شود 


برای مثال ما یک کویری پیچیده داریم که اطلاعات را از دیتابیس طی یک مدت زمانی می گیرد
برای انیکه ما مجبود نباشیم دوباره اطلاعات را از دیتابیس بگیریم  می آیم اطلاعات برگشتی از 
دیتابیس را داخل کش قرار می دهیم و دفعه بعد اطلاعات را از کش می خوانیم 


تنظیمات کش  
config folder   / cache.php 

'default' => env('CACHE_DRIVER', 'file'),  نوع ذخیره


Supported drivers: "apc", "array", "database", "file",
    "memcached", "redis", "dynamodb", "octane", "null"
	
	پشتبانی از این موارد برای ذخیره کش 
	
توجه داشته باشید که برای تغییر  شکل ذخیره سازی کش  
چون ا ز فایل  
env
می خواند باید از آنجا تغییرات را  اعمال کنیم 


برای ذخیره در دیتابیس هم می توانیم از ارتیسان کمک بگیریم 

php artisan cache:table   == >  ایجاد مایکریت برای کش
php artisan cache:clear   == >  ایجاد مایکریت برای کش
php artisan cache:forget   == >  پاک کردن  ایتم مورد نظر 


php artisan cache:table  ==> create migrate


Schema::create('cache', function (Blueprint $table) {
	$table->string('key')->unique();
	$table->mediumText('value');
	$table->integer('expiration');
});

اگر خواستید  در دیتابیس ذخیره کنید   یادتان  نره در فایل 
.env
محل ذخیره سازی را تغییر دهید 


محل ذخیره به شکل فایل هم 

storage/framework/cache/data


روش کش کردن اطلاعات در لاراول

in controller

use Illuminate\Support\Facades\Cache;


برای ست کردن 

/* Cache::put('key','value','expire time(second)'); */
Cache::put('ali','laravel ali',15);

key  ===> برای دسترسی به آن مثل اسم  سشن و کوکی است 



برای گرفتن   کش 


$cache = Cache::get('ali');  //get 

$cache = Cache::get('ali' , "default value");  // with defaul value

// if ali no exist  return  default value
		
dd($cache);



---------------------------------------------------session 55  (75)

متود های کاربری 
cache

$cache = Cache::remember('ali',600, function(){
	return "ali mohseni";
});

dd($cache);

بررسی می کند که ایا در کش ها  
key  ali
وجود دارد یا نه اگر وجود داشته که مقدارش را برمی گرداند اما اگر وجود ندارد کلوژر را اجرا کرده و مقداری که داخل ان  
return 
شده را برای مدت زمانی که به آن داده ایم در کش ذخیره  کش با آن  
key
ذخیره می کند 




$cache = Cache::has('alis');
		
dd($cache);

بررسی میکند که ایا کش وجود دارد یا نه 
اگر کش با این نام وجود داشت   ترو   برمی گرداند 



$cache = Cache::forget('ali');   

این متود کشی که گفتیم را پاک می کند و اگر پاک کرد       
true
برمی گرداند

$cache = Cache::pull('ali');

این متود هم کشی که گفتیم را پاک می کند با این تفاوت که مقداری کشی که پاک کرده است  مثلا 
'laravel ali'
بوده    
=== > آن را برمی گرداند تا بفهمیم چه مقداری را پاک کرده است     
توجه مقدار  کش  برای یک   کی   را برمی گرداند  نه  کی را 


dd($cache);


دستورات ارتیسان  کش

php artisan view:cache  ===> لاراول می آید  تمپت ها   بلید   را کش می کند 
php artisan view:clear   ===> کش های مربوط به   ویوها   را  پاک میکند
php artisan route:cache   ===> روت ها را کش می کند تا سریع تر اجرا شوند 
php artisan route:clear  ===>  روت هارا پاک می کند 
php artisan event:cache  ===>  کش کردن  رویدادها
php artisan event:clear  ===>  پاک کردن رویداد ها 
php artisan config:cache  ===>  کش کردن کانفیگ ها 
php artisan config:clear  ===>   پاک کردن  

php artisan cache:clear  ===>   تمام کشها سیستم لاراولی ما را پاک می کند 
php artisan cache:forget  ===>   پاک کردن  کش مورد نظر 
php artisan cache:table  ===>   پاک کردن  






توجه داشته باشید که وقتی میخواهید  پروژه را اپلود کنید روی   سرور  حتما  حتما  قبلش باید 
کش ها را پاک کنید و بعد پروژه را اپلود کنید 




---------------------------------------------------session 56  (76)

Middleware

به معنی میان افزار است و در واقع پلی هست میان   درخواست و پاسخ که کارش   فیلتر کردن است

مثلا کاربر درخواستی را ارسال میکند   ما در این قسمت بررسی می کنیم که ایا این درخواست مورد تایید ما هست یا نه 
همچنین درخواستی که از سمت سرور برمی گردد را هم می توانید بررسی کنیم ببینیم اگرهمچی اوکی بود بعد نتیجه را به 
کاربر نمایش دهیم

برای مثال در سایت قسمتی داریم که تنها کاربرانی که لاگین کرده اند می توانند به آن دسترسی داشته باشند خود ما در این قسمت بررسی می کنیم 
که ایا کاربر لاگین هست یا نه 
اگر لاگین نبود می فرستیمش به صفحه لاگین 


in app/http/middleware

در این پوشه یکسری  میدل ویر های  از پیش تعریف شده  لاراول وجود دارد مثل 
csrfToken
Authenticate
EncryptCookie  
و ....

ساخت میدل ویر سفارشی 

in cmd   php artisan make:middleware --help

php artisan make:middleware --help
php artisan make:middleware name


php artisan make:middleware CheckNameParameter

در پوشه  میدل ویر ها باید یک فایل با این نام ایجاد شده باشد 


ما هرکاری که خواستیم را می توانید در 
متود handle
قبل از 
return

انجام دهیم 

public function handle(Request $request, Closure $next)
{
	return $next($request);
}


اما هنوز  میدل ویر من ساخته شده توسط سیستم شناسایی نمیشود  برای همین باید به فایل
kernel.php 
برویم 

in http folder

در این فایل ما سه سری  میدل ویر می توانیم تعریف کنیم 

اگر ما میدل ویر را توی 
protected $middleware
قرار دهیم روی  تمام  روت ها  اعمال می شود 

اگر بخواهیم میدل ویر را روی خاصی مثال روت های    
web  or  api
تعریف کنیم باید آن ها را داخل 
protected $middlewareGroups
قرار دهیم 


بهترین موارد 
protected $routeMiddleware
است که نام مستعار به    میدل ویر اختصاص می دهد و ما می توانیم از آن برای هر روتی که 
خواستیم استفاده کنیم و میدل ویر را روی آن اعمال کنیم 

'auth' => \App\Http\Middleware\Authenticate::class,
'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,


protected $middlewarePrority

که برای اولیت میدل ویرها بود است  دیگر در  فایل کرنل لاراول 
8
وجود ندارد 


ما میدل ویری که  الان ساختیم را توی 

protected $routeMiddleware
قرار می دهیم 

'name' => \App\Http\Middleware\CheckNameParameter::class,

توجه داشته باشیم که نامی که انتخاب می کنید نباید تکراری باشد و گرنه  تداخل پیدا میکند

حالا برای اجرای میدل ویر به 
web.php 

می رویم 

use App\Http\Controllers\MiddleW;
Route::get('/mv',[MiddleW::class,"index"])->middleware("name");

روش دوم

Route::get('/mv',["middleware"=> 'name', 'uses' => 'App\Http\Controllers\MiddleW@index']);



public function handle(Request $request, Closure $next)
{
	
	if($request->has('name')){
		return $next($request);
	}else{
		return abort(404);
	}
	
}

این دستور بررسی می کند که ایا در روت ارسالی یا درخوایت ارسالی 
name
وجود دارد یا نه 
اگر وجود نداشت ما را به 
404
می فرستد


ارسال مقدار به  میدل ویر از طریق  روت  و دریافت آن 

Route::get('/mv',[MiddleW::class,"index"])->middleware("name:par1,par2,par3");
public function handle(Request $request, Closure $next,$value1,$value2,$value3)
{
	
	dd($value1,$value2,$value3);
	return abort(404);
	
	
}



---------------------------------------------------session 57  (77)

انواع  میدل ویر ها 

معرفی  سه نوع 
middleware 

1. before
2. after 
3. terminate


before    => زمانی است که ما می خواهیم درخواست کاربر را بررسی کنیم و اگر همچی اوکی بود بفرستیم تا توسط سرور اجرا شود
after     => برای زمانی است که سرور پاسخ داده است و حالا برای نمایش به کاربر از میدل ویر  عبورش می دهیم تا مطمئن شویم همچی اوکی است
terminate => بلافاصله پس از ارسال پاسخ به مرورگر فراخوانی و اجرا می شود


before 

in file middle mored nazar



public function handle(Request $request, Closure $next)
{
	echo "Before ---> ";  ===>  محل قرار دادن دستورات برای     before
	return $next($request);    
}

in controller

echo "Controller";


in web.php
Route::get('/mv2',[MiddleW::class,"index"])->middleware("befores");




----------  result   ===>    Before ---> Controller



after 

public function handle(Request $request, Closure $next)
{
	$response = $next($request);
	
	echo '===>  After  '; 
	
	return $response;
}


Route::get('/mv2',[MiddleW::class,"index"])->middleware("afters");


---------- result   ===>    Controller ===> After


terminate


public function handle(Request $request, Closure $next)
    {
        return $next($request);
    }
	
	public function terminate($request, $response)
    {
        echo " =====>  Terminate ";
    }




Route::get('/mv2',[MiddleW::class,"index"])->middleware("terminates");

---------- result   ===>    Controller =====> Terminate


---------------------------------------------------session 58  (78)

Authentication 

احراز هویت 



in laravel doc --> security --> Authentication

برای استفاده از سیستم 
authentication
ابتادا باید 
laravel ui
را نصب کنیم 

composer  require laravel/ui

اگر قبلا نصب است نیازی نیست دوباره نصب کنید 

سپس می توانید در این قسمت از ریکت  یا  ویو  یا بوت استرپ  استفاده کنیم با دستورات زیر

php artisan ui bootstrap --auth
php artisan ui vue --auth
php artisan ui react --auth


بعد به ما می گوید که دستور 

npm install

را بزنیم  که می زنیم 



حالا اگر به   
web.php 
برویم  علاوه بر روت ها قبلی یک روت جدید هم خودش قرار داده که به شکل زیر است


Auth::routes();

Route::get('/home', [App\Http\Controllers\HomeController::class, 'index'])->name('home');


همچنین یک سری فایل در یک پوشه
Auth 
در محل کنترلر ها ایجاد کرده است 


همچنین در بخش ویوها هم یک پوشه اضافه کرده اسنت
با نام 
auth


حالا هنوز بوت استرپ کامپایل نشده است تا دیزاین صفحه لاگین درست باشد به همین دلیل از 
لاراول میکس برای کامپایل استفاده می کنیم

npm run dev

حالا به پروژه بروید  میبید که صفحات  لاگین و ریجیستر ایجاد شده است 


---------------------------------------------------session 59  (79)

Authentication  

روت های مربوط به 
auth


php artisan route:list
را بزنید تا همه روت ها را ببینید 

Auth::routes(['register'=> false]);  // unable  کردن رجیستر

اما روت های مربوطه در  پوشه 
vendor / laravel  /ui / src /   AuthRouteMethods.php 

قرار دارند 

اما اگر خواستید روت ها ی اختصاصی داشته باشد 

Auth::routes();
را کامنت کنید و بعد  روت های خود را ایجاد کنید اما برای کنترلر آن ها از دستورات 

AuthRouteMethods.php 
استفاده کیند 

به هیچ وجه  
AuthRouteMethods.php 
تغیر ندهید چون اگر دوباره کامپوزر  اینستال  زده شود 
تمام موارد از دیفالت ایجاد می شوند و تغییرات شما از بین می روند 



---------------------------------------------------session 60  (80,81)

Controller in Authentication


register controller

زمانی که روت لیست را می بینیم  مشاهده می کنیم که برای متود ریجستر
متود 
showRegisterationForm
را فراخوانی کرده است اما زمانی که به 
registerController 
می رویم همچین چیزی نیست 

این موضوع به خاطر این است که به حای آن ها 
ترید 
 use RegistersUsers;
فراخوانی شود است
که این مورد به پوشه 
vendor / laravel /ui / auth-backend / RegistersUsers.php 
اشاره می کند در این فایل ما 
متود 

showRegistrationForm

را میبینیم که کارش فراخوانی 
return view('auth.register');
است 


اما گاهی می خواهیم که  بگوییم   
view
دیگر فراخوانی شود که در این صورت 

 public function showRegistrationForm()
    {
        return view('auth.register');
    }

کپی کرده و در  خود کنترلر آن را پیس می دهیم تا 
متود دیفالت  
overwrite
شود 

use RegistersUsers;
	
public function showRegistrationForm()
{
	return view('auth.register');
}


ما در لیست روت ها یک 
register
دیگر هم داریم که با متود پست به 
کنترلر و متود ریجست اشاره می کند 

این مورد هم دقیقا مانند قبلی است و در 

RegistersUsers.php 
متود اصلی آن قرار دارد 



حالا باید بررسی کنیم که مایگریت ها ایجاد شده باشند و دیگر نیازی نیست ما کاری انجام دهیم و فقط اطلاعات را ثبت و ثبت نام می کنیم 

بدون لاگین نیم توانیم وارد  صفحه 
home 
شویم 
زیرا در کنترلر 
home
$this->middleware('auth');
قرار داد و میدل ور برای بررسی  احراز هویت است 




لاگین هم دقیق از همین موضوع پیروی می کند 

 in loginController 
 
 traid   ==> use AuthenticatesUsers;
 
 استفاده شده است 
 
 
 vendor / laravel /ui / auth-backend / AuthenticatesUsers.php 
 
 
 
 public function showLoginForm()
    {
        return view('auth.login');
    }
را هم می توانید در لاگین کنترل  اور رایت کنید تا ویو دلخواهتان فراخوانی شود 



داخل 
AuthenticatesUsers.php 

یک قسمت قرار دارد که اگر تلاش اضافی برای لاگین وجود داشته باشد کاربر برای مدتی لاک می شود تا درخواست اصافی به سرور ارسال نشود

if (method_exists($this, 'hasTooManyLoginAttempts') &&
	$this->hasTooManyLoginAttempts($request)) {
	$this->fireLockoutEvent($request);

	return $this->sendLockoutResponse($request);
}

اما چطور وقتی لاگین انجام شد  ری دایرکت می شودیم 

در لاگین کنترلر  بخشی به  شکل زیر وجود دارد
 protected $redirectTo = RouteServiceProvider::HOME;
 
 این سرویس پروایدر و  متود 
 Home 
 اشاره دارد 
 
in     RouteServiceProvider.php 

با تغییر 

public const HOME = '/home';

می توانیم تعیین کنیم که کاربر به کدام صفحه برود 
البته بعد از لاگین کردن 



زمانی که تیک  مراابه خاطر بسپار زده می شود  یک  توکن لاراول ذخیره می کند که در دیتابیس که بعدا اگر کاربر آمد و همچی اوکی بود دیگر بدون
لاگین وارد حساب کاربری شود 

برای لاگین در وب از سشن ها استفاده می شود که این سشن ها زمان دارند و بعد از مدتی 
expire
می شود برای تعیین این زمان می توانید به 

config / session.php

مراجعه کنید 

'lifetime' => env('SESSION_LIFETIME', 120),

البته این مورد از فایل
.env
خوانده می شود و برای بهتر بودن رون بهتر است 

SESSION_LIFETIME
را در فایل 
.env
تغییر دهید و اگر این مورد در آن فایل نبود می توانید به راحتی آن را 
بعد از 

SESSION_DRIVER
اضافه کنید 


---------------------------------------------------session 60  (82)

Reset password

زمانی که روی  فراموش کردن رمز بزنید وارد 
http://127.0.0.1:8000/password/reset
می شود 


php artisan route:list  
در روت لیست این مورد هم یک  
Get   and Post
داریم که به 

ForgotPasswordController.php
اشاره دارند 
در این فایل هم از 
traid

use SendsPasswordResetEmails;

استفاده کرده است 

برای تشت ارسال ایمبل فراموشی رمز عبور می توانید از سرویس های ایمیل مجازی مثل
mailtrap
برای تست درست بودن کدها استفاده کنید 
mailtrap.io

mailtrap  => safe Email testing Development

ابتدا در این سایت ثبت نام کنید 
بعد با کلیک کردن روش اسم خودتان وارد 
inbox
می شوید 
حال روی 
demo inbox
بزنید تا اطلاعات مربوط به ارسال به شما نمایش داده شود 


حالا وارد 
.env
شوید و اطلاعات را در این فایل قرار دهید 

MAIL_MAILER=smtp
MAIL_HOST=mailhog	--> cahnge       ----->e.g.   (smtp.mailtrap.io)
MAIL_PORT=1025 			--> cahnge 					(2525)
MAIL_USERNAME=null   --> cahnge 				(832e217a438aca)
MAIL_PASSWORD=null		--> cahnge 			(13d801be387504)
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS=null		--> cahnge 				(info@webprog.ir)

حالا عملیات بازیابی رمز عبور را انجام دهید با هر ایملی که می خواهید 
باید ایمل برایتان ارسال شود 

عملیات یازیابی را باید برای ایملی که قبلا ثبت نام کرده است انجام دهید 
همچنین زمانی که ایمل ارسال شده  یک  دکمه است که وقتی روی آن کلیک می کنید وارد 
یک صفحه از سایت خود می شوید که می گوید  رمز جدید را وارد کنید 

با وارد کردن و تایید رمز شما تغییر می کند 
1234567899


---------------------------------------------------session 61  (83)
پیاده سازی تایید ایمیل در هنگام ثبت نام 
یعنی لینک تایید و صحت ایمیل ارسال شود به ایمیل و کاربر با تایید آن ثبت نامش تکمیل شود 


در حالت عادی در فایل 
vendor / laravel/ ui /src / AuthRouteMethods.php

verify = false
است و ما باید آن را  فعال کنیم که برای این کار به 
web.php
می رویم می گوییم

Auth::routes(['verify' => true]);

حالا اگر 
route:list
بزنیم  روت های مربوط به  وریفای هم نمایش داده می شود

email/resend
email/verify
email/verify/id/hash


قدم بعدی است که به مدل ها هم بفهمانیم که همیچنین کاری می خواهیم انجام دهیم 

برای این کار به مدل کاربران می رویم و  این کار را انجام می دهیم 

class User extends Authenticatable ===> convert to ====>

class User extends Authenticatable implements MustVerifyEmail


حالا یک  میدل ویر هم به روت اضافه می کنیم تا  زمانی که ایمیل تایید نشده است اجازه ورود ندهد 

Route::get('/home', [App\Http\Controllers\HomeController::class, 'index'])->name('home')->middleware('verified');

حالا اگر کاربر ثبت نام کند فیلد 
email_verified_at
داخل دیتابیس خالی است و اگر ایمیل را تایید نکرده باشد نمی تواند وارد شود 
اما بلافاصاله بعد از تایید ایمیل این فیلد پر می شود و کاربر به راختی می تواند لاگین کند 

حالا عمیلات ثبت نام را انجام دهیم و باید به شما بگوید تا ایمیل تایید نشده نمی توانید وارد شود
وقتی به 
mailtrap
می روید و ایمل را تایید می کنید  به شما اجازه  ورود می دهد 



---------------------------------------------------session 62  (84)
password Confirmatiom

گاهی کاربر لاگین است اما می خواهد وارد صفحه مهمی در پنل کاربری خود شود و کار مهم انجام دهد--
که باید مطمئن باشیم کاربر   خودش است و کسی به جای ان وارد نشده 
در این صورت می توانید تایید رمز عبور را برای صفحات خاصی انجام دهید 
یعنی اگر کاربر خواست به صفحه مثلا   تغییر نامش برود باید ابتدا  رمز عبور خود را تایید کند تا 
بتواند وارد آن صفحه از پنل کاربریش بشود 

مثلا بخشی داریم که شماره کارتی را می گیریم و مبلغی را واریز می کنیم  و این موضوع قطعا نیاز دارد تا کاربر خودش 
را با دوباره زدن رمز عبور تایید کند 

در 
php artisan route:list
روت های مربوط به این موضع وجود دارد

password/confirm   -> get    --> نمایش ویو
password/confirm   -> post   ---> ارسال اطلاعات 


ابتدا یک روت جدید می سازیم 


اضافه کردن 
->middleware("auth")
به هر روتی یعنی این که  تاز مانی که کاربر لاگین نکرده نمی تواند به آن دسترسی داشته باشد



اضافه کردن 
->middleware("password.confirm")
می گوید که کاربر برای ورود به این روت ابتدا باید رمز خود را در 
باکس
confirmation  password
وارد کند و اگر رمزش درست بود می تواند وارد صفحه مورد نظر شود 

// password confirm

Route::get('/set/secur',function(){
	return 'Pass Confirm';
})->middleware(["auth","password.confirm"]); // two important middleware



این پسود کلنفیرم  به مدت 
3 
اوکی است اما بعد ازان دوباره کاربر باید 
رمز عبور را برای رفتن  به صفحه خاصی که  پسورد  کانفیرم را روی آن قرار داده ایم بزند 

البته این زمان را می توانیم تغییر دهیم 

config / auth.php

بخش 
password_timeout => 10800
که این عدد میشود 
3 
ساعت و می توانیم آن را تغییر دهیم 


---------------------------------------------------session 63 (85)

auth views

in app.blade.php

دایرکتیو
@guest
را داریم
که این دایرکتیو بررسی می کند کاربر میهمان است  یا نه  لاگین است 
اگر مهمان بود  لینگ های مربوط به ثبت نام و  لاگین را بهش نشان می دهد امااگر
لاگین کرده بود لینگ پنل کاربری را بهش نشان می دهد--

@auth

کدهای بین این دایرکتریو زمانی به کاربر نشان داده می شود که  لاگین باشد

@endauth


@guest

کدهای بین این  دایرکتیو زمانی به کاربر نمایش می دهد که میهمان باشد و هنوز لاگین نکرده است

@endguest



@guest  and @auth
شرطی هستند به همین دلیل بین آن ها از 
@else
	هم می توانید استفاده کنید 

توجه داشته باشید که به صفحات مربوط به 
Auth
هر استایل و 
ui
که خواستید می توانید اضافه کنید اما باید مواردی که خودش قرار داده ببرای کدهای 
php
مثل 
name
اینپوت ها را تغییر ندهید 




این نکته خیلی مهم است   خواستان باشد که  
name
اینپوت ها را تغییر ندهید که به ارور می خورید 




 @if (Route::has('login'))
	 #code
  @endif
این دستور بررسی می کند که ایا روت لاگین وجود دارد یا نه 

برای هر روتی که می خواهیم بررسی کنیم وجود دارد یا نه می توانی از این شرط استفاده کنیم





{{ Auth::user()->name }}
با این روش می توانیم به اطلاعات کاربری که لاگین کرده دسترسی پیدا کنیم 




{{ config('app.name', 'Laravel') }}
app()->getLocale()
با این دو روش  می توانیم به اطلاعات  فایل های پوشه 
config
دسترسی پیدا کنید 




 <!-- CSRF Token -->
  <meta name="csrf-token" content="{{ csrf_token() }}">
  روش گرفتن  توکن ایجاد شده 


---------------------------------------------------session 64 (86)
Auth middleware


auth  --> چک می کند کاربر لاگین شده است یا نه اگر نشده  او را ریدارکت میکند به صفحه لاگین

3
روش برای اضافه کردن  میدل ویر وجود دارد 
1. اضافه کردن به روت ها
2.  قرار دادن آن در  متود  
	__construct
	کنترلر
3. اعمال آن روت  گروپ


verified   --> بررسی می کند که کاربر آیا ایمیل را با رفتن به ان و کلیلک کردن روی لینگ تایید ، تایید کرده است یا نه 
				اگر تایید کرده باشد به آن روت دسترسی دارد
				


password.confirm  --->  برای این است که کاربر باید ابتدا برای ورود به این روت  رمز عبور خود را تایید کند و بعد می تواند وارد شود

guest    --->  یعنی این روت را کاربرهای  میهمان هم می توانند مشاهده کنند که دقیقا برعکس 
				auth
است 


auth.basic    -->  برای  احراز هویت سریع کاربر است 
					این مورد دیگر ما را به صفحه لاگین ری دایرکت نمی کند و همان جا 
					سریع یک 
					pop-up
					باز می کند و اطلاعات شما یوزر نیم و  پسورد را از ما دریافت می کند 

Route::get('/auth-basic',function(){
	return 'auth-basic page';
})->middleware("auth.basic");




همه این میدل ویر ها می توانید  در 
app /http /kernel.php  => protected $routeMiddleware

مشاهده کنید 


---------------------------------------------------session 65 (87)

Auth Methods


ابتدا
use Illuminate\Support\Facades\Auth;


Auth::user()   or  auth()->user();
Facades                helper

اطلاعات کاربری که لاگین کرده است را برمی گردانند 

Auth::user()->id     or   Auth::id()
auth()->user()->id     or   auth()->id()


Auth::check()       or   auth()->check()
بررسی می کند که ایا کاربر لاگین است یا نه

auth()->logout();
کاربر را  لاگ  اوت می کند 




$user = User::find(2);
auth()->login($user);


auth()->loginUsingId(5);

از این دو مورد برای  لاگین کردن کاربر استفاده می کنیم 


---------------------------------------------------session 66 (88,89)

Autorization      کنترل سطح دسترسی کاربر 


می خواهیم کاری کنیم که هر کاربر بتواند پست مربوط به خودش را ببیند و ویرایش کند


Gate  
زمانی که کاربر می خواهد کاری انجام دهد  آن را از یک دربازه یا   گیت عبور می دهیم 
و در این  گیت بررسی می کنیم  که شرایط و سطح دسترسی برای این کار را دارد یا نه


in  Auth serviceProvider   --> boot method

use Illuminate\Support\Facades\Gate;

/* Gate::define("gate name" , Clouser for check condition); */

Gate::define("update-post" , function($user , $post ,$param1){
	
	// this place you can check your logic
			
	if($post->user_id === $user->id){  
		return true;
	}else{
		return false;
	}
		
	
	
});




in controller

use Illuminate\Support\Facades\Gate;


$user = auth()->user();
		
		
$post = Post::find(1);


/* if($post->user_id === $user->id){
	
					# code  old method
					
} */


$allow = Gate::allows("update-post" , [$post ,12]);

dd($allow);

با این روش می توانیم تعیین کنیم کاربری که لاگین است به چه  
post
هایی دسترسی داشته باشد


اگر کاربری لاگین نباشد 
false
برمی گرداند



in controller


$user =User::find(1);
		
		
$post = Post::find(1);


روش اول 

$allow = Gate::forUser(User::find(1))->allows("update-post" , [$post ,12]);

این روش اگر  در گیت شرط برقرار بود 
true
برمی گیرداند

		
روش دوم 

$allow = $user->can("update-post" , $post);

این روش اگر  در گیت شرط برقرار بود 
true
برمی گیرداند

روش سوم
		
$allow = $this->authorize("update-post" , $post);

این روش اگر  در گیت شرط برقرار بود 
هیچ کاری انجام نمی دهد ولی اگر 
false
برود شما را  منتقل می کند به  صفحه 
403

این مورد بیشتر برای کاربری های لاگین شده کاربر دارد و نه کاربری خاص
یعنی مربوط به جلسه قبل است


حالا در کنترل می توانیم بررسی کنیم که اگر 
false
برگشت داده شد کاربر را 
abort
کنیم به صفحه 
403
یا هر صفحه دیگری که مدنظرمان است




---------------------------------------------------session 67 (90)

در روش قبل ما بررسی کردیم که کاربری که لاگین است به چه پست هایی دسترسی داشته باشد
اما حالا می خواهیم مشخص کنیم که کاربر با ایدی  خاص  به چه پست هایی دسترسی داشته باشد




اما 
admin
به همچی دسترسی دارد پس در جدول کاربران یک ستون با  هر نامی که خواستی اصافه می کنیم 
که معمولا 
type  or  access
می گذارند
سپس در هنگام ایجاد ستود دیفالت را 
user
یا هر سطحی که می خواهیم کمترین دسترسی را داشته باشد قرار می دهیم تا در هنگام ثبت نام به طور پیشفرض
پایین ترین سطح دسترسی را داشته باشد
وبعدا اگر خودمان خواستیم آن را تغییر می دهیم 




in gate 

if($user->type === "admin"){
	return true;
}


با این روش ادمین به همه پست ها دسترسی دارد اما اگر تعداد مواردی که مدیر باید دسترسی کامل 
به آن ها داشته باشد زیاد  باشد باید دائما این کد را تکرار کنیم که برای جلوگیری از  این کار از 
روش جلسه بعد استفاده می کنیم


---------------------------------------------------session 68 (91)

gate   before     and aftet


Gate::denise   
برعکس
Gate::allows
است و  هر جوابی که از  گیت می آید را  برعکس می کند



Gate::before();
یک قابلیت خوب  گیت است و   قبل از  اجرای   هر  گیتی ابتدا این مورد صدا زده می شود

/* Gate::before(function($user, name gate , $params){}); */

		Gate::before(function($user, $ability , $params){
			/* dd(func_get_args()); */
			if($user->type === "admin"){
				return true;
			}
			
		});

این مورد برای  بررسی و دسترسی دهی کامل به ادمین است ما یکبار آن را تعریف می کنیم و قبل از  
اجرا شدنی هرررررر  گیتی این مورد اجرا می شود و دیگر نیاز نیست ما داخل هر گیتی این دستور را فراخوانی کنیم


/* Gate::after(function($user, $ability ,$result of Gate::define, $params){ */
		
		Gate::after(function($user, $ability ,$result, $params){
			/* dd(func_get_args()); */
		});

این هم بعد از اجرای خود  گیت  اجرا می شود  یعنی 
ابتدا  
before
اجرا می شود 
وبعد   
define
و بعد هم 
after

Gate::before(function($user, $ability , $params){
			/* dd(func_get_args()); */
			if($user->type === "admin"){
				return true;
			}
			
		});
		
		
		
		Gate::define("update-post" , function($user , $post){
			
			
			
			if($post->user_id === $user->id){
				return true;
			}else{
				return false;
			}
				
			
			
		});
		
		
		/* Gate::after(function($user, $ability ,$result of Gate::define, $params){ */
		
		Gate::after(function($user, $ability ,$result, $params){
			/* dd(func_get_args()); */
		});




---------------------------------------------------session 69 (92)

Policies  پالیسی ها

مجموعه یا کالکسی از  گیت ها است

ممکن است ما کلی گیت داشته باشیم و این درست نیست که همه آن ها را داخل متود  
boot
در فایل 
appServiceProvider
قرار دهیم 

در نتیجه ما یک پالیسی ایجاد می کنیم و هر گیتی مربوط به  مثلا  پست ها است را داخل آن قرار می دهیم

ساخت پالیسی

in cmd   ==>  php artisan make:policy --help
				php artisan make:policy PostPolicy
			
			
بعد از اجرای این دستور یک پوشه با نام
Policy
در پوشه 
app
ایجاد می شود و فایل پالیسی در درون آن قرار می گیرد


اما می توانیم کاری که کنیم که  پالیسی که ایجاد می کنیم با مدل مدنظمان 
match
شود که برای ان کار به روش زیر عمل می کنیم


php artisan make:policy PostPolicy --model=Post	



حالا در فایل ایجاد شده خودش متودهایی که ممکن است به آن ها نیاز داشته باشیم را  گذاشته است و نیازی نیست ما آن ها را بنویسیم


حالا باید به  سیستم بفهمانیم که ما این پالیسی را دازیم که برای این کار از روش زیر استفاده می کنیم 

in appServiceProvider --> protected $policies
 

Post::class => PostPolicy::class;
//   Post::class    ===  App\Models\Post
//   policy name::class    ===  'App\Models\Model' => 'App\Policies\ModelPolicy',
//   PostPolicy::class    ===  'App\Models\Model' => 'App\Policies\PostPolicy',

حالا داخل پالیسی می توانیم  دستوراتی که می خواهیم را قرار دهیم 

if($user->type === "admin"){
	return true;
}

این دستور به صورت خلاصه می شود به شکل زیر

return $user->type === "admin";
که برای حرفه ای تر بودن کار می توانیم آن را به جای  کد قبلی در  فایل پالیسی در بخشی که می خواهیم قرار دهیم 


برای مثال این  گیت که در فایل پالیسی قرار دادیم  می گوید که 


public function update(User $user, Post $post)
{
	return $post->user_id === $user->id ;
		
}

هر کاربر تنها می تواند پست مربوط به خودش را  اپدیت کند
به عبارت دیگر اگر پست مربوط به  یوزر باشد   
true
برگشت داده میشود



حالا تنها کافی است متودی که از گیت می خواهیم را فراخوانی کنیم 

$allow =  Gate::allows("update" , $post);
dd($allow);


توجه داشته باشید که در فایل پالیسی ایجاد شده  تمام متودها به عنوان پارامتر دوم  پارامتری را دریافت می کنند 
و براساس ان تشخیص می دهند که کدام مدل و کدام پالیسی مدنظر است اما متود 
create
چیزی به عنوان پارامتر دوم دریافت نمی کند و ما باید در هنگام فراخوانی این گیت به نوعی به ان بفهمانیم که چی مدنظرمان است و کدام مدل را لازم داریم که دراین
صورت در هنگام فراخوانی به  روش زیر عمل می کنیم

$allow =  Gate::allows("create" , Post::class);

به عنوان پارامتر دوم  خود کلاس مدل مورد نظر را  ارسال می کنیم


---------------------------------------------------session 70 (93)

روش های دیگر استفاده از 
policies



روش اول

$allow =  Gate::allows("update" , $post);

$allow =  Gate::allows("create" , Post::class);

روش  دوم

$allow = $user->can("update" , $post);
$allow = $user->can("create" , Post::class);

روش  سوم

$this->authorize("update" , $post);
$this->authorize("create" , Post::class);

روش  چهارم

کمک گیری از  میدل ویر در روت ها 

Route::put('/post/{post}' ,function(Post $post){
	
})->middleware('can:update,post');


Route::post('/post' ,function(){
	
})->middleware('can:create,App\Models\Post');



روش  پنجم

استفاده در  فایل های   ویو   بلید

@can('update' , $post)

{{-- Can Update Code  --}}  // دسترسی برای اپدیت دارد

@else
	
{{-- Can not Update Code  --}} /// دسترسی برای اپدیت ندارد 

@endcan




@can('create' , App\Models\Post::class)

{{-- Can Update Code  --}}  // دسترسی برای اپدیت دارد

@else
	
{{-- Can not Update Code  --}} /// دسترسی برای اپدیت ندارد 

@endcan




@can('create' , App\Models\Post::class)

{{-- Can Update Code  --}}  // دسترسی برای اپدیت دارد

@elsecan('update' , $post)
	
{{-- Can not Update Code  --}} /// دسترسی برای اپدیت ندارد 

@endcan




---------------------------------------------------session 71 (94)

localization

چند زبانه کردن  وبسایت در  لاراول



resource folder  / lang


en ->

ابتدا یک فایل ایجاد می کنیم در این پوشه 
برای مثال 
message.php

return [

    /* 'key' => 'value for show' */
	'welcome' => "Welcome to laravel and Vue 3"

];

حالا  کی و  ولیو هایی که مدنظرمان است را در آن قرار می دهیم 

حالا برای زبان های دیگر پوشه های دیگر  با نام  های مختصر مثل
fa
می سازیم و  همین فایل را  عیننا در آن قرار می دهیم اما این بار  
value
را به زبانی که مدنظرمان است قرار می دهیم 
مثلا
fa

return [

    /* 'key' => 'value for show' */
	'welcome' => "خوش آمدی به لاراول"

];


حالا برای اینه بفهمانیم این فایل خوانده شود باید 
به
config / app.php 

برویم و 
'locale'
را مساوی اسم پوشه مورد نظر قرار دهیم 

'locale' => 'fa',


البته ممکن است ما در بلید  کلیدی را فراخوانی کرده باشیم که در فایل ها ترجمه شده نباشیم که در این صورت براساس
'fallback_locale' => 'en',

که مقدار دیفالت را تعیین می کند  مقدار از پوشه انگلیسی برگشت داده میشود

حالا ممکن است که در فایل های پوشه 
en
هم کلید مدنظر ما نباشد که در این صورت خود متن درخواست یعنی 
مثلا
message.welcome
را می فرستند در خروجی و ارور نمی دهد

برای استفاده در قالب بلید هم از   هلپر فانکشن  ترنسلیت که به شکل
__
است استفاده می کنیم

{{  __('message.welcome')  }}

message  --> file name  .   welcome  --> key




---------------------------------------------------session 72 (95, 96)
روش دوم برای خواندن مطالب از فایل های ترجمه شده در قالب بلید

روش اول 
{{  __('message.welcome')  }}

روش دوم 


می توانیم به جای دادن اسم فایل و 
key
خود استرینگ مورد نظر را پاس دهیم

{{  __('Welcome to laravel and Vue 3')  }}

لاراول می آید بررسی میکند و می بیند که این اسم یک فایل نیست  پس می رود به کانفیگ می بیند که ما 
مثلا

'locale' => 'en',

است پس می اید داخل پوشه 
lang
و دنبال فایل با نام 
en.json
می گردد

حالا برای این روش می توانیم ما یک فایل  جیسون ایجاد کنیم و چیزی های که می خواهیم ترجمه کند را داخل آن قرار دهیم 

{

	"Welcome to laravel and Vue 3" : "locate with JSON"

}

حتما دابل کوتیشن باید باشد در  جیسون


اگر فایل جیسون یا چیزی که مورد نظر ما  است را پیدا نکرد همان متن را برمی گرداند و ارور نمی دهد
یعنی این را برای می گرداند مثلا
Welcome to laravel and Vue 3


حالا چگونه به کاربر اجازه بدهیم که زبان را تغییر دهد--

in controller

use Illuminate\Support\Facades\App;

App::setLocale('fa');
این می رود  داخل فایل کانفیگ این مورد را جایگزین می کند 


حالا می توانیم لینکی را پیاده سازی کنیم که با کلیک روی آن یک پارامتر به کنترل ارسال کنید و با دریافت آن زبان سایت را تغییر دهیم 




dd(App::isLocale('en'));  // بررسی میکند که ایا زبا سایت انگلیسی است یا نه 
						// یا تنظیمات داخل  کانفیگ روی انگلیسی است یا نه و جواب را به صورت
						//  بولین  برمی گرداند
						
						




ارسال پارامتر به به متود ترجمه

در روش اول

{{  __('message.welcome' , ['name' => "sended param"])  }}


return [

    /* 'key' => 'value for show' */
	'welcome' => "خوش آمدی به لاراول  --> :name"

];

در روش دوم 

{{  __('Welcome to laravel and Vue' , ['name' => "sended param json","age"=>26])  }}

en.json					
{

	"Welcome to laravel and Vue" : "locate with JSON en --> :name -- :age"

}
fa.json

{

	"Welcome to laravel and Vue" : "ترجمه با جیسون فارسی  --> :name -- :age "

}


قابلیت جمع و مفرد

{{  trans_choice('message.apples' , 3) }}

return [

    /* 'key' => 'value for show' */
	'welcome' => "Welcome to laravel and Vue 3  --> :name ",
	'apples' => "{1}one apple|{3}three apples"

];
حالا اگر پارامتر اول  یک بود  اولی را می خواند اما اگر  سه بود   دومی را می خواند و برمیگرداند 


حتی می توانید یک بازه به آن اختصاص دهیم 

return [

    /* 'key' => 'value for show' */
	'welcome' => "Welcome to laravel and Vue 3  --> :name ",
	'apples' => "{1}one apple|{3}three apples|[10,20] many apples|[20,*] more than 20 apples"

];


حتی می توانیم به راحتی  
uppercase
کنیم  با  بزرگ نوشتن اسم پارامتر

return [

    /* 'key' => 'value for show' */
	'welcome' => "خوش آمدی به لاراول  --> :NAME",

];

//    output --->  خوش آمدی به لاراول  SENDED PARAM




---------------------------------------------------session 73 (97,98)

pagination        صفحه بندی


in laravel doc --> database


این متود تمام پست های ما را برمی گرداند

$posts = Post::all();
dd($posts);



// laravel 8

ابتدا در 
appServiceProvider

use Illuminate\Pagination\Paginator;

in boot method   ==>    Paginator::useBootstrap();




in controller



$posts = Post::paginate(10);
		
return view('pagination', compact('posts'));


می توانیم شرط هم بگذاریم 

$posts = Post::where('id',">",15)->paginate(10);
return view('pagination', compact('posts'));

این کار را روی  
query bilder
هم می توانیم انجام دهیم 

$posts = DB::table('posts')->where('id',">",15)->paginate(10);




ایجاد دکمه های 
pagination 
در ویوها

{{ $posts->links() }}




البته یک متود دیگرهم داریم که  فقط  کلید های صفحه قبل و بعد را می آورد و دیگر شماره صفحات را نمایش نمی دهد که می توانیم
در کنترلر به جای 
paginate
از
simplePaginate
استفاده کینم


اگر تعداد صفحات زیاد بود لاراول تعدادی را بعد از صفحه جاری نمایش می دهد و بقیه را به صورت 
...
نمایش می دهد که می توانید تعدادی که بعد و قبل از صفحه جاری تا  رسیدن به سه نقطه
نمایش داده می شود را  هندل کنیم به این شکل که در 
ویو ها به شکل زیر عمل می کنیم

{{ $posts->onEachSide(2)->links() }}



---------------------------------------------------session 74 (99)

سفارشی سازی 
pagination

فایل های مربوط به استایل ها در  مسیر زیر قرار دارد 

vendor / laravel / framework  /src/ Illuminate/Pagination/resources /views

داخل این پوشه یک سری فایل  بلید قرار دارد که 
 ui
صفحه بندی را با فریم وروک های مختلف تنظیم می کنند

برای استفاده از آن ها  به هیچ وجه نباید در پوشه  
vendor
تغییر ایجاد کنیم  و  تنها دو راه داریم یا آن ها را کپی کنیم و در پوشه  ویوها خود انها را 
paste
دهیم و تغییرات روی آن ها اعمال کنیم یا از 
ارتیسان کمک بگیریم

php artisan vendor:publish  --tag=laravel-pagination

این دستور یک پوشه بلید در  ویوها می سازد و فایل های مربوط به 
ui
را در ان قرار می دهد که ما می توانیم آن ها را تغییر دهیم 


در حال حاضر لاراول به طور پیشفرص از فریم ورک بوت  استرپ و فایل بلید بوت استرپ برای استایل دهی به 
pagination
استفاده می کند که می توانیم آن را تغییر دهیم 


قبلا گفتیم که می توان چگونه گفت که از کدام استایل برای صفحه بندی از طریق  پروایدر استفاده شود 
اما استفاده از آن بوت استرپ را روی تمام صفحه بندی ها سایت اعمال می کند و ما شاید خواستیم یکی از 
صفحه بندی ها با یک فریم ورک دیگر باشد پس بهتر است  به جای نوشتن 

 Paginator::useBootstrap();
 
 در پروایدر ها  مسیر فایلی که می خواهیم 
 ui
 از آن خوانده شود به به شکل زیر به  لاراول بدهیم 
 
 
 {{ $posts->links('vendor.pagination.bootstrap-4') }}
 

اما اگر تنها از یک فریم ورک استفاده می کنید می توانید کد را داخل 
provider

قرار دهد که خیلی کار را اسان تر می کند 
اگر بوت استرپ بود که 

 Paginator::useBootstrap();
 را قرار می دهیم اما اگر خواستیم فایل دیگر را انتهاب کنیم  به روش زیر عمل می کنیم
 
 Paginator::defaultView('blade address');
 
همین کار را می توانیم برای 
simple
ها انجام دهیم 

 Paginator::defaultSimpleView('blade address');

 
// بررسی فایل های  بلید  صفحه بندی

@if ($paginator->hasPages())
	بررسی می کند که ایا پست به اندازه کافی برای صفحه بندی داریم یا نه 
مثلا 
50
تا پست داریم و گفتیم که 
51
تا پست 
51
تا صفحه بندی بشه خود در این صورت هنوز به عدد کافی نرسیدیم پس نیازی نیست لینک ها صفحه بندی به ما نمایش داده شود 

@if ($paginator->onFirstPage())
میگه که ایا اولین صفحه است یا نه 

$paginator->previousPageUrl()
لینک موجود در فلش مربوط به صفحه قبلی 
<

{{ $paginator->nextPageUrl() }}
بعدی
>

$paginator->currentPage()

صفحه جاری 



---------------------------------------------------session 75 (100)

Append in Pagination

در حالت عادی اگر به جز  
page
کوئری استرینگ
دیگر داشته باشیم با تغییر صفحات اون  کوئری استرینگ هم حذف می شود که این موضوع مشکل ایجاد می کند

in blade 

add ->appends(["query string name " => request('query string value')])

{{ $posts->appends(["search" => request('search')])->onEachSide(2)->links('vendor.pagination.bootstrap-4') }}

 // http://127.0.0.1:8000/pagin?search=post&page=8

حالا می توانیم هر تعداد کوئری استرینگ که داشتم داخل ارایه قرار دهیم 
اما برای زمانی که تعداد کوئری استرینگ ها زیاد است یک راه ساده تر هم وجود دارد


استفاده از 

withQueryString()

{{ $posts->withQueryString()->onEachSide(2)->links() }}




-- fragment

گاهی کاربر پست را خوانده است و حالا می خواهد کامنت ها را بخواند و می خواهد برود صفحه بعد کامنت ها 
در حالت عادی با رفتن به صفحه بعد   از  ابتدای صفحه کاربر دوباره باید اسکرول کند تا به کامنت ها برسد اما لاراول این امکان را به ما 
می دهد تا با 
#
کاری کنیم که خودش با رفتن به صفحه بعد به کامنت ها برود

ابتدا به بخشی که می خواهیم با لود شده صفحه به ان جا برو یک ایدی می دهد 

id="post"

حالا 

{{ $posts->withQueryString()->fragment('post')->onEachSide(1)->links() }}



---------------------------------------------------session 76 (101)

Error Handling


in laravel doc   --> the basic


log
خود لاراول از کتابخانه  هونولاگ استفاده می کند و با آن  لاگ های ما را ذخیره می کند


in controller

use Illuminate\Support\Facades\Log;

Log::info('message ali');  // ذخیره یک پیام به عنوان لاگ 


محل ذخیره لاگ ها 

config / logging.php

اطلاعات مربوط به کنترل لاگ ها در این جا قرار دارد


'default' => env('LOG_CHANNEL', 'stack'),

از فایل 
.env
این را می خواند می گوید 
stack
باشد

stack  == > log channels


'channels' => [
        'stack' => [
            'driver' => 'stack',
            'channels' => ['single'],
            'ignore_exceptions' => false,
        ],

        'single' => [
            'driver' => 'single',
            'path' => storage_path('logs/laravel.log'),
            'level' => env('LOG_LEVEL', 'debug'),
        ],

        'daily' => [
            'driver' => 'daily',
            'path' => storage_path('logs/laravel.log'),
            'level' => env('LOG_LEVEL', 'debug'),
            'days' => 14,
        ],

        'slack' => [
            'driver' => 'slack',
            'url' => env('LOG_SLACK_WEBHOOK_URL'),
            'username' => 'Laravel Log',
            'emoji' => ':boom:',
            'level' => env('LOG_LEVEL', 'critical'),
        ],

        'papertrail' => [
            'driver' => 'monolog',
            'level' => env('LOG_LEVEL', 'debug'),
            'handler' => SyslogUdpHandler::class,
            'handler_with' => [
                'host' => env('PAPERTRAIL_URL'),
                'port' => env('PAPERTRAIL_PORT'),
            ],
        ],

        'stderr' => [
            'driver' => 'monolog',
            'level' => env('LOG_LEVEL', 'debug'),
            'handler' => StreamHandler::class,
            'formatter' => env('LOG_STDERR_FORMATTER'),
            'with' => [
                'stream' => 'php://stderr',
            ],
        ],

        'syslog' => [
            'driver' => 'syslog',
            'level' => env('LOG_LEVEL', 'debug'),
        ],

        'errorlog' => [
            'driver' => 'errorlog',
            'level' => env('LOG_LEVEL', 'debug'),
        ],

        'null' => [
            'driver' => 'monolog',
            'handler' => NullHandler::class,
        ],

        'emergency' => [
            'path' => storage_path('logs/laravel.log'),
        ],
    ],





single  ==> یعنی در یک فایل باشد 

daily ==>  روزانه با تاریخ برای ما لاگ می زند  و در فایل ها مختلف با تاریخ آن قرار می دهد 

'path' => storage_path('logs/laravel.log'),  // محل ذخیره لاگ ها 


storage_path  --> اشاره به پوشه  استورج

storage/ logs / laravel.log  == تمام لاگ های پروژه

چون تنها پوشه 
public
داخل
public html    host
قرار می گیرد  دیگران به این فایل ها ی لاگ دسترسی ندارند



حالا با اجرای صفحه این لاگ ذخیره می شود 
[2021-07-06 17:18:17] local.INFO: message ali 

ارسال پارامتر به لاگ 

Log::info('login user' , ['id' => 3]);

// [2021-07-06 17:22:20] local.INFO: login user {"id":3} 



---------------------------------------------------session 77 (102)

صفحه ارور لاراول

ignition page


این همان صفحه ارور خاص لاراول است که اطلاعات کاملی را درمورد ارور و فایل  و حتی خطی که 
در آن ارور بروز کرده است می دهد
ErrorException
Undefined variable: name
http://127.0.0.1:8000/error


D:\dw\wamp\www\laravel8\example-app\app\Http\Controllers\ErrorHandleController.php:16

در سمت راست صفحه لیسی از مسیرها وجود دارد که لاروال می گوید همه آن ها  را 
رد کرده است تا در شماره آخری به ارور خورده است

این ارور ها تا اندازه ای که ما می بینیم 
رایگان هستند اما بخش های پولی هم دارد که می توان آن ها را از سایت مورد نظر که لینگ آن در قسمت قرمز رنگ 
بالای صفحه قرار دارد می توان خرید 


همچنین لاراول تمام ارور ها را به طور کامل همراه همراه مسیرها  و خط بروز خطا و 
... 
لاگ می اندازد داخل 
storage/ logs / laravel.log 

زمانی که پروژه را می خواهیم اپلود کنیم باید در فایل
.env

APP_DEBUG=true

را 
false
کنیم تا 
ignition page
دیگر دیده نشود و در هنگام خطا کاربر ارسال شود به  صفحه  
500

500
SERVER ERROR

اما لاگ هایی که لارول ذخیره کرده است برای دیباگ کرده  در هنگام بروز خطا بسیار کاربردی هستند 

حتما حتما در هنگام اپلود پروژه روی هاست 
APP_DEBUG
را
false
کنید 

---------------------------------------------------session 78 (103)

Exception

یک خطا یا مشکل است که در سیستم ما رخ می دهد و باعث می شود روال عادی برنامه ما به هم بریزد

لاراول یک سیستم کامل 
error handling
دارد 


in app / Exceptions  /Handler.php

report  method   ---> گزارش خطا
render  method   ---->  رندر خطا

protected $dontReport --> داخل این مورد می توانیم 
						Exceptions 
						هایی که می خواهیم  گزارش نشوند را بنویسیم
						مثلا  
						404
						جز مواردی است که زیاد بروز می کند و لاراول آن را لاگ نمی اندازد
						
						
protected $dontFlash    --> مواردی که در این قسمت مشخص کنیم در یک فلش سشن ذخیره نمی شوند تا بعدا اگر نیاز بود مثلا
							old
							بگذاریم و آن را بگردانیم مانند سایر  اینپوت ها 
							این موارد حتی با  متود  
							old
							بازهم در دسترس نخواهند بود



---------------------------------------------------session 79 (104)
Exception   سفارشی



in cmd  ==>  php artisan make:exception  --help

php artisan make:exception  name

php artisan make:exception  MyException


الان  یک فایل با این نام باید در در این مسیر ایجاد شود

in app / Exceptions  /MyException.php



برای استفاده از این 
Exception
هم کافی است در داخل   کنترلر

use App\Exceptions\MyException;

throw new MyException('message Error ali');

الان با اجرای صفحه وارد 
ignition page
می شویم و متنی که گفتیم به ما نمایش داده می شود 

حالا میتوانیم ارور را در لاگ ها هم مشاهده کنیم


تغییر  ریپورت و  رندر  به صورت سفارشی

in Handler.php   ===> register


if($e instanceof MyException){  // می گوید که اگر  اکسپشن از نوع  اکسپشن
								// MyException
								// اتفاق بیوفتد
	#codes
	dd('my error ... XXX');
}



if($e instanceof MyException){  
								
	#codes   ==> اینجا می توانیم هر کاری خواستیم انجام دهیم  برای مثال ما یک لاگ ثبت می کنیم 
	
	return Log::info('My custom Report Error');
	
	/* dd('my error ... XXX'); */
}


همچنین می توانیم کاری کنیم که  اکسپشن ما  ریپورت نشود 
برای  این کار  کلاس را به 
protected $dontReport

اضافه می کنیم

یعنی کاری کنیم که  با بروز این ارور لاگ برای ما  نیاندازد 
در کل  منظور از ریپوت هما  لاگ انداختن است


protected $dontReport = [
	MyException::class
];


البته در مورد  
Exception
های سفارشی برای تغییر  ریپویت و رندر کار اسان تری هم می توانیم انجام دهیم  و آن این است که داخل خود فایل  
Exception
به روش زیر عمل کنیم 

<?php

namespace App\Exceptions;

use Exception;

use Illuminate\Support\Facades\Log;

class MyException extends Exception
{
    public function report()
    {
        return Log::info('My custom Report Error');
    }
	
	public function render($request)
    {
        
		return Log::info('My custom Report Error');
    }
}

حالا می توانیم در رندر  هم 
return
کنیم یک  ویو را 

return response()->view('error');   --> یک ویو را ریترن می کند  یا به عبارت دیگر ما را به این ویو هدایت می کند



سعی کنید که 
Exception
سفارشی داشته باشید و ریپوت و رندر  را داخل آن قرار دهیم تا  فایل 
Handler
شلوغ شود


/****** Error  ***/

composer/package-versions-deprecated: Generating version class...
composer/package-versions-deprecated: ...done generating version class
> Illuminate\Foundation\ComposerScripts::postAutoloadDump
> @php artisan package:discover --ansi

Script @php artisan package:discover --ansi handling the post-autoload-dump even
t returned with error code 255

این ارور مربوط به زمانی است که مشکلی یا خطایی  سکنتکسی در  فایل 
Handler.php
به وجود آمده است. 
در این فایل حتما باید  از 
Throwable
از لاراوال 
7 
به بعد استفاده شود


اگر مشکلی در  این فایل وجود نداشت  موارد زیر را بررسی کنید 

1.  مسکلی از قبیل بد نوشتن در فایل  
	env
	وجود نداشته باشد
2. bootstrap / cache   تمام فایل ها 
						php
						این مسیر را پاک کنید
3. composer dump 
4. composer install
5. composer update


/****** Error  ***/




---------------------------------------------------session 80 (105)

try    catch

برای زمانی است که می خواهیم به برنامه بگوییم   اگر  فلان خطایی بروز کرد  برنامه را متوقف نکن و کدهایی که 
ما می گوییم را اجرا کن

کدهایی که احتمال می دهیم به خطا بخورند را داخل 
try
قرار می دهیم 
حالا اگر خطایی رخ داد و اکسپشن ایجاد شد   کدهای داخل
catch
صدا زده می شوند 

محدویتی در داشتن تعداد 
catch
نداریم 

try{
	
}catch(MyException $e){
	
}catch(MyException2 $e){
		
}catch(MyException3 $e){
		
}


try{
	throw new MyException('message Error ali');
	
}catch(MyException $e){
	
	/* dd($e->getMessage()); */
	dd($e);
	
}


dd($e->getMessage());  پیام خطا را نمایش می دهد 



داخل 
catch
می توانیم از متود   
report
هم استفاده کنیم


زمانی که ما از 
try   catch
استفاده می کنیم   یعنی داریم خودمان  خطا  را مدیریت می کنیم پی لاراول  لاگی را ذخیره نمی کند  مگر آنکه خودمان از 
هلپر فانکشن 
report
در داخل 
catch
استفاده کنیم 

try{
	throw new MyException('message Error ali');
	
}catch(MyException $e){
	
	/* dd($e->getMessage()); */
	
	report($e);
	
	
	dd($e);
	
}

پاس دادن 
$ex
هر متغییر دیگری که برای خطا ها در 
catch
معرفی کرده اید به 
report
برای نشخیص نوع  
Exception
الزامی است


---------------------------------------------------session 81 (106)

HTTP  Exception  


HTTP  Exception  ==>   خطاهای مربوط به 
						http
						مثل
						404

404  ==> not Found Page
403  ==> No Access
500  ==> Server Error

این اعداد 
Status Code
هستند 

اونایی که با 
100
 شروع می شوند بیشتر مربوط به 
information 
هستند
e.g.   103  104

اونایی که با 
200
 شروع می شوند بیشتر مربوط به 
Successfully 
هستند
e.g.  202  203
202 --> create



اونایی که با 
300
 شروع می شوند بیشتر مربوط به 
Direction 
هستند
e.g.  302  304



اونایی که با 
400
 شروع می شوند بیشتر مربوط به 
Client Error 
هستند
e.g.  403  404



اونایی که با 
500
 شروع می شوند بیشتر مربوط به 
server Error 
هستند
e.g.  500  505


برای استفاده از 
http Exception
ها از یک هلپر فانکشن استفاده می کنیم 

abort();


abort(404);
abort(403);
abort(500);
abort(505);



سفارشی سازی صفحات ارور 

in view folder

create  errors

حتما اسم پوشه باید 
errors
باشد

حالا داخل این پوشه فایل های بلید خود را قرار می دهیم و حتما اسم آن ها  همان اروری که هستند می گذاریم
404.blade.php
500.blade.php


در ضمن لاراول صفحه دیفالتی برای ارورهای کمتر کاربردی ندارد و   مثالا اگر 
408
را درخواست کنید صفحه ارور را نمایش می دهد 

صفحاتی که در حالت عادی مثلا برای 
404
500
403
و ارور های دیگر نشان می دهد  صفحات دیفالت هستند اما شما می توانید برای  هر اروری که خواستید فایل بلید بسیازید 
لاراول بررسی می کند که اگر در  ویوها  پوشه ارور و فایل 
408
داشتید برای نمایش ارور به کاربر از آن استفاده می کند 




---------------------------------------------------session 82 (107)

Mail in laravel


Email  ==> روشی برای تبادل پیام های  دیجیتال 
Mail  ===> وظیفه انتقال این ایمیل را بر عهده دارد


laravel doc   ==> digging deeper

لاراول برای انتقال ایمبل از کتابخانه 
sweef mailer 
استفاده می کند

تنظیمات 
mail 
در لاراول


in .env



MAIL_MAILER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=832e217a438aca
MAIL_PASSWORD=13d801be387504
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS=info@stwebprog.ir
MAIL_FROM_NAME="${APP_NAME}"




1. MAIL_MAILER=smtp
برای دیدن محل ست شدن این مورد 

config / mail.php 

smtp ==> single mail transfer protocol
پروتکلی برای ارسال ایمیل با روند کاری دریافت ایمیل از فرستند و ارسال آن به گیرنده



ses / mailgun /  postmark /  sendmail
این موارد که در کنار 
smtp
هستند  سرورهای دیگر برای ارسال ایمیلند که پولی هستند و در صورت نیاز باید آن ها را خریداری کنید 

smtp
 از سرویس ایمیل خود هاست استفاده می کند اما این موارد  از سرویس های قویتری استفاده می کنند 

in config / mail.php 

log 
سرویس ایمیل نیست و تنها برای ما لاگ می اندازد 



2.  MAIL_HOST=smtp.mailtrap.io

smtp.mailtrap.io
برای حالت 
development
و تست است و نمی توان از آن در خالت 
production
استفاده کرد 

زمانی که روس هاست اپلود کردید باید 
mail 
هاست را وارد  کنید 
مثلا 
info@zxcvAli.com

3. MAIL_PORT=2525    پورت هاست 


4. MAIL_USERNAME=832e217a438aca  
5. MAIL_PASSWORD=13d801be387504


6. MAIL_FROM_ADDRESS=info@stwebprog.ir  ادرس هاست   (  به عنوان فرستند ه به کاربر نمایش می دهد این را )
7. MAIL_FROM_NAME="${APP_NAME}"   اسمی که می خواهیم برای اینیل باشد  مثالا اسم سایت معمولا می گذارند 



in config / mail.php 

'from' => [
	'address' => env('MAIL_FROM_ADDRESS', 'hello@example.com'),
	'name' => env('MAIL_FROM_NAME', 'Example'),
],


فرستنده و نامی که در 
.env
ست کردیم اینجا  به کار گرفته می شود 



---------------------------------------------------session 83 (108)

ایجاد کلاس 
mail 
و  ارسال ایمیل 


in cmd   ==>  php artisan  make:mail  --help
			 php artisan  make:mail  name
			 
			 
			 php artisan  make:mail  TestMail
			 

داخل 
app folder 
یک پوشه با نام 
Mail 
ایجاد می کند و کلاس را در آن قرار می دهد 

in file   ==> build()
ایمیل را می سازد و ارسال می کند 


حالا برای استفاده هر جا که خواستیم 
مثلا 
کنترلر

use Illuminate\Support\Facades\Mail;

use App\Mail\TestMail;


public function index(){
		
	Mail::send( new TestMail() );
}



حالا  یک ویو خیلی قشنگ درست می کند و آن را برای کاربر ارسال می کنیم 
برای این کار یک پوشه با نام 
emails
در ویو ها ایجاد می کنیم 

حالا داخل متود 
build()
اطلاعات لازم را وارد می کنیم 

public function build()
{
	
	/* dd('build'); */
	return $this->view('emails.test')   // body (View page)
				->subject('test email لاراول')  // subject
				->to('ali@gmail.com');  // گیرنده
}

البته این روش ارسال اطلاعات دستی است که به درد نمی خورد و در جلسه بعد در مورد ارسال اطلاعات صحبت می کنیم 


الان با اجرا روت مورد نظر باید ایمیل ارسال شود 



---------------------------------------------------session 84 (109)

view Data

ارسال پارامتر 

->view   ==> ارسال به صورت   html
->text   ==> ارسال به صورت   text    و متن خام 



in controller

public function index(){
		
	$user = User::find(2);
	
	Mail::send( new TestMail($user) );
	
}


in mail file  (e.g.  TestMail.php)

	public $user;

  
    public function __construct(User  $user)
    {
       $this->user = $user;
    }

   
    public function build()
    {
		
        return $this->view('emails.test')
					->subject('test email لاراول')
					->to($this->user->email , $this->user->name);
    }


->to($this->user->email , $this->user->name);  در پارامتر دوم می توانیم اسم را هم  پاس دهیم تا اسم کاربر هم 
												در کنار ایمیل نمایش داده شود 

/* 
test email لاراول

From:Laravel <info@stwebprog.ir>
To:tylor swif <tylor@gmail.com>
Show Headers 

*/

در ضمن زمانی که در متود 
constract
ما  مقداری را تعریف می کنیم  لاراول امکان استفاده از آن در 
view
هم به ما می دهد و ما تنها باید در فایل ویو آـن را فراخوانی کنییم

in blade 

<mark> {{ $user->name }} </mark>



حالا می توانیم هم ارگومان دیگر هم که خواستیم به 
Mail::send( new TestMail($user) );
پاس دهیم و آن را در 
constract
دریافت کنیم 

in controller 

public function index(){
		
	$user = User::find(5);
	
	$user2 = User::find(3);
	
	Mail::send( new TestMail($user , $user2) );
	
}


in mail class file

public $user;
public $user2;


public function __construct(User  $user, User  $user2)
{
   $this->user = $user;
   $this->user2 = $user2;
}

public function build()
{
	
	return $this->view('emails.test')
				->subject('test email لاراول')
				->to($this->user->email , $this->user->name);
}


in view 

<mark> {{ $user->name }} </mark>
<mark> {{ $user2->name }} </mark>



حالا در حالت عادی اگر متود 
->replyTo
تعریف نکنیم  جوابی که  کاربر می دهد به همان ایمیلی که مال هاست است می رود 
یعنی همان ایمیلی که برای 
from
تعیین کرده ایم 
اما با تعریف این متود می توانیم تعریف کنیم که  جوابی که کاربر می دهد که به کدام ایمیل ارسال شود 
یعنی می توانیم گیرنده جواب را هرکسی که خواستیم قرار دهیم 

return $this->view('emails.test')
				->subject('test email لاراول')
				->replyTo('alixvc@gmail.com' , "name del khah")
				->to($this->user->email , $this->user->name);




---------------------------------------------------session 85 (110)
Attachment file to email


برای  اتچ فایل از متود 
->attach()
استفاده می کنیم 

همچنین فایلی که قرار است ارسال شود را باید در پوشه 
storage / app / public
قرار دهیم 



حالا لاروال یک هلپر فانکشن در اختیار ما قرار می دهد که مسیر را تا پوشه استورج به ما می دهد و ما خالا باید تنها نام فایل را به آن 
پاس
دهیم 

dd(storage_path());   "D:\dw\wamp\www\laravel8\example-app\storage"


public_path()  --> مسیر پوشه  پابلیک را برمی گرداند 



dd(storage_path("app/public/email-attach-file/FATCH2.txt")); 
==> "D:\dw\wamp\www\laravel8\example-app\storage\app/public/email-attach-file/FATCH2.txt"

می توانید از 
\
هم برای مسیردهی استفاده کنید اما 
/
اولویت دارد زیرا هاست ها اکثر لینوکسی هستند و برای آن ها 
/
مهم است و 
\
را به درستی نمی شناسند


هنچنین لینوکس برعکس ویندوز به حروف بزرگ و کوچک حساس است 

return $this->view('emails.test')
				->subject('test email لاراول')
				->attach(storage_path("app/public/email-attach-file/FATCH2.txt"))
					->to($this->user->email , $this->user->name);

همچنین لازم به ذکر است که محدودتی در ارسال فایل نداریم 

return $this->view('emails.test')
			->subject('test email لاراول')
			->attach(storage_path("app/public/email-attach-file/FATCH1.txt"))
			->attach(storage_path("app/public/email-attach-file/FATCH2.txt"))
			->attach(storage_path("app/public/email-attach-file/FATCH3.txt"))
			->to($this->user->email , $this->user->name);

حتی می توانیم اسم فایل ارسالی را هم تغییر دهیم 


return $this->view('emails.test')
			->subject('test email لاراول')
			->attach(storage_path("app/public/email-attach-file/FATCH1.txt") , 
			['as' => 'reza.txt'])
			->to($this->user->email , $this->user->name);


---------------------------------------------------session 86 (111)
preview Email

گاهی می خواهیم ایمیل را قبل از ارسال به کاربر مشاهده کنیم و اگر هنچی اوکی بود ایمیل را به کاربر ارسال کنیم که این 
قابلیت را هم لاراول به ما می دهد 


ابتدا یک روت از نوع 
get
تعریف می کنیم

use App\Models\User;
use App\Mail\TestMail;

Route::get('/test-mail', function(){
	
	$user = User::find(5);
	$user2 = User::find(3);
	return new TestMail($user,$user2);
	
});


حالا زمانی که به روت برویم  پیشنمایش به ما نمایش داده می شود


برای ارسال تصویر در ایمیل هم به روش زیر عمل می کنیم که یک  پوشه داخل پوشه 
public
می سازیم و عکس مورد نظر را در آن قرار می دهیم و بعد  در 
view

<img src="{{asset('img/v.jpg')}}" width="100" height="100">


---------------------------------------------------session 87 (112,113)

markdown in Email

آشنایی با  سینتکس

markdown  ==> یک سینتکس قالب دهی به متن است مانند 
				html
			 اما راخت تر نوشته می شود و در نهایت هم به 
			 html
			 تبدیل می شود
			 
برای کار کردن با 
markdown
می توانیم از ابزارهای انلاین استفاده کنیم که معروف ترین آن ها
stackEdit
هست

			  
**laravel**  ==> bold
*laravel*  ==> italic

#laravel  ==> h1
##laravel  ==> h2
###laravel*  ==> h3
####laravel*  ==> h4
#####laravel*  ==> h5
######laravel*  ==> h6

~  ==> tilda

~~laravel~~  ==> del (line on text)


// list
-laravel
-vue
-react


// check list
-[x]laravel  --> checked
-[]vue
-[]react


> laravel  ==> نقل قول

tab ==> code tag

![alt text description](http://googlelog.png)    img 



تا اینجا گفتیم که لاراول به ما امکان ارسال 
text and view
را به ایمیل می دهد و حالا می توانیم از 
markdown
هم برای ارسال ایمیل استفاده کنیم 


برای ارسال ایمیل به شکل مارک دون

in cmd  ==> php artisan make:mail --help
			
			php artisan make:mail name  --markdown address
			
			php artisan make:mail markdownMail  --markdown emails.markdownMail

تفاوت کلاس ایجاد شده  در 
app / mail
با کلاس قبلی این است که در فایل قبلی برای ارسال  باید از 
view  or  text
استفاده می کردیم اما در اینجا می توانیم از 
markdown
هم استفاده کنیم 


in build method 

public function build()
{
	return $this->markdown('emails.markdownMail')
				->to($this->user->email , $this->user->name);
	
}


in controller 

use App\Mail\markdownMail;


$user = User::find(5);
Mail::send( new TestMail($user) );

حالا به روت می رویم و باید ارسال شود 


زمانی که دستور ارتیسان را می زنیم خود لاراول یک فایل بلید  
example
هم برای ما ایجاد می کند که داخل آن کدهای زیر قرار دارد

@component('mail::message')
# Introduction

The body of your message.

@component('mail::button', ['url' => ''])
Button Text
@endcomponent

Thanks,<br>
{{ config('app.name') }}
@endcomponent


mail::button ===> این یعنی کامپوننت یک فساد است که از  
					vendor
					فراخوانی می شود


برای این که بتوانیم این استایل ها و دکمه ها را تغییر دهیم باید از ارتیسان استفاده کنیم

php artisan vendor:publish --tag=laravel-mail


این دستور فایل های بلید مربوط به ایمیل را کپی کرده و داخل پوشه وندور 
در کنار فایل های  
blade
ما قرار می دهد

resource / vendor / mail / html

حالا تمام استایل ها و ساختارها داخل این فایل ها است و برای تغییر آن ها می توانید از 
preview 
هم استفاده کنید 

use App\Mail\markdownMail;
Route::get('/test-mail', function(){
	
	$user = User::find(5);
	
	return new markdownMail($user);
	
});



---------------------------------------------------session 88 (114)

Notification in laravel


in laravel doc  -> digging deeper --> notification


این سیستم ما این امکان را می دهد که اعلان های مختلفی را روی کانال های مختلف به کاربران خود ارائه دهیم 

کانال های مختلف مانند 
email
sms
telegram
database

امکان استفاده از چند کانال با هم وجود دارد

لاراول برای ارسال ایمیل از یک کتابخانه اختصاصی استفاده می کند که ما در ایران نمی توانیم از آن  استفاده کنیم 


برای ایجاد بستر  نوتیفیکیشن از ارتیسان کمک می گیریم

php artisan make:notification --help

php artisan make:notification name


php artisan make:notification PostNotification


داخل مسیر زیر فایل ایجاد می شود
app / notification /PostNotification.php


public function via($notifiable)
{
	return ['mail'];
}

این متود می آید کانال ارسال را مشخص می کند

اگر کانال دیگری هم خواستیم به آرایه اضافه می کنیم


زمانی که 
mail 
قرار می دهیم حتما باید 

public function toMail($notifiable)
{
	return (new MailMessage)
				->line('The introduction to the notification.')
				->action('Notification Action', url('/'))
				->line('Thank you for using our application!');
}
باید باشد در متودها زیرا یک کلاس 
mail 
را برمی گرداند و به ما امکان می دهد که ایمیل ارسال کنیم 




public function toArray($notifiable)
{
	return [
		//
	];
}
این مورد برای ذخیره اطلاعات در دیتابیس است 


slack notification ==> یک سرویس خارجی است که نمی توانیم از آن استفاده کنیم 

 

---------------------------------------------------session 89 (115)

send notification



->line
متن ایمیلی است که ارسال می کنیم با نوتیفیکیشن

->action  

یک button ایجاد می کند و یک button در ایمیل ارسالی قرار می دهد


ارسال نوتیفیکیشن 

برای این کار ما دو راه داریم

1. استفاده از 
traid notifiable

معمولا ما ایمیل را به کاربران ارسال میکنیم پس به مدل User می رویم و در انجاد notifiable  را use می کنیم

In user model

use Illuminate\Notifications\Notifiable 

in user class 
use  Notifiable;

زمانی که از این ترید استفاده میکنیم یک متود به کلاس User اضافه می شود به اسم notify که می توانیم از ان استفاده کنیم

in controller

$user = User::find(2);

$user->notify(new PostNotification());

$user->notify(new name notify mored nazar);

حتما کلاس نوتیفیکیشن را 
Use
کنید

الان زمانی که روت را اجرا می کنید باید نوتیفیکیشن ارسال شود





2. استفاده از فساد 
Notification 

in controller
use Illuminate\Support\Facades \Notification;

Notification::send($user , new PostNotification() );

به جای یک یوزر می توانید به کالکشنی از یوزرها ارسال کنیم و تنها کافی است کاربرانی که می خواهیم را دریافت کنبم و به عنوان پارامتر اول به ابن فساد پاس دهیم.
$users = User::all();

Notification::send($users , new PostNotification() );


ارسال پارامتر

$post = Post::find(1);

Notification::send($user , new PostNotification($post) );

حالا این ورودی را می توانیم داخل کلاس PostNotification در بخش نوتیفیکیشن ها در متود construct  ان را دریافت کنیم
public $param;

__construct(Post $post){
	
	$this->param = $post;

}

حالا می توانیم در 
->
از ورودی استفاده کنیم

->line($this->param->title)



---------------------------------------------------session 90 (116)

MAIL Notification



برای اینکه بگوییم نوتیفیکیشن از طریق ایمیل ارسال شود باید داخل via و داخل ارایه mail قرار دهیم

public function via($notifiable){
      return ['mail'];
}

وقتی mail قرار میدهیم  خودش متوجه می شود و متود toMail اجرا می شود.

این متود به عنوان ورودی
 $notifiable 
را دریافت می کند که در اینجا همان اطلاعات user ما است.
حالا داخل بدنه toMail به تمام اطلاعات کاربرد مورد نظر دسترسی داریم.



در کنار 
->line
می توانیم تمام متودهای دیگر مانند from و ... را هم استفاده کنیم.



حالا برای اینکه بتوانیم شخصی سازی دلخواه را روی notification  ها اعمال کنیم باید مثل ایمیل انها را از vendor کپی و داخل view های خودمان از ان استفاده کنیم که برای این کار ما از 
ارتیسان کمک می گیریم



in cmd  ==>
php artisan vendor:publish  --tag=laravel-notifications



الان باید فایل های بلید مربوط به ساختار نوتیفیکیشن را در پوشه نوتیفیکیشن در داخل 
view
ها قرار داده باشد



نوتیفیکیشن در فایل بلید از همان کامپوننت های 
Mail
استفاده می کند




می توانیم برای ارسال ایمیل از 
view
ها هم استفاده کنیم. یعنی برای کاربر 
view
ارسال کنیم


in notification class in app/notifications

return (new MailMessage)->view('name');



---------------------------------------------------session 91 (117)
Markdown mail notification


in cmd  ==> php artisan make:notification --help
			php artisan make:notification name   --markdown address
			php artisan make:notification MarkdownNotification   --markdown emails.markdown-notification

الان باید داخل ادرسی که دادیم فایل ایجاد شده باشد 
همچنین داخل 
app / notification
هم باید فایل اضافه شده باشد 

هیچ تفاوتی میان  نوتیفیکیشن معمولی و این مورد وجود ندارد و تنها متود ارسال  داخل 

app / notification / MarkdownNotification

از نوع 
return (new MailMessage)->markdown('emails.markdown-notification');

است 


حالا برای ارسال به روش زیر عمل می کنیم 

in controller


public function index(){
		
	$user = User::find(5);
	
	$post = Post::find(1);
	
	Notification::send($user , new MarkdownNotification($post));		
}


in notification class

use App\Models\Post;




	public $post;

    
    public function __construct(Post $post)
    {
        $this->post = $post;
    }

    
    public function via($notifiable)
    {
        return ['mail'];
    }

    
    public function toMail($notifiable)
    {
        return (new MailMessage)->markdown('emails.markdown-notification', ['post' => $this->post]);
    }


in view 

{{ $post->title }}




---------------------------------------------------session 92 (118)

فارسی سازی ایمیل 
Authentication  and Reset password


برای 
reset password
and 
verify
لاراول از نوتیفیکیشن استفاده می کند


داخل وندور اگر برویم و بخش 
auth    ==>vendor\laravel\framework\src\Illuminate\Auth\Notifications

می بینیم که یک پوشه با نام نوتیفیکیشن وجود دارد و ولاراول به کمک آن ها ایمیل های مربوط به 
reset password
and verify
را ارسال می کند

داخل این فایل ها لاراول از شیوه 
Lang
استفاده کرده است که این موضوع کارما را برای فارسی سازی اسان می کند
Lang::get('Reset Password'), $url)

به همین منظور برای فارسی سازی کنار فایل ها مربوط به ترجمه داخل 
resource
یک فایل جیسون ایجاد کنید و  به روش زیر عمل کنیم 

{

	"Welcome to laravel and Vue" : "ترجمه با جیسون فارسی  --> :name",
	"Reset Password" : "بازیابی کلمه عبور"

}


---------------------------------------------------session 93 (119)
Save Notifications in Database


یکسری نوتیفیکیشن از طریق ایمیل به کاربر  ارسال می کنیم و  می خواهیم در دیتابیس هم ذخیره کنیم تا مثلا اگر خواستیم در 
پنل کاربری به کاربر نمایش دهیم بتوانیم

خود لاراول یک دستور دارد که همه کارهای لازم از قبیل ساخت مایگریت و 
..
را برای ما انجام می دهد

php artisan notifications:table


migrate

Schema::create('notifications', function (Blueprint $table) {
	
	$table->uuid('id')->primary();
	
	$table->string('type');
	$table->morphs('notifiable');
	$table->text('data');
	$table->timestamp('read_at')->nullable();
	$table->timestamps();
});


$table->uuid('id')->primary();   ==> uuid  == یک الگوریتم برای ایجاد ایدی یونیک 



$table->timestamp('read_at')    زمانی کاربر پیام را خوانده است به ما نشان می ده

برای اینکه تاریخ ها درست باشد و برای منطقه زمانی ما باشد باید به داخل 
config / app.php 

برویم و
'timezone' => 'UTC',  ==>  'Asia/Tehran'


حالا  اگر فیلد دیگر خواستیم خودمان به فایل مایگریت اضافه می کنیم و در غیر اینصورت 
php artisan migrate



Now

add database word into via

public function via($notifiable)
{
	return ['mail', 'database'];
}

حالا باید دیتایی که باید داخل دیتابیس ذخیره می شود را داخل 
toArray
قرار دهیم 

toArray
می تواند 
toDatabase
هم باشد 

public function toArray($notifiable)
{
	return [
		'post_title' => $this->post->title,
		'post_body' => $this->post->body,
		'message' => 'test notification database'
	];
}


حالا روت را اجرا می کنیم 


دیتاهایی که به آن پاس داده ایم به صورت 
json
در فیلد دیتا در حدول  نوتیفیکیشن ذحیره شده اند

{"post_title":"title1","post_body":"asdffffffffffffffff","message":"test notification database"}


حالا لاراول چند متود کاربردی برای دسترسی به این اطلاعات که در دیتابیس ذخیره کرده ایم در اختیار ما قرار داده است 

in controller



$user = User::find(5);
dd($user->notifications);

این دستور تمام نوتیفیکیشن های مربوط به کاربر را برمی گرداند 
می توانیم این دستور را به ویو ارسال کنیم و با 
Foreach
همه آن ها را به کاربر نمایش دهیم 


حالا لاراول یک متودها برای خواندن دارد و زمانی که اجرا شود نوتیفیکیشن مورد نظر به حالت خوانده شده تبدیل می شود و فیلد 
read_at
در دیتابیس دیتا دریافت می کند 



$notif = $user->notifications->first();  //select notify 
		
$notif->markAsRead();

با اجرای این دستور فیلد 
read_at
تاریخ  همان زمان را می گیرد و دیگر 
null
نیست


لاروال یک تابع دیگر هم دارد که مواردی که خوانده نشده است را برمی گرداند

$user->unreadnotifications;

می توانیم با دستور زیر نوتیفیکیشن های مورد نظر را پاک کنیم

$notif = $user->notifications->first();

$notif->delete();


یا می توانیم کل نوتیفیکشن ها یک کاربر را پاک کنیم 

$user->notifications()->delete(); // delete all for this user


می توانیم اطلاعاتی را هم که می خواهیم اپدیت کنیم 

$user->notifications()->update([]);


برای دریافت بخش های نوتیفیکشن هم می توانیم به روش زیر عمل کنیم 

$notif = $user->notifications->first();

dd($notif->data);
dd($notif->data['message']);



---------------------------------------------------session 94 (120)

SMS Channel in Notifications


لاراول از یک کتابخانه اختصاصی به نام 
Nexmo
برای ارسال 
sms
استفاده می کند
و چون در ایران هستیم  نمی توانیم از این سرویس استفاده کنیم

داخل پوشه 
app
یک پوشه به نام 
Channels
ایجاد می کنیم 

داخل این پوشه یک فایل می سازیم به اسم 
SmsChannel.php

حالا داخل فایل ابتدا موارد زیر را قرار می دهیم 

<?php

namespace App\Channels;

use Illuminate\Notifications\Notification;



class SmsChannel {
	public function send($notifiable , Notification $notification){
		dd($notifiable , $notification);
	}
}

حالا باید به کلاس نوتیفیکشنی که داریم از آن استفاده می کنیم برای ارسال نوتیفیکشن برویم و عمل زیر را انجام دهیم 


use App\Channels\SmsChannel;


public function via($notifiable)
{
	return ['mail', 'database' , SmsChannel::class];
}


public function toSms($notifiable)
{
	return $message = "test sms";
}


in controller
$user = User::find(5);
		
$post = Post::find(1);

Notification::send($user , new MarkdownNotification($post));

حالا اگر روت را اجرا کنیم باید 
dd($notifiable , $notification);
به ما نمایش داده شود 


حالا بخش زیر را تکمیل می کنیم 

class SmsChannel {
	public function send($notifiable , Notification $notification){
		dd($notifiable , $notification->toSms($notifiable));
		
		
		// Send SMS  ==> کدهای مربوط به سرویش پیامکی را اینجا قرار می دهیم 
	}
}



---------------------------------------------------session 95 (121 , 122)

Event in LARAVEL



in laravel doc  ==> Digging Deeper

ممکن است در سیستم ما یک اتفاقی بیوفتد و ما می خواهیم به آن گوش کنیم و زمانی که آن اتفاق افتاد  
کاری خاصی را انجام دهیم 


مثلا ما در سایت نویسند ه داریم و می خواهیم زمانی که او یک پست ارسال کرد 
یک ایمیل به مدیر سایت ارسال شود 

Event  ==> رویدادی که روی می دهد 
Listener  ==> گوش می دهد تا ایونت روی بدهد و کاری خاصی را انجام دهد 


می توانید برای هر 
event
چند 
listener
داشته باشیم 




---------------------------------------------------session 96 (122)
Create Event And Listener


می خواهیم اینوت بگذاری م که وقتی پست ارسال شد  لیستنر  گو ش بدهد و ایمیل ارسال کند 


in cmd  ===>   php artisan make:event --help 

				php artisan make:event  name
				
				php artisan make:event  CreatePost
				
حالا در پوشه 
app
یک پوشه به نام 
Events
برای ایونت ها ایجاد می شود و فایل درون آن قرار می گیرد 


in cmd  ===>   php artisan make:listener --help 

				php artisan make:listener  name
				
				php artisan make:listener  CreatePostListener

حالا در پوشه 
app
یک پوشه به نام 
Listeners
برای ایونت ها ایجاد می شود و فایل درون آن قرار می گیرد 


dispath  ==> به معنی اجرا کردن ایونت  هرجا اینونت اجرا می شود  می گوییم  دیس پچ شده 


in event file


broadcast  ==> یک قابلیت است در لاراول که می آید اتفاقاتی که در سمت سرور می افتد را به سمت کلاینت پاس می دهد 
               مثلا برای چت های انلاین که ما یک پیام را ارسال می کنیم و سیستم بلافاصله آن را به کلاینت طرف مقابل ارسال می کند 
			   استفاده می شود 
برای ایم مبحث باید از کتابخانه 
portial 
استفاده کنید 

InteractsWithSockets   --> در ایونت ها است و مربوط به همین کار می شود 




SerializesModels  ==>  یک استاندارد  مانند جیسون که در زبان های برنامه نویسی دیگر هم است و ما می توانیم در 
						آن انواع داده ها مانند ابجمت و غیره را قرار دهیم 



in listener file 

یک متود به نام 
handle($event)
وجود دارد که 
$event
به آن پاس داده شده است و کارهای ما را این متود انجام می دهد 


public function handle($event)
{
	dd("Event Dispath");
}


چگونه ایونت را اجرا کنیم و اصلا چکونه بفهمانیم که کدام ایونت مربوط به کدام 
listener
است

in provider folder  /EventServiceProvider.php

داخل 
protected $listen
می توانیم تعریف کنیم که کدام لیستنر  مربوط به کدام ایونت است 


use App\Events\CreatePost;
use App\Listeners\CreatePostListener;

protected $listen = [
	Registered::class => [
		SendEmailVerificationNotification::class,
	],
	CreatePost::class => [
		CreatePostListener::class
	],
];





dispatch  
یا اجرا کردن 
event

in controller

use App\Events\CreatePost;

public function index(){
		
	event(new CreatePost());
	
}


الان باید با اجرای روت 
dd
داخل فایل 
listener
اجرا شود 



---------------------------------------------------session 97 (123)

ارسال پارامتر به 
event


in  controller

use App\Events\CreatePost;

public function index(){
		
	$x = "Laravel Event ==> Vue Listener";
	
	event(new CreatePost($x));
	
}


in event 

public $param;

public function __construct($param)
{
	$this->param = $param;
}


in listener

public function handle($event)
{
	/* dd("Event Dispath"); */
	dd($event->param);
}


حالا گاهی نمی خواهیم در 
event
پروپرتی ها از نوع 
public
باشند و نیاز است که از نوع 
private

باشند که در این صورت باید از 
getter
استفاده کنیم 



in event 



private $param;

public function __construct($param)
{
	$this->param = $param;
}


//getter

public function getParam(){
	return $this->param;
}


in listener

public function handle($event)
{
	
	dd($event->getParam());
}


---------------------------------------------------session 98 (124)

Job & Queue


laravel doc   ==> digging deeper  --> Queues

Job  --> کار 
Queue  -- > صف 


Queue  --> فرض کنید  یک کاغذ است که لیستی از 
			job
			ها داخلش قرار دارند


معمولا برای کارهای بزرگ از این مورد استفاده می شود

مثلا کاربر یک سفارش را ثبت می کند و ما نمی خواهیم همان لحظه ایمیل برایش ارسال شود 
و می خواهیم فرضا یک یا دوساعت بعد ایمیل برایش ارسال شود 


in config / Queue.php 

تنظیمات 
queue
در اینجا قرار دارد 


'default' => env('QUEUE_CONNECTION', 'sync'),

زمانی که 
"sync"
باشد زمانی که یک  جاب را فایر می کنیم همان موقع اجرا می شود


"database"   ==>  ذخیره در دیتابیس



"beanstalkd", "sqs", "redis", ==> سرویس های خارجی 
"null"


'failed' => [
	'driver' => env('QUEUE_FAILED_DRIVER', 'database-uuids'),
	'database' => env('DB_CONNECTION', 'mysql'),
	'table' => 'failed_jobs',
],

برای زمانی است که ما یک 
جاب قرار می دهیم و به هر دلیلی اجرا نمی شود 
این تنظیمات می گوید که آن را در دیتابیس ذخیره کند تا بعدا ببینیم دلیل 
شکست خوردن آن چه بوده است

---------------------------------------------------session 99 (125)

Create Job in laravel


in cmd  ==> php artisan make:job --help
			php artisan make:job name
			
			php artisan make:job TestJob

داخل 
app 
یک پوشه به نام 
jobs
ایجاد میشود و کلاس مورد نظر در آن قرار می گیرد 

داخل کلاس ایجاد شده یک سری ترید ها وجود دارد که عبارتند از 

Dispatchable ==> به جاب این قابلیت را می دهد که  دیسپچ شود  و اجرا شود 


InteractsWithQueue  ===> ارتباط بین جاب و کیو را ایجاد میکند 

Queueable   ==> این قابلیت را به جاب می دهد که داخل کیو  یا همان لیست کارها قرار بگیرد 

SerializesModels  ===> یک استاندارد شبیه  جیسون  برای تبدیل کردن به استرینگ 



ژمانی که موقع اجرا  جاب می شود   متود 
handle()
آن اجرا می شود 



---------------------------------------------------session 100 (126)

dispatch  job   یا اجرای جاب 


in controller


use App\Jobs\TestJob;

public function index(){
	
	TestJob::dispatch();
	
}


in job

public function handle()
{
	var_dump('JOB DISPATH');
}

حالا چون تنظیمات 
queue
ما روی سینک است اگر به لینک برویم همان موقع دستور ما 
dispatch
می شود 

چون بقیه سرویس ها پولی هستند ما تنها می توانیم از دیتابیس استفاده کنیم به همین منظور به فایل
.env
می رویم و روی دیتابیس قرار می دهیم

QUEUE_CONNECTION=sync  == > QUEUE_CONNECTION=database


برای ایجاد جدول هم از ارتیسان کمک می گیریم 

php artisan queue:table

این دستور مایگریشن مربوطه را ایجاد می کند 


Schema::create('jobs', function (Blueprint $table) {
	$table->bigIncrements('id');
	$table->string('queue')->index(); 
	$table->longText('payload');    ===> برای دخیره داده ها 
	$table->unsignedTinyInteger('attempts');   ===> تعداد تلاش برای انجام  جاب 
	$table->unsignedInteger('reserved_at')->nullable();  ==> تاریح رزرو
	$table->unsignedInteger('available_at');   ==> زمانی که می توانیم از آن جاب استفاده کنیم 
	$table->unsignedInteger('created_at');
});


حالا 
php artisan migrate

الان باید جدول جاب در دیتابیس ایجاد شده باشد 

حالا یکبار دیگر روت مربوط به جاب را اجرا می کنیم 


الان باید اطلاعات در دیتابیس ذخیره شود 


queue in database    به طور پیشفرض دیفالت است و اگر خواستیم طبقه بندی برای جاب ها داشته باشیم می توانیم آن را تغییر دهیم 


payload in database   ===> دیتاها به صورت 
							serialize
							شده 


حالا برای اجرای جاب هایی که در دیتابیس ذخیره کرده ایم باید از 
ارتیسان استفاده کنیم 

php artisan queue:work  --help
php artisan queue:work  --queue=name
php artisan queue:work  --queue=default

این دستور می آید جاب های مارا اجرا و پس از تمام شدن آن ها را از دیتابیس جذف می کند 


---------------------------------------------------session 101 (127)

دسته بندی کردن جاب ها 

in controller

public function index(){
		
	TestJob::dispatch()->onQueue('email');
	
}

با این روش فیلد 
queue
در دیتابیس برابر با 
email
می شود و ما می توانیم بدین طریق جاب ها خود را دسته بندی کنیم 


ارسال پارامیتر 

in job


public $user;
	 
	 
public function __construct(User $user)
{
	$this->user = $user;
}


in controller

public function index(){
	
	$user = User::find(5);
	
	TestJob::dispatch($user)->onQueue('email');
	
}



ایجاد تاخیر در اجرای جاب ها 

TestJob::dispatch($user)->onQueue('email')->delay(now()->addSeconds(20));


now()->addSeconds(20)  ==> مربوط به کتابخانه کربن


TestJob::dispatchNow($user);   ==> همانند  سینک همان موقع حاب را اجرا می کند 




---------------------------------------------------session 102 (128)

failed jobs

ممکن است جابی که ایجاد کرده ایم در زمان اجرا به هر دلیلی با ارور یا مشکل مواجه
شود و این موضوع کمک می کند بفهمیم که برای چه این جاب شکست خورده است و کار نکرده است 

حالا ما یک ارور دستی ایجاد می کنیم تا نمونه  شکست خوردن را ببنیم 

in job
public function handle()
{
	
	throw new Exception('Error in Job');
	
	
	var_dump('JOB DISPATH');
	
	
	
}

حالا روت را اجرا می کنیم تا جاب در دیتابیس ذخیره شود 

حالا جاب را اجرا می کنیم 

php artisan queue:work    ==> دیفالت ها را اجرا می کند

ابتدا بببیند که در بین حدول ها دیتابیس جدول 
failed_jobs
باشد که به طور پیشفرض خود لاراول آن را قرار می دهد اما اگر نبود با دستور زیر آن را ایجاد کنید 

php artisan queue:failed-table


اما بررسی فیلدهای دیتاتبیس


connection   ===> نوع درایور ما را مشخص می کند 

queue  === > نوع  کیو 

payload  == >  دیتاها 

exception  ==> متن کامل خطا 


failed_at  ==> زمان بروز خطا 


می توانیم برای اینکه جاب های خطا دار   را ببینیم  یک  مدل و کنترلر و روت ایجاد کنیم و آن را در یک صفحه نمایش دهیم 
یا می توانیم آن را در ارتیسان ببینیم 

php artisan queue:failed


می توانیم تعداد تکرار اجرای جاب را هم مشخص کنیم یعنی  جاب  
10 بار
اجرا شود اگر با هم به ارور خود حالا فی لد شود  ودر  دیتابییس  ذخیره شود 



php artisan queue:work --tries=3

این دستور مثلا برای اجرا همه جاب ها 
3 
بار تلاش می کند اما گاهی ما می خواهیم که تعداد تلاش برای هر جاب متفاوت باشد که در این صورت به روش زیر عمل می کنیم 


in job 

public $tries = 5;

---------------------------------------------------session 103 (129)

retry

دوباره اجرا کردن جاب ها ی 
failed
شده 


php artisan queue:retry --help

حالا این دستور می گوید که ایدی  جابی که  فی لد 
شده و می خواهید دوباره اجاره شود  را به من بده یا این که 
all 
بزن تا همه جاب ها  فی لد شده دوباره برای اجرا درخواست شوند 

php artisan queue:retry all

php artisan queue:retry 4

در حقیقت این دستور  جاب 
failed
شده را از جدول 
failed_jobs
به جدول 
jobs
منتقل می کند


---------------------------------------------------session 104 (130)

Artisan Console


in laravel doc  ==> digging deeper => artisan console

ما 
3 
نوع ارسال درخواست در لاراول داریم 

1. api
2. command line  (artisan console)
3.  route in browser (http request)

در 
cmd 
زمانی که می گوییم 
php ---
---   یک فایل پی اچ پی است که ما می توانیم آن را اجرا کنیم 

php  ali.php


در ورت پوشه لاراول ما فایل 
artisan
را داریم که پسوند ندارد اما از نوع 
php 
است زیرا در ابتدای آن این دستور گذاشته شده است 

#!/usr/bin/env php


in artisan  file

define('LARAVEL_START', microtime(true));

require __DIR__.'/vendor/autoload.php';   ==> composer

$app = require_once __DIR__.'/bootstrap/app.php';


$kernel = $app->make(Illuminate\Contracts\Console\Kernel::class);

$status = $kernel->handle(
    $input = new Symfony\Component\Console\Input\ArgvInput,
    new Symfony\Component\Console\Output\ConsoleOutput
);

$kernel->terminate($input, $status);

exit($status);

این دستورات همان دستوراتی است که داخل 
index.php
اصلی پروژه در 
پوشه پابلیک هم قرار دارند


تنها تقاوت در این حط است 

in console

$kernel = $app->make(Illuminate\Contracts\   Console   \Kernel::class);


in index  
 
$kernel = $app->make(Illuminate\Contracts\   Http   \Kernel::class);



##############################

 $input = new Symfony\Component\Console\Input\ArgvInput,
 
 هر دستوری که بعد از 
 php artisan 
 بزنیم به عنوان ورودی به داخل این متغییر ریخته می شود 
 
  php artisan ali  mm  bb
  
  
   $input = [0=>ali, 1=> mm, 2=>  bb]


کرنل مربوط به کنسول در این ادرس قرار دارد 

app / Console /kernel.php


 protected $commands
 
 دستورانی که خوودمان می خواهیم به ارتیسان اضافخ کنیم تا در 
 cmd
 در دسترس باشد باید اینجا قرار دهیم 
 
 
schedule(Schedule $schedule){}


برای برنامه ریزی و زمان بندی اجرای دستورات  ارتیسان است 


 protected function commands()
{
	$this->load(__DIR__.'/Commands');

	require base_path('routes/console.php');
}

این متود می اید کامند های مارا  اضافه و آن ها را اماده اجرا می کند 

$this->load(__DIR__.'/Commands');  این دستور میگه که  کامند ها را ایجاد و داخل پوشه 
									Commands
									قرار بده 


require base_path('routes/console.php');	

این دستور اشاره دارد به  پوشه 
routes
و فایل 
console.php 

in  console.php 

Artisan::command('inspire', function () {
    $this->comment(Inspiring::quote());
})->purpose('Display an inspiring quote');


این مشابه روت ها است و می توانیم دستورات را اینجا قرار دهیم 

این دوشکل ایجاد دستورات  ارتیسان هستند 
داخل کرنل و پوشه  
	Commands

یا داخل پوشه روت و فایل 
console.php 


جفت این روش یکی هستند و یک کار را انجام می دهند 


Artisan::command('inspire', function () {
    $this->comment(Inspiring::quote());
})->purpose('Display an inspiring quote');

به این فانکشن ورودی دوم 
clouser command
می گویند 



به روش ایجاد کامند در  کرنل و پوشه 
Commands
روش 
Generate Command
می گویند 


---------------------------------------------------session 105 (131)

Create Command

تنها از یک روش برای ایجاد کامند ها استفاده کنید   
یا روش کلوژر   یا روش  ایجاد پوشه 
commands



روش  کلوژر

in console.php    in routes folder

Artisan::command('test', function () {
    echo "test command Clouser";
})->purpose('Desciption for this');


->purpose('Desciption for this')  ===> توضیحات

نمی توانیم از 
return 
استفاده کینم

بعد از ذخیره دستور 

php artisan test
را می زنیم و می بینم که متن را برایمان چاپ می کند 

همچنین به لیست دستورات ارتیسان   
available
اضافه می شود و می توانیم آن را همراه توضیحش در 

php artisan   or  php artisan  list

ببینیم

---------------------------------------------------session 106 (132)

Send Param to Closure Command

in console.php 



Artisan::command('greeting {name : discription for param}', function ($name) {
	
	echo "Hi ".$name." , Welcome to Command";
	
})->purpose('Welcome to ...');


اگر دستور 

php artisan greeting --help

را بزنیم به ما می گوید که پارامتر چه چیزی می خواهد 

فقط توجه داشته باشید که فاصله در این جا الزامی است 

{name : discription for param}





ارسال چند ارگومان 



Artisan::command('greeting {name : discription for param} {family : desc famili}', function ($name , $family) {
	
	echo "Hi ".$name." ".$family. " , Welcome to Command";
	
})->purpose('Welcome to ...');


php artisan ali mohseny


الان این پارامترها  اجباری است و  اگر پاس ندهیم  ارور می دهد  
برای اینکه این ها را اختیاری کنیم به روش زیر عمل می کنیم 

با علامت سوال 


Artisan::command('greeting {name : discription for param} {family? : desc famili}', function ($name , $family = null) {
	
	echo "Hi ".$name." ".$family. " , Welcome to Command";
	
})->purpose('Welcome to ...');

روش دیگر برای اختیاری کردن پارامترهای

با مساوی 

Artisan::command('greeting {name : discription for param} {family=Shioexh : desc famili}', function ($name , $family) {
	
	echo "Hi ".$name." ".$family. " , Welcome to Command";
	
})->purpose('Welcome to ...');




---------------------------------------------------session 107 (133)

پاس دادن 
option 
به ارتیسان
اپشن مانند   ==>  --help   -r  -m


in console.php

Artisan::command('greeting {name : discription for param} {family=Shioexh : desc famili} 

{--age : option for artisan}'


, function ($name , $family) {
	
	echo "Hi ".$name." ".$family. " , Welcome to Command";
	
})->purpose('Welcome to ...');


حتی می توانیم نام مستعار و کوچک شده هم قرار دهیم

{--A|--age : option for artisan}


حالا برای استفاده از اپشن در بدنه تابع باید به روش زیر عمل کنیم

Artisan::command('greeting {name : discription for param} {family=Shioexh : desc famili} {--A|--age : option for artisan}', function ($name , $family) {
	
	//use option
	
	$this->option('age');
	
	
	echo "Hi ".$name." ".$family. " , Welcome to Command";
	
})->purpose('Welcome to ...');



$this->option('age');
این را اگر 
dd
بگیریم و دستور را بزنیم در 
cmd
اگر  اپشن پاس داده شود  
true
و در غیر این صورت 
false
را برمی گرداند که می توانیم از آن برای اجرا یا عدم اجرای فرمانی خاص استفاده کنیم 



حالا گاهی می خواهیم که اپشن مقدار هم بگیرد که در این صورت به روش زیر عمل می کنیم 

{--A|--age= : option for artisan}

از مساوی استفاده می کنیم اما  نباید  فاصله بین مساوی باشد 

php artisan navid --age=30

php artisan navid --A 30  ===> روش نام مستعار دیگر به  مساوی نیازی ندارد 

حالا با 
$this->option('age');  // 30
می توانیم مقدار را دریافت کنیم 





دسته بندی  دستورها 

با قرار داد این در ابتداری دستور 
webprog:greeting
دسته بندی می شود و در گروه و دسته  
webprog
قرار می گیرد


Artisan::command('webprog:greeting {name : discription for param} {family=Shioexh : desc famili} {--A|--age= : option for artisan}', function ($name , $family) {

	echo "Hi ".$name." ".$family." : " . $this->option('age'). " , Welcome to Command";
	
})->purpose('Welcome to ...');


وقتی دسته بندی کردیم برای اجرای دستور باید به شکل زیر عمل کنیم 

php artisan webprog:greeting navid --age=32



---------------------------------------------------session 108 (134)

بررسی بیشتر 
$this
در دستورات 
console

$this
اشاره می کند به 
Artisan

 $this->comment('ali echo');
 این متود متن را به خروجی می فرستد و نمایش می دهد   و باید به جای 
 echo 
 از آن استفاده کنیم

می توانیم رنگ متنی که به خروجی می فرستیم را هم تغیر دهیم 

$this->comment('ali echo'); // yellow
$this->info('ali info'); // Green
$this->error('ali error'); // red
$this->question('ali question'); // blue
$this->line('ali line'); // white

می توانیم از ترکیب رنگ ها استفاده کنیم 

$this->line('ali <info>line</info>'); 



می توانیم یک جدول هم ایجاد کنیم 

//table
$header = ['name','age'];
$body = [
	['ali',26],
	['ali',26],
	['ali',26],
	['ali',26],
];
	
$this->table($header , $body);


---------------------------------------------------session 109 (135)

پرسیدن سوال و گرفتن ورودی در 
command artisan


Artisan::command('input', function () {
	
	
    $input = $this->ask('Enter Your name');
	
	$this->line("name is: {$input}");  == > حتما دابل کوتیشن
	
	
})->purpose('input Command');


// Confirm

Artisan::command('input', function () {
	
	$input = $this->confirm('Enter Your name' , true);

	$this->line("gebder is: {$input}");
	
})->purpose('input Command');

به طور پیشفرض مقدار 
no
را در نظر می  گیرد یعنی اگر ما دستوری در جواب سوال وارد نکنیم  خودش  
no
را در نظر می گیرد  اما می توانیم این پیش فرض را هم تغییر دهیم 

$input = $this->confirm('Enter Your name' , true);

با پارامتر دوم   که اگر 
true 
بگذاریم به طور پیشفرض
yes
را در نظر می گیرد 



//   choice

Artisan::command('input', function () {
	
	$input = $this->choice('what is your gender?' , ['Male' , 'Famale'] , 'Male' , 5 , true);

	$this->line("gebder is: {$input}");
	
})->purpose('input Command');


می توانیم برای این مورد هم مقدار دیفالت در نظر بگیریم 
به عنوان پارامتر  سوم


می توانیم تعداد دفعاتی که از کاربر  سوال پرسیده می شود اگر جواب غلط بدهد را هم مشخص کنیم  به عنوان پارمتر چهارم 


پارامتر آخر هم 
multiple 
است که اگر آن را 
true
قرار دهیم می توانیم چند جواب دریافت کنیم 


$input = $this->secret('Enter Your pass');

$this->line("pass is: {$input}");

این مورد زمانی که ورودی را وارد می کنیم روی صفحه نمایش نمی دهد اما آن را دریافت می کند 



---------------------------------------------------session 110 (136)

Generating Command

این روش شامل شاخت پوشه
Commands
و قرار دادن دستورات در آن است اما اینبار در پوشه 
app / console


برای این کار می توانیم از 
ارتیسان کمک بگیریم


php artisan make:command --help
php artisan make:command name

php artisan make:command Hello


الان با اجرای این دستور پوشه کامند در 
app / console
ایجاد می شود و فایل دستورات در آن قرار می گیرد 


in Hello.php 


protected $signature = 'command:name';  

==>  بخش اول اسم دسته بندی که می خواهیم داخل آن قرار گیرد است و بخش دوم اسم دستور 

خودمان باید اینها را تغییر دهیم 

protected $signature = 'webprog:hello';


protected $description = 'description For Hello Command';
این بخش هم توضیحات دستور است 




---------------------------------------------------session 111 (137)

سایر موارد در  مورد 
Generating Command


ارسال پارامتر

in 
app / console / Hello.php


protected $signature = 'webprog:hello {name : discription for param} {family=Shioexh : desc famili} {--A|--age= : option for artisan}';


in handle method

public function handle()
{
	echo "Hi ".$this->argument('name')." ".$this->argument('family')." : " . $this->option('age'). " , Welcome to Command";
	return 0;
}


---------------------------------------------------session 112 (138)


public function handle()
{
	$this->comment('ali echo'); // yellow
	$this->info('ali info'); // Green
	$this->error('ali error'); // red
	$this->question('ali question'); // blue
	$this->line('ali line'); // white

	$this->line('ali <info>line</info>'); 


	//table
	$header = ['name','age'];
	$body = [
		['ali',26],
		['ali',26],
		['ali',26],
		['ali',26],
	];

$this->table($header , $body);


	return 0;
}



دریافت ورودی 


in handel method

$input = $this->ask('Enter Your name');
	
$this->line("name is: {$input}");


$input = $this->confirm('Enter Your name' , true);

$this->line("gebder is: {$input}");


$input = $this->choice('what is your gender?' , ['Male' , 'Famale'] , 0 , 2 , true);

$this->line("gebder is: {$input}");


$input = $this->secret('Enter Your pass');

$this->line("pass is: {$input}");




---------------------------------------------------session 113 (139)

Call method

گاهی نیاز است که دستور ارتیسان را از طریق  
http
فراخونی کنیم  یعنی یک روت تعریف کنیم و بگیم زمانی که روت صدا زده شد
این دستور ارتیسان اجرا شود


در هاست های اشتراکی  ما اصلا به ترمینال دسترسی نداریم و باید دستورانی که نیاز است با ارتیسان اجرا شوند 
را در قالب یک روت و 
http
فراخوانی کنیم 


این برای اجرا  کیوها  عالی است 

in  web.php 


use Illuminate\Support\Facades\Artisan;

Route::get('/call-artisan', function(){
	
	$result = Artisan::call( "webprog:hello" , ["name" => 'ali' ,"--age"=> 25] );
	
	dd($result);
	
});


نمونه استفاده از این متود برای کیو ها 


Route::get('/call-queue', function(){
	
	$result = Artisan::call( "queue:work" , ["--queue"=> 'default' , "--once" => true] );
	
	dd($result);
	
});

در حالت عادی زمانی که در 
cmd
دستور 

queue:work

را می زدیم منتظر می ماند و  جاب های بعدی را هم اجرا می کرد اما ما در پروتکل 
http
نمی توانیم 
http
را بیش از 
60
ثانیه منتظر نگه داریم زیرا به ما ارور 
time out

می دهد به همین دلیل با قرار دادن پارامتر سوم و 
true
کردن آن می گوییم که تنها یکبار اجرا شود 

"--once" => true


البته متود کال یک کاربرد دیگر هم دارد و آن این است که می توانیم از آن استفاده کنیم و در  یک دستور ارتیسان که 
تعریف کرده ایم  دستور ارتیسان دیگری را فراخوانی کنیم 


in handle method hello 

$this->call('webprog:input');


---------------------------------------------------session 114 (140)

tinker method


tinker
یک رپل قدرتمند است برای لاراوال

REPL  ==> Read Evaluate Print Loop
			یک محیط برنامه نویسی تعاملی است که از کاربر ورودی می گیرد 
			آن را پردازش می کند و بعد نتیجه را به کاربر نمایش می دهد--

نمونه  ==> cmd


برای وارد شدن به آن دستور زیر را می زنیم 

php artisan tinker

گرفتن اطلاعات کاربر

in cmd  === > $user = App\Models\User::find(5);  ==> Enter


in cmd  ===> doc  request   ==> داکیومنت ریکوئست را برمی گرداند 


in cmd  ===> show  request   ==> کدها ریکوئست را برمی گرداند 


تمامی عملیات ساخت  و حذف کردن و اپدست کردن دیتابیس را می توانیم با 
tinker
انجام دهیم که کار ما را خیلی آسان می کند 



---------------------------------------------------session 115 (141 , 142)

Http Client


in laravel doc  ==> digging deeper  ==> از لاراول هفت اضافه شده

این بخش به ما کمک می کند یک درخواست به 
api
بدیم و پاسخی دریافت کنیم


این بخش از کتابخانه 
Guzzle
استفاده می کند 

خودش لاروال این مورد را دارد می توانید آن را در 
composer.json
ببنید 


برای تست از 
json placeholder

استفاده می کنیم 





GET Method

in controller

use Illuminate\Support\Facades\Http;


$data= Http::get("https://jsonplaceholder.typicode.com/posts");

		
dd($data->body());    ===> دیتا ها را به صورت یک استرینگ برمی گرداند


dd($data->json()); ==> برای استفاده از داده های ارسال شده از 
						api
						نیاز داریم آنها را در قالب ارایه داشته باشیم که این متود
						دیتاها را به صورت ارایه برمی گرداند 
						
به این شکل هم می توانیم دیتاها را دریافت کنیم 

$data= Http::get("https://jsonplaceholder.typicode.com/posts")[0];

						
dd($data->status());  ==> status  
							کد و درخواست ما را نشان می دهد
							
200  ==> success
400 >= X    ===> error

   
dd($data->ok());   ===> رنج دویست تا سیصد را بررسی می کند که در این رنج درخواست موفقیت آمیز بوده است 


dd($data->clientError());  ==> ارورهای رنج 
								400
								را که هم برای کاربر است و هم نشانه شکست خوردن درخواست است را بررسی می کند
								

dd($data->serverError());   ==> ارورهای رنج
								500
								که ارور های سرور هستند را بررسی می کند 



$data->throw();   ===> اگر به ارور بخوریم یک  اکسپشن را هندل می کند 



ارسال پارامتر 

$data= Http::get("https://jsonplaceholder.typicode.com/posts" , [
	"id" => 12
]);


تعیین کردن تایم اوت برای درخواست    یعنی اگر درخواست خیلی طول کشید  بیخیال آن بشود 

# $data= Http::timeout(second)->get("https://jsonplaceholder.typicode.com/posts");
$data= Http::timeout(5)->get("https://jsonplaceholder.typicode.com/posts");


---------------------------------------------------session 116 (143)

Post Method in Http Client

$data= Http::post("https://jsonplaceholder.typicode.com/posts" , [
	"id" => 12
]);


$data= Http::asForm()->post("https://jsonplaceholder.typicode.com/posts" , [
	"id" => 12
]);


$data= Http::attach('name' , content , 'final name')->post("https://jsonplaceholder.typicode.com/posts" , [
	"id" => 12
]);


$data= Http::attach('image' , file_get_contents('path') , 'img.png')->post("https://jsonplaceholder.typicode.com/posts" , [
	"id" => 12
]);

$data= Http::withBasicAuth('username' , 'password')->post("https://jsonplaceholder.typicode.com/posts" , [
	"id" => 12
]);

$data= Http::withToken('token')->post("https://jsonplaceholder.typicode.com/posts" , [
	"id" => 12
]);

$data= Http::withHeader([

	'token' => 'token',
	'X-Header' => 'header',
	
])->post("https://jsonplaceholder.typicode.com/posts" , [
	"id" => 12
]);



$data= Http::retry(count resend , time (milisecond) )->post("https://jsonplaceholder.typicode.com/posts" , [
	"id" => 12
]);
   ===> تکرار ارسال درخواست 
   

   

$data= Http::retry(3 , 500)->post("https://jsonplaceholder.typicode.com/posts" , [
	"id" => 12
]);  


 
   
---------------------------------------------------session 115 (144 - 151 )

Laravel  8


در 

Documents 

لاراول برای مشاهده تغییرات هر نسخه با نسخه قبل می توانید ابتدا ورژن را انتخاب و بعد به بخش 
release notes 
بروید


در لاراول 
8 

 دل ها داخل پوشه 
 models
 قرار گرفته اند و همچنین هر تغییری که در فایل
 
.env
ایجاد کنیم خود لاراول به طور خودکار سرور را
 reset 
می کند و سرور را 
serve
می کند




یکی موارد اضافه شده در لاراول 8 موضوع 

Jetstream

است این پکیج دو بخش برای فرانت اند و بک اند 
دارد.
 در بک اند ار 
Fortify
استفاده میکند که باید ان را یاد بگیریم زیرا قابلیت های زیادی به ما می دهد اما در سمت فرانت نیازی نیست از پکیح

Jetstream 

استفاده کنیم زیرا برای استفاده از ان در سمت فرانت نیاز است با موارد زیر اشنا باشیم و انها را یا بگیریم که اصلا نیازی نیست

Tailwind css
Livewire
Inertia.js

پس ما به جای نصب پکیج 

Jetstream 

پکیج 

Fortify 

را به تنهایز نصب میکنیم تا از قابلیت های ان در سمت بک اند استفاده کنیم.



---------------------------------------------------session 116 (152)

Fotify  Package


برای پیاده سازی 
auth
در لاراول 
ui
ما مجبور  بودیم از قواینین  فرانت و بک اند  آن پیروی کنیم اما 
fortify
فقط قسمت بک اند ما را هندل می کند و کاری به فرانت ندارد و ما به راحتی می توانیم 
فرانت را کاستومایز کنیم 



عملکرد به این صورت است که شما هر دیزاینی که خواستین پیاده می کنید و تنها اطلاعات را به روتی که مربوط به 
fortify
است ارسال می کنید تا بقیه کار ها را خودش انجام دهد 


install

in github

composer require laravel/fortify

حالا باید با دستور زیر تنظیمات را به 
پروایدر فراخوانی کنیم 

php artisan vendor:publish --provider="Laravel\Fortify\FortifyServiceProvider"


این دستور 
FortifyServiceProvider.php 
را به پوشه پروایدرها اضافه می کند 


حالا دستور 
php artisan migrate
را میزنیم تا جدول مورد نساز خود را ایجاد کند 


حالا حتما  حتما باید به لاراول بگید که همچین پروایدری وجود دارد  یعنی داخل 
config / app.php => providers

آن را اضافه کنید 
App\Providers\FortifyServiceProvider::class,




---------------------------------------------------session 117 (153)

داخل پوشه 
app
یک پوشه به اسم اکشن ایجاد شده است که کلاس های 
fortify
داخل آن قرار دارد

CreateNewUser.php  ===> برای ایجاد کاربر

PasswordValidationRules.php  ==> ایمن کردن و اعتبار سنجی پسورد 

ResetUserPassword.php 

UpdateUserPassword.php 

UpdateUserProfileInformation.php 


پوشه بعدی داخل 
provider
ها اضافه شده است 

FortifyServiceProvider.php  ==>
فیچر ها و ویژگی هایی که نیاز است را اجرا می کند 

 public function boot()
    {
        Fortify::createUsersUsing(CreateNewUser::class);
        Fortify::updateUserProfileInformationUsing(UpdateUserProfileInformation::class);
        Fortify::updateUserPasswordsUsing(UpdateUserPassword::class);
        Fortify::resetUserPasswordsUsing(ResetUserPassword::class);

        RateLimiter::for('login', function (Request $request) {
            return Limit::perMinute(5)->by($request->email.$request->ip());
        });

        RateLimiter::for('two-factor', function (Request $request) {
            return Limit::perMinute(5)->by($request->session()->get('login.id'));
        });
    }
	
داخل همین 
boot
هم تعریف می کنیم  که ویو های مربوط به 
authentication
چی ها باشند 



فایل بعدی داخل پوشه
config

fortify.php 


'username' => 'email',

'email' => 'email',


میگه که نوع اینپوت ها چی باشند 



'home' => RouteServiceProvider::HOME,
این دستور صفحه ای بعد از لاگین یا ریجستر باید کاربر به ان انتقال داده شود را مشخص می کند 
این اشاره دارد به پروایدر

in provider       RouteServiceProvider.php 

public const HOME = '/home'; ===> این را می توانیم تغییر دهیم 

'limiters' => [
	'login' => 'login',
	'two-factor' => 'two-factor',
],

تعداد دفعاتی که کاربر می تواند لاگین کند را مشخص می کند 
default = 5 / min 
اگر در 
1 
دقیقه 
5 
بار اشتباه بزند به او ارور می دهد و می گوید که تا 
n
ثانیه دیگر نمی توانید لاگین کنی 

'login' => 'login',
'two-factor' => 'two-factor',
می توانید روت های دیگری را هم که لازم است به این ارایه اضافه کنید 



'features' => [
	Features::registration(),
	Features::resetPasswords(),
	// Features::emailVerification(),
	Features::updateProfileInformation(),
	Features::updatePasswords(),
	Features::twoFactorAuthentication([
		'confirmPassword' => true,
	]),
],

این هم ویژگی هایی است که 
fortify
در اختیار ما قرار می دهد و اگر مثلا 
Features::registration(),
را کامنت کنیم دیگر صفحه  ریجستر نداریم 

// Features::emailVerification(),
خودکار کامنت است و اگر نیازی  بود باید آن را از کامنت بیرون بیاوریم 




++++  پیاده سازی  لاگین و ریجستر 

برای این کار به 

FortifyServiceProvider.php 
می رویم و به روش زیر عمل می کنیم 

public function boot()
    {
        Fortify::createUsersUsing(CreateNewUser::class);
        Fortify::updateUserProfileInformationUsing(UpdateUserProfileInformation::class);
        Fortify::updateUserPasswordsUsing(UpdateUserPassword::class);
        Fortify::resetUserPasswordsUsing(ResetUserPassword::class);

        RateLimiter::for('login', function (Request $request) {
            return Limit::perMinute(5)->by($request->email.$request->ip());
        });

        RateLimiter::for('two-factor', function (Request $request) {
            return Limit::perMinute(5)->by($request->session()->get('login.id'));
        });
		
		Fortify::loginView(function(){
			return view('fortify-loginx');
		});
		
    }
	
خود این پکیج روت ها را هندل می کند و نیازی نیست ما روتی ایجاد کنیم 

حالا اگر به روت 
/login
برویم باید ویو ای که مشخص کردیم نمایش داده شود 


چون روی این پروژه  
laravel Ui 
داشتیم پکیج 
fortify
کار نمی کند به همین دلیل من از 
laravel vue on computer ast 
استفاده می کنم


	
	
---------------------------------------------------session 118 (154)

install bootstrap in laravel 8

روش ها استفاده

npm
CDN
Download


می توانیم فایل های را دانلود و داخل پوشه پابلیک قرار دهیم و بعد با 
asset()
هرجای که خواستیم آن ها را استفاده کنیم



NPM ==> 
ابتدا 
package.json
را بازکنید و مواردی که نیاز ندارید را پاک کنید 
بعد 
npm i

حالا 
npm i bootstrap jquery popper.js 


in resource / js / bootstrap.js

 
try{
	
	window.Popper = require('popper.js').default;
	window.$ = window.jQuery = require('jquery');
	
	require('bootstrap');
	
}catch(e){}   ==> ترتیب مهم است 



in resource /sass / app.scss

// Bootstrap
@import '~bootstrap/scss/bootstrap';  ~==> اشاره به   ==> node_modules



in webpack.mix.js

mix.js('resources/js/app.js', 'public/js')
    .sass('resources/sass/app.scss', 'public/css');




npm run dev 


in each file in blade

 <link rel="stylesheet" href="{{asset('/css/app.css')}}">
 
 
 
end of body tag

<script src="{{asset('/js/app.js')}}"></script>



---------------------------------------------------session 119 (155)


ایجاد صفحات لاگین و ریجستر 


in FortifyServiceProvider

Fortify::loginView(function () {
	return view('auth.login');
});

Fortify::registerView(function () {
	return view('auth.register');
});

Fortify::requestPasswordResetLinkView(function () {
	return view('auth.forgot-password');
});

Fortify::verifyEmailView(function () {
	return view('auth.verify-email');
});


حالا باید صفحه 
home
یا صفحه ای که برای برگشت مشخض کردیم را در روت ها اشافه کنیم 

Route::get('/home', function () {
    return view('home');
});


حالا می توانیم به روت برویم و عملیات ریجستر را انجام دهیم و بعد هم نی توانیم لاگین کنیم 


in  Create Name in Actions Folder

public function create(array $input)
{
	Validator::make($input, [
		'name' => ['required', 'string', 'max:255'], 
		'email' => [
			'required',
			'string',
			'email',
			'max:255',
			Rule::unique(User::class),  ==> چک می کند که ایمیل کاربر یکسان نباشد یا به عبارتی کاربر با این اطلاعات قبلا ثبت نام  نکرده باشد
		],
		'password' => $this->passwordRules(), 
	])->validate();
	
	

	return User::create([
		'name' => $input['name'],
		'email' => $input['email'],
		'password' => Hash::make($input['password']),
	]);
}


'password' => $this->passwordRules(), اشاره دارد به  فایل 

PasswordValidationRules.php 

in  PasswordValidationRules.php  

		==> return ['required', 'string', new Password, 'confirmed'];

confirmed ==> یعنی  با تکرار رمز عبور برابر باشد 



می توانیم به  بخش ساخت کاربر یا  اعتبار سنجی اگر چیزی می خواهیم اضافه کنیم 

return User::create([
	'name' => $input['name'],
	'email' => $input['email'],
	'is_admin' => 0,
	'password' => Hash::make($input['password']),
]);



---------------------------------------------------session 120 (156)

اضافه کردن   
username
به جای ایمیل برای ورود کاربر 


ابتدا به فایل مایگریشن یک فیلد دیگر اضافه می کنیم به اسم 
username

public function up()
{
	Schema::create('users', function (Blueprint $table) {
		$table->id();
		$table->string('name');
		$table->string('username')->unique();
		$table->string('email')->unique();
		$table->timestamp('email_verified_at')->nullable();
		$table->string('password');
		$table->rememberToken();
		$table->timestamps();
	});
}

یا باید یک مایگریت جدید برای اضافه کردن این فیلد ایجاد کنیم 


حالا در  بلید  اینپوت مورد تظر را به ریجستر اضافه می کنیم 

<div class="form-group row">
	<label for="username" class="col-md-4 col-form-label text-md-right">{{ __('Username') }}</label>

	<div class="col-md-6">
		<input id="username" type="text" class="form-control @error('username') is-invalid @enderror"
			name="username" value="{{ old('username') }}" required autocomplete="username" autofocus>

		@error('username')
		<span class="invalid-feedback" role="alert">
			<strong>{{ $message }}</strong>
		</span>
		@enderror
	</div>
</div>


حالا زمانی که روی دکمه رجیستر می زنیم فایل 

Create Name

فراخوانی می شود 

Validator::make($input, [
'name' => ['required', 'string', 'max:255'],
'email' => [
	'required',
	'string',
	'email',
	'max:255',
	Rule::unique(User::class),
],


'username' => [
	'required',
	'string',
	'max:255',
	Rule::unique(User::class , 'username'),
	//Rule::unique(User::class , 'column name'),
	//'unique:users'   ==> روش دوم برای  اعتبار سنجی یونیک بودن 
	
],


'password' => $this->passwordRules(),
])->validate();





حالا 


return User::create([
	'name' => $input['name'],
	'username' => $input['username'],
	'email' => $input['email'],
	'password' => Hash::make($input['password']),
]);



حالا در مدل 

protected $fillable = [
	'name',
	'email',
	'username',
	'password',
];




حالا برای لاگین با 
username

in  blade view


<div class="form-group row">
	<label for="username"
		class="col-md-4 col-form-label text-md-right">{{ __('Username') }}</label>

	<div class="col-md-6">
		<input id="username" type="username" class="form-control @error('username') is-invalid @enderror"
			name="username" value="{{ old('username') }}" required autocomplete="username" autofocus>

		@error('username')
		<span class="invalid-feedback" role="alert">
			<strong>{{ $message }}</strong>
		</span>
		@enderror
	</div>
</div>



حالا باید به 
fortify
بفهمانیم که ما می خواهیم کاربر با کدام فیلد لاگین کند 

in config folder  / fortify

'username' => 'email',  ==>'username' => 'username',



---------------------------------------------------session 121 (157)

ایجاد رمز عبور خیلی ایمن در پکیج
fortify


پسورد باید شامل حروف کوچک و بزرگ باشد و همچنین شامل اعداد
شامل کاراکترهای حاص باشد 
ما می خواهیم این را پیاده سازی کنیم 


in app  / fortify / actions / PasswordValidationRules


 rotected function passwordRules()
{
	return ['required', 'string', new Password, 'confirmed'];
}

این متود در تمامی فایل های دیگر مربوط به فورتی فای  صدا زده شده است و به راحتی می توانیم از آن استفاده کنیم


اگر بخواهیم پسورد سامل اعداد باشد به روش زیر عمل می کنیم 

protected function passwordRules()
{
	return ['required', 'string', (new Password)->requireNumeric(), 'confirmed'];
}




روش زیر می گوید که پسور باید شامل اعداد و جروف کوچک و بزرگ باشد 

protected function passwordRules()
{
	return ['required', 'string', 
	(new Password)
	
	->requireNumeric()
	->requireUppercase()
	
	, 'confirmed'];
}


روش زیر میگه که علاوه بر موارد قبلی شامل کاراکترهای خاص هم باشد 

protected function passwordRules()
{
	return ['required', 'string', 
	(new Password)
	->requireNumeric()
	->requireUppercase()
	->requireSpecialCharacter()
	, 'confirmed'];
}


بار روش زیر هم می توانیم طول پسورد را تعیین کنیم 


protected function passwordRules()
{
	return ['required', 'string',
	(new Password)
	->requireNumeric()
	->requireUppercase()
	->requireSpecialCharacter()
	->length(10)
	, 'confirmed'];
}






-------------------------------------------------------- note
برای ریدارکت همه روت ها به یک بلید می توانیم از روش زیر استفاده کینم 

Route::get('/{path?}', function ($basepath='') {
    return view('welcome');
});





---------------------------------------------------------------session 3


در هنگام استفاده از ویو به همراه لاراول ممکن است به ارور هایی
throw-er-unhandled-error-event
برخورد کنید برای حل این مشکل روش زیر را اعمال  میکنیم 

1. delete node_modules folder
2. delete package-lock.json

3. in project folder    npm cache clear --force
4.npm install
5. npm run dev


== use Vue 3 in laravel



== in resource/js/app.js


import './bootstrap';

import { createApp } from 'vue';
import App from './components/App.vue'
createApp(App).mount("#app");




in resource/js/bootstrap.js



import axios from "axios";

window.axios = axios;

window.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';




in webpack.mix.js

const mix = require('laravel-mix');


mix.js('resources/js/app.js', 'public/js')
    .vue()
    .sass('resources/sass/app.scss', 'public/css');


in blade file

<div id="app"></div>
					
<script src="/js/app.js"></script>


in cmd  npm run serve  or watch





== use axios in Vue and laravel


in web.php (Routes)

Route::get('/user', function () {
    return ['ali',"hesam",'reza','ali',"hesam",'reza'];
});


in vue Component

<template>
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header">Example Component Ali</div>

                    <div class="card-body">
                     
                        <h2>Users</h2>
                        <ul>
                            <li v-for="user in users">{{user}} 12</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
</template>

<script>
    export default{
        data(){
            return{
                users:[]
            }
        },
        mounted(){
            axios.get('/user')
            .then(response => this.users = response.data)
            .catch(error => console.log(error));
        }
    }

</script>



---------------------------------------------------------------session 3x

برای ارسال اطلاعات از  بلید های لاراول به  ویو می توانید از روش زیر استفاده کنید 


in blade

<script>
	window.nameAli = {};
	window.nameAli.Auth = "{{ Auth::check() }}" == '' ? false : true;
	window.nameAli.csrf = "{{ csrf_token() }}";
</script>


in component 

data(){
	return{
		auth:false,
	}
},

created(){
	console.log(window.nameAli);
	console.log(nameAli);
	console.log(nameAli.Auth);
	
	this.auth = nameAli.Auth;
}





---------------------------------------------------------------session 4
//database && migration

migration ---> سیستم قدرتمند لاراول برای کنترل دیتابیش
---> به ما کمک می کند که وقتی پروژه بزرگ است اطلاعات را کامل به برنامه نویس دیگری قرار ندهیم


---> کانکشن به دیتابیس ---> config folder ---> database.php

اما برای امنیت بیشتر به فایل  .env
می رویم و اطلاعات کانکشن را آنجا شت می کنیم

---> in .env  ---> دنبال قسمت زیر برای ست کردن باشید

ابتدا در php my admin دیتابیس مورد نظر را ایجاد و بعد اطلاعات را وارد قسمت زیر کنید

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=root
DB_PASSWORD=


---->migration --->  کلاس هایی هستند که یک فانکشن 
				----> up & down   دارند

--> up  ---> for Create my DB


######### for ceate migration
terminal --> php artisan help migrate ---> در این حالت مایگیرت اجرا نمی شود و یک راهنما برای استفاده به ما می دهد

terminal --> php artisan help make ---> راهما برای ساخت بخش های مختلف


terminal --> php artisan migrate ---> تمام توابع موجود در فایل های پوشه مایگریت را ران می کند
---> دو ارور هم ایجاد می شود که برای جلوگیری از آنها (max key length is 1000 bytes)
--> go to  App folder ---> providers  ---> appServiceProviders.php
--> in public function boot() ---> 
public function boot(){
	Schema::defaultStringLength('191');
}

بعد از این کار حتما به دیتابیس بروید و table 
های ایجاد شده را حذف کنید

terminal --> php artisan migrate // دیگه ارور نباید باشد و خودش در دیتابیس 3 تیبل ساخته شود

#### Create migration new
terminal --> php artisan make:migration create_posts_table
زمانی که دستور را  اجرا کریدم در داخل پوشه migration
یک فایل جدید با همی نامی که زدیم  --> create_posts_table
ایجاد شده است

فایل ایجاد شده تنها فانکشن آپ و دون دارد پس ما فایل های دیگر را باز کرده و تکه زیر را برای آپ کپی کرده و داخل آپ پیس می دهیم و بعد 
آن را اصلاح می کنیم

Schema::create('posts', function (Blueprint $table) {
            $table->id();
            $table->string('title');
            $table->text('text');
            
        });

terminal --> php artisan migrate
--> تیبل post فیلدهای بالا ایجاد شده است

### change prev migrate for add  ستون جدید

Schema::create('posts', function (Blueprint $table) {
	$table->id();
	$table->string('title');
	
	$table->text('new');// مثال این را اضافه کردیم
	
	$table->text('text');
	
});

// ابتدا باید table post را پاک کنید
terminal --> php artisan migrate::refresh




-----------------------------------------------------session 5


Views ---> resource folder -->view folder

لایه بندی در لاراول
// layout in laravel

in view folder --> create a folder   --> ترجیحا با نام   - ---> layout

in layout ---> main.blade.php  ---> تمام قسمت هایی که ثابت هستند را داخل این 
منظور از ثابت بودن قسمت های ثابت قالب مثل هدر و فوتر یا بخش های ثابت دیگر است

--> paste می دهیم
بعد در داخل مثلا
post.blade.php  --> همچی را پاک کی کنیم و می نویسیم

@extends("layout/main") --->false
@extends("layout.main") -->true  /// در لاراول به جای اسلش از دات(.) استفاد می شود  

به جای قسمت متغییر  --> @yield('content') // or نام دیگر دلخواه به جای کانتنت 

NOW
in post page --->
@section('content')  // name should similar with @yield

@endsection

********
بی نهایت از این   --> yield  ها می توانیم بگذاریم

مثال

@section('link')  // name should similar with @yield
	<a>linksssssss</a>
@endsection


---------------------------------------------------session 6

app -> http -> controller  --> محل کنترلرها

##########  Create Controller

terminal --> php artisan make:controller PostsController  --> enter
// اسم کنترل بعتر است به شکل جمع 
// باشد اما اسم مدل و ویو مفرد بهتر است

// بعد از اینتر باید در کنترلر باید فایل کنترل ایجاد شده باشد

// in new controller file
class PostsController extends Controller{
   public function index(){
	   // other Code
	   return view('post');
   }
}
############################################
فراخوانی کنترل
in web.php  in route folder

Route::get("/post",PostsController@index); ---> یعنی برو تو پست کنترلر و 
public function index   رو فراخوانی کن 


Route::get("/posts/add",PostsController@store);  

// in new controller file
class PostsController extends Controller{
   public function index(){
	   // other Code
	   return view('posts'); فایل پست را از ویوها می خواند
   }
   
   public function store(){
	   // other Code
	   return view('post.add'); // فایل اد را از داخل پوشه post  می خواند
   }
}


----------------------------------------------------------- session 7

// Query Bilder

in terminal  ---> php artisan serve

//web.php
Route::get('/user', function(){
	$users=DB::table('table name')->get();
	return view('users',compact('users');
});

in view --> create users.blade.php

@extends("layout.main")

@section('content')  
	@foreach($users as $user)
	
		<li>{{$user->name}} Email : {{$user->email}}</li>
	
	@endforeach
@endsection

// می توانیم برای 
//Query bilder
ها سرط هم بگذاریم

Route::get('/user', function(){
	$users=DB::table('table name')->where('name','ali')->first();
	$users=DB::table('table name')->where('name','ali')->value('email');
	$users=DB::table('table name')->pulk('name','email');// ستون
	return view('users',compact('users');
});

// روش   query bilders   
// روش خوبی است اما روش بهتری هم وجود دارد که بیشتر از آن استفاده می شود به نام
// Eloquent ORM


------------------------------------------------------------session 8

//forms

in add2.blade.php 

<form action="" method="post">
{{csrf_field()}} <!----ایجاد توکن برای جلوگیری از حملات csrf-- بدون این ارور توکن میس مچ می دهد-->
	name : <input type="text" name="name">
	email : <input type="email" name="email">
	password : <input type="password" name="password">
	<input type="submit" name="adduser">
</form>


in web.php

//اگر اطلاعات با متود  پست ارسال شود ماهم باید برای روتر از پست استفاده کنیم

Route::post('/post/add2', "postsController@add");

'/post/add2'  --- > این را داخل اکشن فرد قرار می دهیم

<form action="/post/add2" method="post">
{{csrf_field()}} <!----ایجاد توکن برای جلوگیری از حملات csrf-- بدون این ارور توکن میس مچ می دهد-->
	name : <input type="text" name="name">
	email : <input type="email" name="email">
	password : <input type="password" name="password">
	<input type="submit" name="adduser">
</form>


in postsController.php and class postsController

public function add(Request $request){
	return request()->all();  /// همه اطلاعات را به صورت جیسون برمی گردازند
	return $request->all();  /// روش دوم
}

--------------------------------------------------------- session 9
terminal --> php artisan make:model Post  //create model



in terminal ---> php artisan make:model Article -m -c // create  model && migration && controller

// حالا همه موارد ساخته شده اند
 now in article migration
 
 // اطلاعات مورد نظر خودم را وارد می کنم
 
 Schema::create('articles', function (Blueprint $table) {
            $table->increments('id');
            $table->string('title');
            $table->text('demo');
            $table->text('text');
            $table->timestanps();
        });
		
		
in terminal php article migrate:refresh

----------------
in view  create article.blade.php


in web.php //routes

// Articles
Route::get('/article', 'ArticleController@index');
Route::get('/article/add', 'ArticleController@add');
Route::get('/article/new', 'ArticleController@store'); 


روش اول  --> Query Bilder

in ArticleController  and index method

$article=DB::table('articles')->get();
return view('article.index',compact('articles');

// روش دوم  --> Eloquent
$article=Article::get();  // ---> model  هم باید اد شود  --> use App\Article 
return view('article.index',compact('articles');


---------------------------------------------session 10

add dates to DB

in views   article  add.blade.php

<form action="/article/new" method="post">
{{csrf_field()}} <!---- ایجاد توکن برای جلوگیری از حملات csrf-- بدون این ارور توکن میس مچ می دهد-->
	title : <input type="text" name="title">
	demo : <input type="email" name="demo">
	text : <input type="text" name="text">
	<input type="submit" name="add user">
</form>

in ArticleController

public function store(Request $request){
	   // other Code
	   //return $request->all(); // برای دیدن اطلاعات ارسال شده
	   //return view('post.add'); // فایل اد را از داخل پوشه post  می خواند
	   Article::create({
		   'title'=>$request['title'];
		   'demo'=>$request['demo'];
		   'text'=>$request['text'];
	   });
   }
   
 // برای جلوگیری از ورود اطلاعات بیهوده توسط هکر باید در لاراول در مدل بگوییم که چه فیلدهایی می خواهیم پر شوند
 
 in Article  in models

protected $fillable = [
        'title' , 'demo', 'text'
    ];

--------------------------------------------------- session 11








/* ==============================================================
	
					PDF

======================================================================*/

Create pdf in laravel

اول کتابخانه 
mpdf
را نصب می کنیم 

composer require mpdf/mpdf


از 
2 
کتابخانه می توانیم استفاده کنیم 

1. dompdf
2.mpdf  ==> best 


https://github.com/mccarlosen/laravel-mpdf      

							==> راهنما در گیت هاب

https://mpdf.github.io/installation-setup/installation-v7-x.html

							===> سایت اصلی 









composer require carlos-meneses/laravel-mpdf


حالا چک می کنیم که به کامپوزر اضافه شده باشد 

"require": {
	carlos-meneses/laravel-mpdf: "2.1.6"
}



in    config/app.php


'providers' => [
	// ...
	Meneses\LaravelMpdf\LaravelMpdfServiceProvider::class
]

همچنین که نام مستعار برای 
fecad
برای آن انتخاب می کنیم 

'aliases' => [
	// ...
	'PDF' => Meneses\LaravelMpdf\Facades\LaravelMpdf::class
]




in Controller

//....
use PDF;
class ReportController extends Controller {
	
	
	public function index(Request $request){
		
		$users = ['ali','reza','علی'];

        if ($request->has('type')) {
            if ($request->get('type') == 'pdf') {
				
                $pdfFile = PDF::loadView('pdff.users-pdf', compact('users'), [], [
				  'title' => 'Another Title',
				  'margin_top' => 10,
				  'margin_bottom' => 10,
				  'margin_header' => 5,
				  'margin_footer'  => 5,
				]);
				
                return $pdfFile->stream('users-list.pdf');
            }
        }

        return view('pdff.index', compact('users'));
	}
	
}


حالا ویوها را همراه روت ایجاد می کنیم 





حالا یک فایل می سازیم و تنظیمات را در آن قرار می دهیم 

config/pdf.php


return [
	'mode'                 => 'utf-8',
	'format'               => 'A4',
	'default_font_size'    => '12',
	'default_font'         => 'sans-serif',
	'margin_left'          => 10,
	'margin_right'         => 10,
	'margin_top'           => 10,
	'margin_bottom'        => 10,
	'margin_header'        => 0,
	'margin_footer'        => 0,
	'orientation'          => 'P',
	'title'                => 'Laravel mPDF',
	'author'               => '',
	'watermark'            => '',
	'show_watermark'       => false,
	'watermark_font'       => 'sans-serif',
	'display_mode'         => 'fullpage',
	'watermark_text_alpha' => 0.1,
	'custom_font_dir'      => '',
	'custom_font_data' 	   => [],
	'auto_language_detection'  => false,
	'temp_dir'               => rtrim(sys_get_temp_dir(), DIRECTORY_SEPARATOR),
	'pdfa' 			=> false,
        'pdfaauto' 		=> false,
];


همچنین می توانیم تنظیمات را در خود کنترلر هم قرار دهیم 

PDF::loadView('pdf', $data, [], [
  'title' => 'Another Title',
  'margin_top' => 0
])->save($pdfFilePath);







in /config/pdf.php

return [
	'custom_font_dir' => base_path('resources/fonts/'), // don't forget the trailing slash!
	'custom_font_data' => [
		'examplefont' => [
			'R'  => 'ExampleFont-Regular.ttf',    // regular font
			'B'  => 'ExampleFont-Bold.ttf',       // optional: bold font
			'I'  => 'ExampleFont-Italic.ttf',     // optional: italic font
			'BI' => 'ExampleFont-Bold-Italic.ttf' // optional: bold-italic font
			'useOTL' => 0xFF,
			'useKashida' => 75,
		]
		// ...add as many as you want.
	]
];



body {
	font-family: 'examplefont', sans-serif;
}

or 
<div style="font-family:'sahel', sans-serif; direcrtion:rtl; text-align:right;">علی </div>



در فونت های فارسی 
 'useOTL' => 0xFF,
    'useKashida' => 75,
	
الزامی هستند 






use PDF;

$pdf = PDF::loadView('pdf.document', $data);
$pdf->getMpdf()->AddPage(...);




زمانی که سند 
html
بزرگ است برای این که ارور دریافت نکنیم می توانیم به روش زیر عمل کنیم 

//....
use PDF;
class ReportController extends Controller {
	public function generate_pdf()
	{
		$data = [
			'foo' => 'hello 1',
            'bar' => 'hello 2'
		];
		$pdf = PDF::chunkLoadView('<html-separator/>', 'pdf.document', $data);
		return $pdf->stream('document.pdf');
	}
}




<div>
    <h1>Hello World</h1>
    <table>
        <tr><td>{{ $foo }}</td></tr>
    </table>
    <html-separator/>
    <table>
        <tr><td>{{ $bar }}</td></tr>
    </table>
    <html-separator/>
</div>





برای 
header and footer

<style>
	body {
		font-family: sans-serif;
	}
	
	@page {
		header: firstpage;
		footer: otherpages;
	}
</style>



<body>

<htmlpageheader name="firstpage" style="display:none">
    <div style="text-align:center">First Page {DATE j-m-Y}</div>
</htmlpageheader>

<htmlpagefooter name="otherpages">
	<div width="100%" style="vertical-align: bottom; font-family: serif; font-size: 8pt; color: #000000; font-weight: bold; font-style: italic; text-align:center; margin-bottom:6px;">
	@php $page = 1  @endphp
	<div style="@if($page == 2) display:none;  @endif">
	<br><br><br>
		Laravel has wonderful, thorough documentation covering every aspect of the framework.
		Whether you are new to the framework or have previous experience with Laravel, we recommend
		reading all of the documentation from beginning to end.
		<hr>
		
	</div>
        <span style="font-weight: bold; font-style: italic;">{PAGENO}/{nbpg}</span>
           
    </div>
</htmlpagefooter>


<sethtmlpageheader name="firstpage" value="on" show-this-page="1" />
<sethtmlpagefooter name="otherpages" value="on" />




<table style="rotate:90|-90;">

<table style="autosize:1;">



{PAGENO}  شماره صفحه 

{nbpg}   تعداد کل صفحات 

{DATE j-m-Y}	  تاریخ 


<pagebreak />
<tocpagebreak>
رفتن به صفحه بعد 
	
	/* ==============================================================
	
					End PDF

======================================================================*/








/* ==============================================================
	
					Shop

======================================================================*/
اولین کاری که برای ایجاد یک وبسایت نیاز است  تحلیل دیتابیس است

به فیلدی که می خواهیم در 
url
قرار دهیم به جای ایدی برای رفتن به صفحه محصول یا  
...
اسلاگ می گوییم
slug

همیشه لازم نیست لاراول را روی پورت
8000
بالا بیاریم ما می توانیم این پورت راه هم خودمان تعیین کنیم

php artisan serve  --port=8001




%%%%%  %%%%   Migrations  

ترتیب ایجاد و کلید های خارجی مهم است. 
باید مواردی که کلید خارجی دارند را بعد از جدولی که کلید خارجی به آن وصل می شود ایجاد کنید




***  Users
Schema::create('users', function (Blueprint $table) {
	$table->id();
	$table->string('name');
	$table->string('email')->unique();
	$table->string('cellphone');
	$table->string('avatar');  ///img
	$table->string('provider'); // login type(google/facebook/handle/....)
	$table->integer('status')->default(1);  // user status (active/block/...)
	$table->timestamp('email_verified_at')->nullable();
	$table->string('password');
	$table->rememberToken();
	$table->timestamps();
});


***  categories

Schema::create('categories', function (Blueprint $table) {
	$table->id();
	$table->string('name');
	$table->string('slug')->unique()->nullable();
	$table->text('description')->nullable();
	$table->boolean('is_active')->default(1);
	$table->string('icon')->nullable();
	$table->timestamps();
});


*** brands
Schema::create('brands', function (Blueprint $table) {
	$table->id();
	$table->string('name');
	$table->string('slug')->unique()->nullable();
	$table->boolean('is_active')->default(1);
	$table->timestamps();
});


****products

Schema::create('products', function (Blueprint $table) {
	$table->id();
	$table->string('name');
	$table->string('slug')->unique();
	$table->string('primary_image');   // تصویر اصلی 

	$table->integer('status')->default(1);
	$table->boolean('is_active')->default(1);


	$table->unsignedInteger('delivery_amount')->default(0);  //  هزینه ارسال
	$table->unsignedInteger('delivery_amount_per_product')->nullable();  // هزینه ارسال به ازای هر محصول اضافی

	$table->foreignId('brand_id');
	$table->foreign('brand_id')->references('id')->on('brands')->onDelete('cascade');
	
	$table->foreignId('category_id');
	$table->foreign('category_id')->references('id')->on('categories')->onDelete('cascade');
	
	$table->text('description');

	$table->timestamps();
});

unsignedInteger  --> یعنی تنها اعداد مثبت   --> در ایران این را ما  استرینگ یا  همین قرار می دهیم اما
										استاندارد در کشورهای دیگر که واحد دلا است 
										decimal
										قرار می دهند که اعداد اعشاری را هم شامل شود


***products_images

Schema::create('products_images', function (Blueprint $table) {
    $table->id();

	$table->string('image');

	$table->foreignId('product_id');
	$table->foreign('product_id')->references('id')->on('products')->onDelete('cascade');
	
	$table->timestamps();
});


***tags

Schema::create('tags', function (Blueprint $table) {
	$table->id();
	$table->string('name');
	$table->timestamps();
});

 ***product_tag  --> جدول رابط  --> چون زابط است می توانیم برایش ستون ایدی قرار ندهیم
 
Schema::create('product_tag', function (Blueprint $table) {
	//$table->id();  // نباید قرار دهیم وگرنه ارور می دهد
	//چون جلوتر ما 
	//primary ست کرددیم
	
	$table->foreignId('tag_id');
	$table->foreign('tag_id')->references('id')->on('tags')->onDelete('cascade');

	$table->foreignId('product_id');
	$table->foreign('product_id')->references('id')->on('products')->onDelete('cascade');
	$table->primary(['tag_id' , 'product_id']);
	$table->timestamps();
});



***comments

توی هیچ وبسایتی چیزی را به طور کامل از دیتابیس حذف نکنید و اگر خواستید چیزی را حذف کنید 
soft delete
انجام دهیم

Schema::create('comments', function (Blueprint $table) {
	$table->id();

	$table->foreignId('product_id');
	$table->foreign('product_id')->references('id')->on('products')->onDelete('cascade');

	$table->foreignId('user_id');
	$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

	$table->boolean('approved')->default(0);  // for confirm by admin
	$table->text('text');

	$table->softDeletes();

	$table->timestamps();
});


*** product_rates  // امتیازدهی

Schema::create('product_rates', function (Blueprint $table) {
	$table->id();

	$table->foreignId('product_id');
	$table->foreign('product_id')->references('id')->on('products')->onDelete('cascade');

	$table->foreignId('user_id');
	$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

	$table->tinyInteger('rate');  // for small number

	$table->timestamps();
});


**** attributes

Schema::create('attributes', function (Blueprint $table) {
	$table->id();
	$table->string('name');
	$table->timestamps();
});


****   attribute_category  --> رابط

Schema::create('attribute_category', function (Blueprint $table) {
//$table->id();

	$table->foreignId('attribute_id');
	$table->foreign('attribute_id')->references('id')->on('attributes')->onDelete('cascade');


	$table->foreignId('category_id');
	$table->foreign('category_id')->references('id')->on('categories')->onDelete('cascade');

	$table->boolean('is_filter')->default();
	$table->boolean('is_variation')->default();

	$table->primary(['attribute_id' , 'category_id']);

	$table->timestamps();
});


*** product_attributes

Schema::create('product_attributes', function (Blueprint $table) {
	$table->id();

	$table->string('value');
	$table->boolean('is_active')->default(1);


	$table->foreignId('product_id');
	$table->foreign('product_id')->references('id')->on('products')->onDelete('cascade');

	$table->foreignId('attribute_id');
	$table->foreign('attribute_id')->references('id')->on('attributes')->onDelete('cascade');


	$table->timestamps();
});



***product_variations

Schema::create('product_variations', function (Blueprint $table) {
	$table->id();


	$table->foreignId('attribute_id');
	$table->foreign('attribute_id')->references('id')->on('attributes')->onDelete('cascade');

	$table->foreignId('product_id');
	$table->foreign('product_id')->references('id')->on('products')->onDelete('cascade');

	$table->string('value');
	$table->unsignedInteger('price')->default(0);
	$table->string('sku')->nullable();   // شناسه انبار

	$table->unsignedInteger('sale_price')->nullable(); // takhfif

	$table->timestamp('date_on_sale_from')->nullable();
	$table->timestamp('date_on_sale_to')->nullable();


	$table->timestamps();
});


*** provinces

Schema::create('provinces', function (Blueprint $table) {
	$table->id();

	$table->string('name');

	$table->timestamps();
});


*** cities

Schema::create('cities', function (Blueprint $table) {
	$table->id();
	$table->string('name');

	$table->foreignId('province_id');
	$table->foreign('province_id')->references('id')->on('provinces')->onDelete('cascade');


	$table->timestamps();
});


*** user_addresses

Schema::create('user_addresses', function (Blueprint $table) {
	$table->id();

	$table->string('title');
	$table->string('address');
	$table->string('cellphone');
	$table->string('postal_code');

	$table->foreignId('user_id');
	$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

	$table->bigInteger('province_id');
	$table->bigInteger('city_id');

	$table->string('longitude')->nullable(); // طول جغرافیایی
	$table->string('latitude')->nullable();  // عرض جغرافیایی

	$table->timestamps();
});


***coupons


enum  ---> نوعی  ستون است که تنها می تواند مقادیر  دیفالتی که برای آن تعیین کردیم را دریافت کند و 
			مقدار دیگری را دریافت نمی کند
			

Schema::create('coupons', function (Blueprint $table) {
	$table->id();

	$table->string('name');
	$table->string('code');
	$table->string('code');

	$table->enum('type' , ['amount' , 'percentage']);

	$table->unsignedInteger('amount')->nullable();
	$table->unsignedInteger('percentage')->nullable();
	$table->unsignedInteger('max_percentage_amount')->nullable(); 
	// تعیین ماگزیمم برای تخفیف مثلا پنجاه درصد تخفیف تا سقف بیست هزار تومان

	$table->timestamp('expire_at');

	$table->text('description')->nullable();

	$table->timestamps();
});


** orders

Schema::create('orders', function (Blueprint $table) {
	$table->id();

	$table->foreignId('user_id');
	$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

	$table->foreignId('address_id');
	$table->foreign('address_id')->references('id')->on('user_addresses')->onDelete('cascade');

	$table->foreignId('coupon_id')->nullable();
	$table->foreign('coupon_id')->references('id')->on('coupons')->onDelete('cascade');

	$table->tinyInteger('status')->default(0);
	$table->unsignedInteger('total_amount');
	$table->unsignedInteger('delivery_amount')->default(0); // هزینه ارسال
	$table->unsignedInteger('coupon_amount')->default(0);  
	$table->unsignedInteger('pay_amount')->default(0);   /// مبلغ نهایی

	$table->enum('peyment_type' , ['pos' , 'cash' , 'shabaNumber' , 'cardToCard' , 'online']);
	$table->tinyInteger('payment_status')->default(0);

	$table->text('description')->nullable();

	$table->timestamps();
});



*** order_items

Schema::create('order_items', function (Blueprint $table) {
	$table->id();

	$table->foreignId('order_id')->nullable();
	$table->foreign('order_id')->references('id')->on('orders')->onDelete('cascade');

	$table->foreignId('product_id')->nullable();
	$table->foreign('product_id')->references('id')->on('products')->onDelete('cascade');

	$table->foreignId('product_variation_id')->nullable();
	$table->foreign('product_variation_id')->references('id')->on('product_variations')->onDelete('cascade');

	$table->unsignedInteger('price');
	$table->unsignedInteger('quantity');
	$table->unsignedInteger('subtotal');

	$table->timestamps();
});



***transactions

Schema::create('transactions', function (Blueprint $table) {
	$table->id();

	$table->foreignId('user_id')->nullable();
	$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

	$table->foreignId('order_id')->nullable();
	$table->foreign('order_id')->references('id')->on('orders')->onDelete('cascade');

	$table->unsignedInteger('amount');
	$table->string('ref_id')->nullable();
	$table->string('token')->nullable();

	$table->enum('gateway_name' , ['zarinpal' , 'pay']);

	$table->tinyInteger('status')->default(0);

	$table->text('description')->nullable();

	$table->timestamps();
});


****** whishlist

Schema::create('whishlist', function (Blueprint $table) {
	//$table->id();

	$table->foreignId('user_id')->nullable();
	$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

	$table->foreignId('product_id')->nullable();
	$table->foreign('product_id')->references('id')->on('products')->onDelete('cascade');

	$table->primary(['user_id' , 'product_id']);

	$table->timestamps();
});
	
	
*** banners

Schema::create('banners', function (Blueprint $table) {
	$table->id();

	$table->string('title')->nullable();
	$table->string('image');
	$table->string('text')->nullable();
	$table->integer('priority')->nullable(); // ترتیب
	$table->boolean('is_active')->default();
	$table->string('type');
	$table->string('button_text')->nullable();
	$table->string('button_link')->nullable();
	$table->string('button_icon')->nullable();

	$table->timestamps();
});	
	


*** contact_us

Schema::create('contact_us', function (Blueprint $table) {
	$table->id();

	$table->string('name');
	$table->string('email');
	$table->string('subject');
	$table->text('text');

	$table->timestamps();
});	

	
*** settings

Schema::create('settings', function (Blueprint $table) {
	$table->id();

	$table->string('address');
	$table->string('telephone');
	$table->string('telephone')->nullable();
	$table->string('longitude')->nullable();
	$table->string('letitude')->nullable();
	$table->string('instagram')->nullable();
	$table->string('telegram')->nullable();
	$table->string('facebook')->nullable();
	$table->string('tweeter')->nullable();

	$table->timestamps();
});	

	
now create  database  and set .env   and set timezone in  config/app.php (UTC --> Asia/Tehran)


and run php artisan migrate	

اگر ارور داشتیم بعد از رفع آن از دستور زیر استفاده می کنیم

php artisan migrate:fresh		
	
	
/*****

 Create Admin  Panel

***/	

bootstrap-bundle == bootstrap.js + popper.js

npm i 

ابتدا نصب بوت استرپ

npm i bootstrap@4.5.0
	
حالا در پوشه 
rsource  --> create scss folder

قرار دادن فایل های 
sccss
در این پوشه 

@import "~bootstrap/scss/bootstrap.scss";
صدا زدن بوت استرپ از 
node_modules

~ --> tilda --> اشاره به  نود ماژولز  پوشه 

باید قبل از کامپایل 
sass  and  sass loader
را هم نصب کنیم

اگر تصویر برای پس زمینه در 
css
استفاده کردیم باید آن ها را دقیق ادرس دهی کنیم و گرنه در هنگام کامپایل به ارور می خوریم


اگر ادرس دهی فایل های اشتباه باشد به ما ارور می دهید  مثل  تصاویر یا فونت 

ERROR in ./resources/scss/admin/admin.scss
Module build failed (from ./node_modules/mini-css-extract-plugin/dist/loader.js):
ModuleBuildError: Module build failed (from ./node_modules/css-loader/dist/cjs.js):
Error: Can't resolve '../fonts/Vazir.eot' in 'C:\Users\HomaRayaneh\Desktop\Lshop\resources\scss\admin''

این ارور می گه که فایل فونت به درستی ادرس دهی نشده است 

برای کامپایل 
scss
mix.sass('resources/scss/admin/admin.scss', 'public/css/admin');

npm run dev

اضافه کردن فایل جاوااسکریپت

ترتیب 
import
فایل های جاوااسکریپت مهم است

برای گلوبال کردن یک کتابخانه آن را در 
window
می ریزیم

window.$ = window.jQuery =  require('jquery');

mix.js('resources/js/admin/admin.js', 'public/js');
    .sass('resources/scss/admin/admin.scss', 'public/css/admin');

npm run dev  ==> الان جاوااسکریپت را کامپایل می کند 


	
اضافه کردن  فونت  
Awesome

@import "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css";

in admin.scss

هنگام کامپایل باید اینترنت وصل باشد 


بعد از کامپایل کردن  نوبت این است که صفحه بندی ها را انجام دهیم 


php artisan make:model Brands -cr   // ایجاد مدل و کنترلر باهم  --> کنترلر ریسورس

	
پکیجی که کار با 
slug
رو برای ما ساده تر می کند 

eloquent-sluggable

https://github.com/cviebrock/eloquent-sluggable

این پکیج فارسی را هم ساپورت می کند
composer require cviebrock/eloquent-sluggable

php artisan vendor:publish --provider="Cviebrock\EloquentSluggable\ServiceProvider"


use Cviebrock\EloquentSluggable\Sluggable;

class Post extends Model
{
    use Sluggable;

    /**
     * Return the sluggable configuration array for this model.
     *
     * @return array
     */
    public function sluggable(): array
    {
        return [
            'slug' => [  // اسم فیلد اسلاگ را می گیرد
                'source' => 'title'   // می پرسد که اسلاگ را از روی  محتوای کدام ستون بسازم
            ]
        ];
    }
}



برای انیکه این پکیج فارسی را بهتر ساپورت کند باید فایل 
config/ sluggable.php
را تغییر دهیم و کدهای زیر را داخل آن قرا ر دهیم


<?php

return [

    /**
     * What attributes do we use to build the slug?
     * This can be a single field, like "name" which will build a slug from:
     *
     *     $model->name;
     *
     * Or it can be an array of fields, like ("name", "company"), which builds a slug from:
     *
     *     $model->name . ' ' . $model->company;
     *
     * If you've defined custom getters in your model, you can use those too,
     * since Eloquent will call them when you request a custom attribute.
     *
     * Defaults to null, which uses the toString() method on your model.
     */

    'source' => null,

    /**
     * The maximum length of a generated slug.  Defaults to "null", which means
     * no length restrictions are enforced.  Set it to a positive integer if you
     * want to make sure your slugs aren't too long.
     */

    'maxLength' => null,

    /**
     * If left to "null", then use the cocur/slugify package to generate the slug
     * (with the separator defined below).
     *
     * Set this to a closure that accepts two parameters (string and separator)
     * to define a custom slugger.  e.g.:
     *
     *    'method' => function( $string, $sep ) {
     *       return preg_replace('/[^a-z]+/i', $sep, $string);
     *    },
     *
     * Otherwise, this will be treated as a callable to be used.  e.g.:
     *
     *    'method' => array('Str','slug'),
     */

    'method' => function($string, $separator = '-') {
        $_transliteration = ["/ö|œ/" => "e",
            "/ü/" => "e",
            "/Ä/" => "e",
            "/Ü/" => "e",
            "/Ö/" => "e",
            "/À|Á|Â|Ã|Å|Ǻ|Ā|Ă|Ą|Ǎ/" => "",
            "/à|á|â|ã|å|ǻ|ā|ă|ą|ǎ|ª/" => "",
            "/Ç|Ć|Ĉ|Ċ|Č/" => "",
            "/ç|ć|ĉ|ċ|č/" => "",
            "/Ð|Ď|Đ/" => "",
            "/ð|ď|đ/" => "",
            "/È|É|Ê|Ë|Ē|Ĕ|Ė|Ę|Ě/" => "",
            "/è|é|ê|ë|ē|ĕ|ė|ę|ě/" => "",
            "/Ĝ|Ğ|Ġ|Ģ/" => "",
            "/ĝ|ğ|ġ|ģ/" => "",
            "/Ĥ|Ħ/" => "",
            "/ĥ|ħ/" => "",
            "/Ì|Í|Î|Ï|Ĩ|Ī| Ĭ|Ǐ|Į|İ/" => "",
            "/ì|í|î|ï|ĩ|ī|ĭ|ǐ|į|ı/" => "",
            "/Ĵ/" => "",
            "/ĵ/" => "",
            "/Ķ/" => "",
            "/ķ/" => "",
            "/Ĺ|Ļ|Ľ|Ŀ|Ł/" => "",
            "/ĺ|ļ|ľ|ŀ|ł/" => "",
            "/Ñ|Ń|Ņ|Ň/" => "",
            "/ñ|ń|ņ|ň|ŉ/" => "",
            "/Ò|Ó|Ô|Õ|Ō|Ŏ|Ǒ|Ő|Ơ|Ø|Ǿ/" => "",
            "/ò|ó|ô|õ|ō|ŏ|ǒ|ő|ơ|ø|ǿ|º/" => "",
            "/Ŕ|Ŗ|Ř/" => "",
            "/ŕ|ŗ|ř/" => "",
            "/Ś|Ŝ|Ş|Ș|Š/" => "",
            "/ś|ŝ|ş|ș|š|ſ/" => "",
            "/Ţ|Ț|Ť|Ŧ/" => "",
            "/ţ|ț|ť|ŧ/" => "",
            "/Ù|Ú|Û|Ũ|Ū|Ŭ|Ů|Ű|Ų|Ư|Ǔ|Ǖ|Ǘ|Ǚ|Ǜ/" => "",
            "/ù|ú|û|ũ|ū|ŭ|ů|ű|ų|ư|ǔ|ǖ|ǘ|ǚ|ǜ/" => "",
            "/Ý|Ÿ|Ŷ/" => "",
            "/ý|ÿ|ŷ/" => "",
            "/Ŵ/" => "",
            "/ŵ/" => "",
            "/Ź|Ż|Ž/" => "",
            "/ź|ż|ž/" => "",
            "/Æ|Ǽ/" => "E",
            "/ß/" => "s",
            "/Ĳ/" => "J",
            "/ĳ/" => "j",
            "/Œ/" => "E",
            "/ƒ/" => ""];
        $quotedReplacement = preg_quote($separator, '/');
        $merge = [
            '/[^\s\p{Zs}\p{Ll}\p{Lm}\p{Lo}\p{Lt}\p{Lu}\p{Nd}]/mu' => ' ',
            '/[\s\p{Zs}]+/mu' => $separator,
            sprintf('/^[%s]+|[%s]+$/', $quotedReplacement, $quotedReplacement) => '',
        ];
        $map = $_transliteration + $merge;
        unset($_transliteration);
        return preg_replace(array_keys($map), array_values($map), $string);
    },

    /**
     * Separator to use when generating slugs.  Defaults to a hyphen.
     */

    'separator' => '-',

    /**
     * Enforce uniqueness of slugs?  Defaults to true.
     * If a generated slug already exists, an incremental numeric
     * value will be appended to the end until a unique slug is found.  e.g.:
     *
     *     my-slug
     *     my-slug-1
     *     my-slug-2
     */

    'unique' => true,

    /**
     * If you are enforcing unique slugs, the default is to add an
     * incremental value to the end of the base slug.  Alternatively, you
     * can change this value to a closure that accepts three parameters:
     * the base slug, the separator, and a Collection of the other
     * "similar" slugs.  The closure should return the new unique
     * suffix to append to the slug.
     */

    'uniqueSuffix' => null,

    /**
     * Should we include the trashed items when generating a unique slug?
     * This only applies if the softDelete property is set for the Eloquent model.
     * If set to "false", then a new slug could duplicate one that exists on a trashed model.
     * If set to "true", then uniqueness is enforced across trashed and existing models.
     */

    'includeTrashed' => false,

    /**
     * An array of slug names that can never be used for this model,
     * e.g. to prevent collisions with existing routes or controller methods, etc..
     * Defaults to null (i.e. no reserved names).
     * Can be a static array, e.g.:
     *
     *    'reserved' => array('add', 'delete'),
     *
     * or a closure that returns an array of reserved names.
     * If using a closure, it will accept one parameter: the model itself, and should
     * return an array of reserved names, or null. e.g.
     *
     *    'reserved' => function( Model $model) {
     *      return $model->some_method_that_returns_an_array();
     *    }
     *
     * In the case of a slug that gets generated with one of these reserved names,
     * we will do:
     *
     *    $slug .= $separator + "1"
     *
     * and continue from there.
     */

    'reserved' => null,

    /**
     * Whether to update the slug value when a model is being
     * re-saved (i.e. already exists).  Defaults to false, which
     * means slugs are not updated.
     *
     * Be careful! If you are using slugs to generate URLs, then
     * updating your slug automatically might change your URLs which
     * is probably not a good idea from an SEO point of view.
     * Only set this to true if you understand the possible consequences.
     */

    'onUpdate' => true,

];


زمانی که از 
resource controller
استفاده می کنیم خودش روت ها را ایجاد میکند و نیازی نیست دیگر ما خودمان ایجاد کنید
با زدن دستور زیر می توانیم روت هایی که خودش ایجاد کرده است را ببنیم

php artisan route:list



برای ایجاد 
sweet alert
در لاراول از کتابخانه 

uxweb/sweet alert 

استفاده میکنیم
	
https://github.com/uxweb/sweet-alert

composer require uxweb/sweet-alert

 add   @include('sweet::alert')  to master
 
 
بعد 

npm install sweetalert --save-dev
	

بعد داخل فایل های جاوااسکریپست اضافه می کنیم و بعد دوباره کامپیال می کنیم

npm run dev

حالا می توانید از فساد استفاده کنید یا تابع

fecads
use SweetAlert;

public function store()
{
    SweetAlert::message('Robots are working!');

    return Redirect::home();
}	
	
SweetAlert::message('Message', 'Optional Title');

SweetAlert::basic('Basic Message', 'Mandatory Title');

SweetAlert::info('Info Message', 'Optional Title');

SweetAlert::success('Success Message', 'Optional Title');

SweetAlert::error('Error Message', 'Optional Title');

SweetAlert::warning('Warning Message', 'Optional Title');


تابع 

alert()->message('Message', 'Optional Title');

alert()->basic('Basic Message', 'Mandatory Title');

alert()->info('Info Message', 'Optional Title');

alert()->success('Success Message', 'Optional Title');

alert()->error('Error Message', 'Optional Title');

alert()->warning('Warning Message', 'Optional Title');

alert()->basic('Basic Message', 'Mandatory Title')->autoclose(3500);

alert()->error('Error Message', 'Optional Title')->persistent('Close');


/**
 * Destroy the user's session (logout).
 *
 * @return Response
 */
public function destroy()
{
    Auth::logout();

    alert()->success('You have been logged out.', 'Good bye!');

    return home();
}

برای نمایش کلمه فعال به جای 
1
گه در دیتابیس ذخیره کردیم می توانیم از 
accessor
استفاده کنیم

in model

public function getIsActiveAttribute($is_active)
{
	return $is_active ? 'فعال' : 'غیرفعال';
}	
	
$brand->getRawOriginal('is_active')  ==> مقدار اصلی دستابیس را برمی گرداند و  اکسسوری را روی مدل اعمال کردیم نادیده می گیرد



برای تبدیل تاریخ شمسی و میلادی به یک دیگر می توانیم از پکیج 
verta
استفاده کنیم 

حتما حتما  داکیومنت خوانده شود


https://hekmatinasser.github.io/verta/


composer require hekmatinasser/verta

برای  استفاده 
{{ verta($brand->created_at) }}
	
استفاده به عنوان فساد 

// config/app.php
'providers' => [
    ...
    Hekmatinasser\Verta\Laravel\VertaServiceProvider::class,
],

'alias' => [
    ...
    'Verta' => Hekmatinasser\Verta\Verta::class,
]	
	
	
	
use Verta;
// or
use Hekmatinasser\Verta\Verta;	
	
	
می توانیم برای آن فرمت هم بدهیم

{{ verta($brand->updated_at)->format('Y-n-j') }}	
	
	
	
با این دستور می توانیم بعد از عملیات کاربر را به هر صفحه ای خواستیم منتقل کنیم 
return redirect()->route('admin.attributes.index');

اگر خواستیم کاربر بعد از عملیات دوباره به همین صفحه ای که در آن بوده ایم برگردد از کد زیر استفاده می کنیم 

return redirect()->back();
	
	
در حالت عادی بوت استرپ  مولتی  سلکت را پشتیبانی نمی کند که در این ثورت باید از یک کتابخانه کمکی استفاده کنیم 

bootstrap select

npm i bootstrap-select

// js
require('bootstrap-select');	

//css
@import "~bootstrap-select/sass/bootstrap-select.scss";



<select data-live-search="true" multiple name="atttribute_ids[]" class="selectpicker form-control" id="atttributeSelect">

	<option >غیرفعال</option>
	<option >fsd</option>
	<option>fgf</option>
</select>	
	
 $('.selectpicker').selectpicker();	
	

استایل های راستچین کردن


// Bootstrap Select RTL & Customize
.filter-option-inner-inner {
    text-align: right;
}

.bootstrap-select > button {
    color: #6e707e;
    background-color: #fff;
    border-color: #d1d3e2;
}

.bootstrap-select > button:not(:disabled):not(.disabled):active,
.bootstrap-select > button:not(:disabled):not(.disabled).active,
.show > .btn-light.dropdown-toggle {
    color: #6e707e;
    background-color: #fff;
    border-color: #d1d3e2;
}

.bootstrap-select > button:focus,
.bootstrap-select > button.focus {
    color: #6e707e;
    background-color: #fff;
    border-color: #d1d3e2;
    box-shadow: 0 0 0 0.2rem rgba(78, 115, 223, 0.25);
}

.bootstrap-select .dropdown-menu li {
    text-align: right;
}

.bootstrap-select.show-tick .dropdown-menu li a span.text{
    margin-right: 10px;
}
	
برای اینکه قابلیت سرچ هم داشته باشد  به روش زیر عمل می کنیم

data-live-search="true"

<select data-live-search="true" multiple name="atttribute_ids[]" class="selectpicker form-control" id="atttributeSelect">

	
یکی از قابلیت های خوب این کتابخانه این است که فارسی را هم پشتیبانی می کند 

require('bootstrap-select');
require('bootstrap-select/dist/js/i18n/defaults-fa_IR');
	
حتی می توانیم برای آن تایتل ست کنیم 

$('#atttributeSelect').selectpicker({
	'title' : "انتخاب ویژگی"
});	

زمانی که یک متغییر را از کنترلر به ویو پاس می دهیم با  دایرکتیو زیر می توانیم آن را دریافت کنیم

@json($var)	
	
	
validation
برای یونیک بود ن 
"slug"=>"required|unique:categories,slug",

$category = Category::create ===> ایدی فیلید که ایجاد شده است را برمی گرداند و داخل متغییر می ریزد	
	
	
// latest ==> order by create_at desc
// oldest ==> order by create_at asc	
	
	
	
	
داخل 
foreach
لاراول به 
$loop
دسترسی داریم

@foreach ($category->attribute as $attr)
	{{ $attr->name }} {{$loop->last ? "" : ","}}
@endforeach
	
	
دسترسی به جدول 
pivot

@foreach ($category->attributes()->wherePivot("is_variation", 1)->get() as $attr)
	{{ $attr->name}} 
@endforeach 
	

in_array( موردی که می خواهیم چک کنیم , ارابیه )
in_array($attr->id , $category->attributes()->pluck('id')->toArray() ) ? "selected" : "" 

pluck('id')  ->  تنها ایدی را برمی گرداند 
->toArray()   -> تبدیل می کند به ارایه 


مواردی مانند 
slug
که یونیک هستند را باید به شکل زیر اپدیت کنیم 
"slug"=>"required|unique:categories,slug,".$category->id,	
	
	
اصلاح  اینپوت تایپ فایل

.custom-file-label::after {
    content: "فایل";
    right: unset;
    left: 0;
    border-left: unset;
    border-right: inherit;
    border-radius: 0.35rem 0 0 0.35rem;
}	
	
 $("#primary_image").change(function(){
	var fileName = $(this).val();
	$(this).next('.custom-file-label').html(fileName);
});	
	
	
	
Category $category  ==> route model binding	
	
	
	
برای ایجاد ویژگی های متغییر از پلاگین جی کوئری 
czMore

استفاده می کنیم 

download from github
	
	
	

اعتبارسنجی برای تصاویر

"primary_image" => "required|mimes:jpg,png,jpeg,svg",
	
"images" => "required",
"images.*" => "mimes:jpg,png,jpeg,svg", ==> برای مقادیر ارایه ای استفاده می کنیم و این روش تمام  انچه در ارایه است را به ترتیب بررسی می کند 


اعتبار سنجی برای ارایه های دوبعدی 

"variation_values.*.*" => "required",  > ali[x][y]
	


برای ساختن تاریخ و اضافه کردن آن به اسم فایل ها هنگام اپلود تا یونیک باشند  ما از کتابخانه کربن استفاده می کنیم


اپلود تصویر در لاراول باید به شکل زیر باشد 


$year = Carbon::now()->year;
$month = Carbon::now()->month;
$day = Carbon::now()->day;
$hour = Carbon::now()->hour;
$minute = Carbon::now()->minute;
$second = Carbon::now()->second;
$microsecond = Carbon::now()->microsecond;
$fileNameImage = $year.'_'.$month.'_'.$day.'_'.$hour.'_'.$minute.'_'.$second.'_'.$microsecond."_". $request->primary_image->getClientOriginalName();
$request->primary_image->move(public_path(env('PRODUCTS_IMAGES_UPLOAD_PATH')) , $fileNameImage);
        
	
->getClientOriginalName();    /  اسم اصلی فایل را که کاربر اپلود کرده برمی گرداند 



ساخت هلپر فانکشن سفارشی در لاراول

in app folder  => create  helpers.php

use Carbon\Carbon;

function generateFileName($name){
    $year = Carbon::now()->year;
    $month = Carbon::now()->month;
    $day = Carbon::now()->day;
    $hour = Carbon::now()->hour;
    $minute = Carbon::now()->minute;
    $second = Carbon::now()->second;
    $microsecond = Carbon::now()->microsecond;
    return $year.'_'.$month.'_'.$day.'_'.$hour.'_'.$minute.'_'.$second.'_'.$microsecond."_". $name;      
}

in composer.json

"autoload": {
	"psr-4": {
		"App\\": "app/",
		"Database\\Factories\\": "database/factories/",
		"Database\\Seeders\\": "database/seeders/"
	},
	"files": [
		"app/helpers.php"
	]
},


in cmd   composer dumpautoload


حالا در هر فایل یا هرجایی از پروژه که خواستیم می توانیم این  تابع را فراخوانی کنیم 


ساخت یک کنترلر برای اپلود تصاویر تا وقتی خواستیم تصویری اپلود کنیم  فقط آن را صدا بزنیم 

php artisan make:controller Admin\ProductImageController

public function upload($image)
{
	// این تابع به صورت هلپر فانکشن در  
	// app/helper.php
	// تعریف شده است
	 
	$fileNameImage = generateFileName($image->getClientOriginalName());
	
	$image->move(public_path(env('PRODUCTS_IMAGES_UPLOAD_PATH')) , $fileNameImage);
	
	return  $fileNameImage;
}	

بهتر است مسیر ذخیره فایل های اپلودی را به این ثورت ذخیره کنیم تا بعدا اگر خواستیم تغییر دهیم  فقط فایل 
.env
را تغییر دهیم 


حالا در کنترلر های دیگر به این شگل از آن استفاده می کنیم

$ProductImageController = new ProductImageController();
$fileName = $ProductImageController->upload($request->primary_image);
	
$fileName  --> شامل اسم فایل برای ذخیره در دیتابیس 

	
	
	



@foreach ($product->attributes as $attr)
	<div class="form-group col-md-3">
		<label for="brandSelect">{{ \App\Models\Attribute::find($attr->attribute_id)->name }}</label>
		<input type="text" class="form-control" value="{{ $attr->value }}" disabled>
	</div>
@endforeach	
	
به این سبک از کوئری که ما داخل یک  حلقه یک کوئری دیگر می زنیم 
n+1 
کوئری می گویند که در دیتاهای بزرگ مشکل ساز می شود به همین دلیل لارواول یک روش برای اینکار پیشنهاد می دهد 


in model 
 public function attribute(){
        return $this->belongsTo(Attribute::class);
    }
	
in controller
$attributes = $product->attributes()->with('attribute')->get();
$attributes = $product->attributes()->with('اسم رابطه ای گه در مدل ایجاد کردیم')->get();
return view('admin.products.show' , compact('product' , 'attributes'));
    
   
in view

 @foreach ($attributes as $attr)
<div class="form-group col-md-3">
<label for="brandSelect">{{ $attr->atrribute->name}}</label>
	<input type="text" class="form-control" value="{{ $attr->value }}" disabled>
</div>
@endforeach	
	
	
	
	
	
	
	
date picker  شمسی 	
	
برای این منظور از کتابخانه زیر استفاده می کنیم

MD.BootstrapPersianDateTimePicker
	
https://github.com/Mds92/MD.BootstrapPersianDateTimePicker

برای 
vue 
هم پکسج زیر عالی است

https://talkhabi.github.io/vue-persian-datetime-picker/#/	
	
	
	
@import "~bootstrap-select/sass/bootstrap-select.scss";

require('md.bootstrappersiandatetimepicker/dist/jquery.md.bootstrap.datetimepicker.js');

$('#id').MdPersianDateTimePicker({ 
  targetTextSelector: '#inputTextDate1',
  targetDateSelector: '#inputHiddenDate1',
   englishNumber:true,
	enableTimePicker:true,
	textFormat: "yyyy-MM-dd HH:mm:ss"
});


.mds-bootstrap-persian-datetime-picker-popover{
	max-width:fit-content !important;
}

توجه داشته باشید که مقدار اینپوت اگر فرمت زمان نباشد ارور می دهد
value  ==>  باید فرمت زمانی باشد و اگر متن قرار دهیم ارور می دهد 


تاریخ را حتما به صورت میلادی در دیتابیس ذخیره کنید 


برای این که اعتبار سنجی انجام دهیم که ایا این ایدی در جدول وجود دارد یا نه 

"brand_id" => "required|exists:brands,id",


// تبدیل تاریخ شمسی به میلادی  با هلپر فانکشنی که تعریف کردیم 
           
in helper.js

function convertJalaliToGregorian($date){
	if($date == null){
        return null;
    }
    $pattern = '/[-\s]/';
    $date_from_split = preg_split($pattern , $date);
    $date_from_arr = verta()->getGregorian($date_from_split[0],$date_from_split[1],$date_from_split[2]); 

    return implode("-" , $date_from_arr) . " " . $date_from_split[3];
}
	
convertJalaliToGregorian( تاریخ شمسی )	
	
	
	
	
	
	

?>














			


		</code>
	</pre>
	
</body>
</html>